<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    面试汇总 |  Victor&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="Victor's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-面试汇总"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面试汇总
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/08/23/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/" class="article-date">
  <time datetime="2019-08-23T06:31:28.000Z" itemprop="datePublished">2019-08-23</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">45.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">170 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>自我介绍</p>
<p><a href="https://victor-huihui.gitee.io/2021/03/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM</a></p>
<p>您好，我叫朱会会，来自华东师范大学数据科学与工程学院，现在是一名研二的学生。目前在京东实习，负责组内自研的内容流量平台的维护与研发。</p>
<p>研二作为主力开发学院的在线网课平台-水杉在线，除了负责后端开发之外，还负责整个开发平台的CICD能力和习题推荐系统的搭建，目前水杉在线的用户有接近三千多名本科生和研究生用户，前段时间也是有幸参与了世界人工智能大会的展览。</p>
<p>非常荣幸有机会参加今天的面试。以上就是我的自我介绍，谢谢。</p>
<h1 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h1><p>项目基于组内自研的内容流量平台-cfc，用于流量统计、链路追踪、降级限流等等功能，我开发的是一个智能兜底的需求，主要是用来兜底一些异常情况，具体是这样的，系统接入cfc后，可以在cfc的管理页面来设置开启使用手动兜底还是智能兜底，手动兜底的功能需要开发者自己把握，因为有些异常可能是业务的异常，不需要进行处理和兜底，这时候填写一个无序兜底的异常白名单，在抛出异常进入兜底窗口的时候，会跳过这些异常，不进行处理。还需要手动填写一个json的兜底方案。智能兜底是这样的，我们在单例的拦截器中维护了一个concurrenthashmap，map以traceName为key，存储了上一次的正常返回结果和时间戳，每半个小时更新一次。这样当用户进入异常处理窗口的时候，就直接从内存中取出数据返回。大概就是这样。（这里可能会问到单例模式和hashmap）。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>SpringMVC中的interceptor拦截请求主要是通过HandlerInterceptor来实现的，定义拦截器的方式有两种，一是实现或继承了HandlerInterceptor，二是实现或继承WebRequestInterceptor接口。</p>
<ul>
<li>preHandle：返回boolean类型，返回false请求结束，后续的Interceptor和controller不会执行；返回true会继续调用下一个Interceptor的prehandle方法，是最后一个Interceptor的时候调用controller方法。</li>
<li>postHandle：controller之后执行，在DispatcherServlet进行视图返回渲染之前被调用，所以可以在这个方法中对controller处理之后的modelAndView对象进行操作。</li>
<li>在afterCompletion：在整个请求结束之后，在DispatcherServlet渲染了对用的视图之后执行。</li>
</ul>
<p>当preHandle时true的时候，postHandle才会执行，当为false的时候，afterCompletion仍然会执行。</p>
<p>对于过滤器，逻辑需要复写invoke方法，所以就一个invoke方法。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p>
<p>单例模式的使用场景</p>
<ul>
<li>有频繁实例化然后销毁的情况，也就是频繁的 new 对象，可以考虑单例模式；</li>
<li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象；</li>
<li>频繁访问 IO 资源的对象，例如数据库连接池或访问本地文件；</li>
</ul>
<p>在 Spring 中的 bean 默认就是单例的，拦截器也是单例的。</p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>优点：简单，只有第一次获取才生成实例，不浪费内存</p>
<p>缺点：线程不安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 静态私有变量，确保能够在静态方法中访问到该类变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="comment">// 将构造函数私有化，不允许外部调用构造函数创建对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取单例是静态的方法，因为不能通过构造函数创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次调用时才实例化</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h3><p>优点：线程安全且第一次调用才生成初始化，节约内存</p>
<p>缺点：加锁影响效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了防止线程不安全，加上synchronized锁，锁的是this.class对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>优点：不加锁，获取单例时效率高</p>
<p>缺点：类加载就初始化，浪费内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p>优点：在多线程环境下能够保存高性能</p>
<p>缺点：实现较为复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="comment">// volatile关键字防止指令重排导致的问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="comment">// 线程1执行到这，由于指令重排可能导致先将引用（分配内存）给实例，再调用构造方法，</span></span><br><span class="line">                    <span class="comment">// 如果线程2在调用构造方法之前调用getInstance()，那么此时INSTANCE不为null此时</span></span><br><span class="line">                    <span class="comment">// 线程2拿到的是没有执行初始化的实例</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h3><p>优点：只有第一次调用getInstance()后，实例才会创建，而不是只要类一加载就创建，节省内存，同时类加载时JVM会保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="水杉在线"><a href="#水杉在线" class="headerlink" title="水杉在线"></a>水杉在线</h1><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>水杉在线其实是一个多个子系统组成的平台，包括水杉学堂-类似于mooc形式，还有定制化的类似于gitlab的仓库，和OJ平台，我们做的的工作主要是门户和水杉学堂的开发，并且实现了多个平台登录的打通。</p>
<p>后端使用的是springcloud，前端是vue框架，所有文件都放在对象存储，通过Url引用访问。（估计会问到数据库，引申出和mysql相关的问题）。</p>
<h2 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD</h2><p><strong>为什么使用CICD</strong></p>
<p>其实我们最开始使用CICD的目的很简单，就是因为不断的打包发布太麻烦了，我们最初开发的时候其实是比较傻瓜式的，初期前端开发人员使用mock模拟数据和后端进度解耦，后端分成多个微服务同时开发，待后端开发者开发完成后在打包发布，进行前后端联调。因为不断的打包发布太麻烦，所以就去探索了一下CICD的相关实现，最终使用gitlab+docker compose实现了CICD的能力。</p>
<p>其实后来我们通过实践发现CICD有更多的好处，比如：</p>
<ul>
<li><p>过程比较透明</p>
<p>通过观察节点日志，服务失败，可以很方便看到哪一环节除了问题，方便开发人员更快的定位和解决问题。</p>
</li>
<li><p>方便自测隔离</p>
<p>我们现在的做法是，用户都往master分支push代码，当需要发布的时候，将master分支合并到prod分支触发CICD流程，实现新版本的发布。但是后来工具发现，可以以分支为单位，每个分支按自测需要新建一个CICD流程，这样就避免了代码污染的问题，每个开发者在自测的时候，不会影响到线上的环境或者别人的环境。</p>
</li>
</ul>
<p><strong>CICD实践</strong></p>
<p>借助gitlab和docker-compose来实现，这里需要为每个服务编写.gitlab-ci.yaml配置文件来定义流水线阶段分级与每个节点的具体逻辑的文件。还有dockerfile，用来构建镜像的文件，文本包含了一条条构建镜像需要的指令和说明。另外还需要一台runner机器，用来执行集成脚本的机器。我们也使用了阿里云的镜像服务</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/CICD.png" alt="CICD"></p>
<h2 id="习题推荐系统"><a href="#习题推荐系统" class="headerlink" title="习题推荐系统"></a>习题推荐系统</h2><p>我们希望赋予他更多的AI元素，例如在录入习题的时候，我们需要给习题添加标签，在前期我们更多的是实验室一起手动打标签，后来注意到百度的easydl有这种多标签分类，我们就用我们的数据在easydl平台训练了一个多标签分类的模型，再有新的数据进来的时候，可以进行自动的打标签。</p>
<p>习题推荐是因为我们平台一开始设计就有考试这块的业务，我们也提供了练习的功能，一开始的时候我们是这样设计的，建立Lucene索引，用户提供标签信息，我们去做匹配，当然也会做记录，例如这次抽到了哪些题目，还有用户的正确率这些信息，后来有了这些数据之后，我们就考虑来做推荐了，因为我们前期收集的数据还算标准，大概就是用户针对某个标签的正确率，这其实和商品的评分是一致的，可以拿来做推荐，这个目前我们更多的是在算法层面的研究。</p>
<h2 id="开源项目推荐"><a href="#开源项目推荐" class="headerlink" title="开源项目推荐"></a>开源项目推荐</h2><p>用户 90W</p>
<p>项目 450W</p>
<p> 交互数量1200W </p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p><strong>数据结构</strong></p>
<p>注意：拉链法是头插法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>put操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于7行的key是null的情况，是允许的，但是null无法调用hashcode()方法，所以使用第0个下标来存储key是null的键值对。</p>
<p>$therehold = capacity*loadFactor$</p>
<p><strong>hash阶段</strong></p>
<ul>
<li><p>由源码可知，hash的计算函数是<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，为什么有异或操作？</p>
<p>首先hash的值是一个32位的二进制，在得到hash值之后，需要执行<code>(n-1) &amp; hash</code>操作，当n很小的时候，前位都是0，而0与0或者1执行&amp;运算都是0，如果对于两个hash高位不同而低位相同，则很容易碰撞，所以需要执行一次异或操作，将前边的信息保留在后位。</p>
</li>
<li><p>为什么capcity是2的幂</p>
<p>因为最后计算桶位的时候，公式是<code>(n-1) &amp; hash</code>，如果n是2的幂，保证n-1是全为1的二进制数，如果不全是1，存在某一位为0，那么0和01的与运算都是0，增加碰撞的可能，本质上和上一个问题都是为了减少hash碰撞。</p>
</li>
<li><p>为什么是与运算而不是模</p>
<ul>
<li>位运算效率高</li>
<li>避免hashcode为负数的情况。</li>
</ul>
</li>
</ul>
<p><strong>put操作</strong></p>
<ul>
<li>table是null或者table.length()是0，则<code>resize</code></li>
<li>计算桶位index，table[i]==null，新建节点添加。添加成功后，判断实际存在的键值对个数是不是超过therehold，超过则<code>resize</code>。</li>
<li>如果table[i]不是null，则判断table[i]的首个元素是否和key一样，如果相同则直接覆盖value(相同指hashcode和equals)，否则判断table[i]是否为treenode，如果是红黑树，则在树中插入键值对，如果不是，则遍历table[i]，判断链表长度是否大于8，大于8则树化，在树中插入操作，否则进行链表的插入操作。遍历过程中若发现key存在则直接覆盖value</li>
</ul>
<p><strong>扩容操作</strong></p>
<p>用在两处：</p>
<ul>
<li>因为hashmap是懒加载，在第一次put的时候才会初始化，所以在第一次put进行resize初始化，16或者是传入的参数值。</li>
<li>put操作之后，需要检查size是不是已经超过therehold，超过则resize。若此时capacity已经大于了最大值，则把therehold置为Int的最大值，否则对capacity和therehold进行扩容操作。</li>
</ul>
<p><strong>扩容之后需要元素需要重新散列，但是不需要重新计算所有的哈希，只需要看看原来的哈希值新增的bit是1还是0就行，为什么呢？</strong></p>
<p>因为n右移了一位，最后在计算桶位的时候，得到的hash值肯定也多了一位，如果新增的一个bit是0，和1与运算还是0，不需要变动。如果新增的bit位变成了1，原来是00101是5，现在是100101是21=5+16。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>实现和hashmap类似，但是引入分段锁(segment)，每个锁维护几个桶(HashEntry)，多个线程可以同时访问不同分段锁上的桶，并发度就是segment的个数，默认是16.</p>
<p>jdk1.7采用分段锁机制，核心类是segment，继承重入锁<code>ReentrantLock</code>。而jdk8使用CAS(乐观锁)来支持更高的并发度，在CAS操作失败的时候使用内置锁synchronized。</p>
<p><strong>乐观锁？</strong></p>
<p>全称是比较并交换(Compare-and-Swap)，CAS指令需要有3个操作数，分别是内存地址V，旧的预期值A和新的值B。执行操作时，只有当V的值等于A，才将V的值更新为B。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>继承自hashmap，内部维护了一个双向链表，用来维护插入顺序或者LRU(最近最少使用)顺序，accessOrder决定了顺序，默认是false，此时维护的是插入顺序，如果是true，维护的是查找顺序。</p>
<p>最重要的是两个用于维护顺序的函数：</p>
<ul>
<li><p>afterNodeAccess</p>
<p>当第一个节点被访问时，如果accessOrder是true，则将该节点移到链表尾部。也就是说在指定为LRU顺序之后，在每次访问一个节点后，都将节点移到链表尾部，保证链表尾部是最近访问的节点，首部就是最近最久未使用的节点。</p>
</li>
<li><p>afterNodeInsertion</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在put操作执行之后，当removeEldestEntry()方法返回true时会移除最晚的节点，也及时链表首部节点first。removeEldestEntry默认是false，需要为true的时候需要继承LinkedHashMap并且覆盖这个方法，这再是实现LRU缓存的时候很有效，通过移除最近未使用的节点，保证缓存空间够用。</p>
</li>
<li><p>使用LinkedHashMap实现LRU缓存</p>
<ul>
<li>继承LinkedhashMap</li>
<li>设定最大缓存空间 MAX_ENTRIES</li>
<li>使用LinkedHashMap的构造函数设置accessOrder为true，开启LRU缓存。</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRY = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    LRU()&#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRY,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LRU&lt;Integer,String&gt; test = <span class="keyword">new</span> LRU();</span><br><span class="line">test.put(<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">test.put(<span class="number">2</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">test.put(<span class="number">3</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">test.get(<span class="number">1</span>);</span><br><span class="line">test.put(<span class="number">4</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">System.out.println(test.keySet());</span><br></pre></td></tr></table></figure>

<p>最后输出：[3,1,4]</p>
</li>
</ul>
<h2 id="WeakhashMap"><a href="#WeakhashMap" class="headerlink" title="WeakhashMap"></a>WeakhashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>entry继承自弱引用，下一次GC的时候会被回收，主要用来实现缓存。</p>
<p>tomcat中的<code>ConcurrentCache</code>使用W来实现缓存，采用的是分代缓存。</p>
<ul>
<li>经常使用的对象放在eden中，使用ConcurenthashMap实现，不担心被回收。</li>
<li>不常使用的对象放在longterm中，使用W实现，下一次GC会被回收。</li>
<li>get时，先从eden获取，没找到再到longterm获取，获取到放入eden。</li>
<li>put时，如果eden的大小超过size，将eden中的对象放入longtrem中，利用JVM进行回收。</li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="1、存储引擎"><a href="#1、存储引擎" class="headerlink" title="1、存储引擎"></a>1、存储引擎</h2><p>Mysql默认的存储引擎是InnoDB，在5.7版本只有InnoDB是支持事务的。</p>
<h3 id="MyISAM和InnoDB区别？"><a href="#MyISAM和InnoDB区别？" class="headerlink" title="MyISAM和InnoDB区别？"></a>MyISAM和InnoDB区别？</h3><p>在5.5之前，默认引擎是MyISAM 。优点有：全文索引，压缩，空间函数，但是不支持事务和行级锁，最大的缺陷是崩溃之后无法安全恢复，在5.5之后，引入InnoDB并成为默认引擎。</p>
<p><strong>两者的对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>行级锁</td>
<td>表级锁</td>
<td>表级锁和行<strong>级锁</strong>(默认)</td>
</tr>
<tr>
<td>事务和崩溃后安全恢复</td>
<td>不支持</td>
<td>支持，同时具有回滚，崩溃修复能力</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>MVCC</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>MVCC多版本控制，比单纯的锁更加高效，只在<code>Read Committed</code>和<code>Repetable read</code>两个隔离级别工作，可以使用乐观锁和悲观锁来实现。</p>
<p>MyISAM更注重性能。但不是首选。</p>
<h2 id="2、字符集与校对规则"><a href="#2、字符集与校对规则" class="headerlink" title="2、字符集与校对规则"></a>2、字符集与校对规则</h2><p>字符集指的是一种从而二进制编码到某类字符符号的映射。校对规则是指某种字符集下的排序规则。MySql中每一种字符集都会对应一系列的校对规则。</p>
<p>M采用的是类似继承的方式制定字符集的默认值，每个数据库和每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集(这些表在没有指定字符集的情况下，才会采用摩恩字符集)。</p>
<h2 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h2><p><a target="_blank" rel="noopener" href="https://krains.gitee.io/blogs/MySQL/MySQL%E7%B4%A2%E5%BC%95.html#b-tree">参考</a></p>
<p>索引的数据结构主要有：B树和哈希索引。哈希索引的底层就是哈希表，因为在绝大多数需求为单条记录查询的时候，可以选择哈希索引，其他情况下选择B树索引。</p>
<p>B树使用的是B+树。两种存储引擎的实现方式不同：</p>
<ul>
<li><p>MyIASM</p>
<p>叶节点的data区域存放是是数据记录的地址。在索引检索的时候，按照B树算法索引，指定的Key存在，则取出data域的值，然后以data域的值为地址读取对应的数据记录。这被称为“非聚簇索引”。</p>
</li>
<li><p>InnoDB</p>
<p>数据文件本身就是索引文件。树的叶节点data域保存了完整的数据记录，因此InnoDB表数据文件本身就是主索引，这称为“聚簇索引”。其余的索引作为辅助索引，辅助索引的data记录的是相应记录主键的值而不是地址。</p>
<p>在根据主索引搜索时，直接找到Key所在的节点；在根据辅助索引查找时，先取出主键的值，再走一遍主索引。因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，会造成主索引频繁分裂。</p>
</li>
</ul>
<h2 id="4、查询缓存"><a href="#4、查询缓存" class="headerlink" title="4、查询缓存"></a>4、查询缓存</h2><p>8.0版本移除，不实用。</p>
<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。</p>
<h2 id="5、事务"><a href="#5、事务" class="headerlink" title="5、事务"></a>5、事务</h2><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ul>
<li>原子性：事务是自小的执行单位。原子性确保动作要么全部完成，要么全部不执行。</li>
<li>一致性：数据库从一个正确状态变化到另一个一致性状态。</li>
<li>隔离性：并发访问数据库，两个用户的事务不干扰。并发事务之间的数据库是独立的。</li>
<li>持久性：对数据库的改变是持久的，即使数据库发生故障也不应该有影响。</li>
</ul>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><ul>
<li><p><strong>脏读</strong></p>
<p>一个事务修改数据库，还没提交。另一个事务读数据，因为这个数据还没提交，所以读出的是脏数据。对脏数据的操作可能不正确。</p>
</li>
<li><p>丢失修改</p>
<p>两个事务读一个数据，第一个事务修改之后第二个事务也修改，这样第一个事务修改的结果就丢失了。保留第二次修改的结果。</p>
</li>
<li><p>不可重复读</p>
<p>一个事务内多次读用一个数据，在两次读数据之间，由于第二个事务修改数据，导致两次读的数据不同，称为不可重复读。</p>
</li>
<li><p>幻读</p>
<p>它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
</li>
</ul>
<p>不可重复读的重点是多次读取发现某些列被修改。</p>
<p>幻读重点是多次读取发现记录增多后者减少。</p>
<h3 id="数据库的隔离级别："><a href="#数据库的隔离级别：" class="headerlink" title="数据库的隔离级别："></a>数据库的隔离级别：</h3><ul>
<li><p>读未提交</p>
<p>允许读取尚未提交的数据变更，可能导致脏读幻读或者不可重复读。</p>
</li>
<li><p>读已提交</p>
<p>允许读取并发事务已经提交的数据。避免脏读，但是幻读和不可重复读可能发生。</p>
</li>
<li><p>可重复读</p>
<p>对同一字段的多次读取结果都是一致的，除非被本身事务自己修改。</p>
</li>
<li><p>可串行化</p>
<p>最高的更隔离级别。服务ACID，所以的事务逐个执行，这样事务之间不产生干扰</p>
</li>
</ul>
<p>InnoDB默认是可重复读。使用的是next-key lock算法，避免幻读，已经达到了可串行化的隔离级别。隔离级别越低，锁越少，所以大部分数据库的隔离级别都是读已提交，但是InnoDB使用可重复读，并且不会有性能损失。InnoDB在分布式事务的情况下使用可串行化的隔离级别。</p>
<h3 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h3><ul>
<li>表级锁：粒度最大的锁，整张表加锁。实现简单，资源消耗少，加锁快，不会出现死锁。出发锁冲突的概率高，并发度最低。</li>
<li>行级锁：粒度最小，当前操作行加锁。大大减少数据库操作的冲突，并发度高。开销大，加锁慢，会出现死锁。</li>
</ul>
<p>InnoDB存储引擎的算法有三种：</p>
<ul>
<li>Reacord lock：单行记录锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身。</li>
<li>Next-key lock：record+gap，包含记录本身。</li>
</ul>
<p>补充：</p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h2 id="6、大表优化"><a href="#6、大表优化" class="headerlink" title="6、大表优化"></a>6、大表优化</h2><p>MYSQL表单过大，数据库的CRUD性能下降，措施如下：</p>
<ul>
<li><p>限定数据范围</p>
<p>禁止不带任何限制数据范围条件范围的查询语句。</p>
</li>
<li><p>读写分离</p>
<p>主库写，从库读。</p>
</li>
<li><p>垂直分区</p>
<p>数据表的相关性进行拆分。把一张列比较多的表拆分成多张表。</p>
<ul>
<li>优点：列数据变小，在查询时减少读取的block数，减少IO次数。简化表结构，易于维护。</li>
<li>缺点：主键冗余，需要管理冗余列，引起join操作，事务变得复杂。</li>
</ul>
</li>
<li><p>水平分区</p>
<p>保持数据表结构不变，通过策略存储数据分片，这样每一片数据分散到不同的表或者库中，达到分布式的目的。</p>
<p>水平拆分支持大的数据量。但是分表仅仅解决了单一表数据量大的问题，但是表数据还在同一台机器上，其实对于并发能力没有太多提升。所以水平拆分最好分库。</p>
<p>分片支持大的数据量存储，但是分片事务难以解决，逻辑复杂，尽量不分片，非要分片，尽量选择客户端分片，可以减少一次和中间件的网络IO</p>
<p>数据库分片的两种常见方案：</p>
<ul>
<li>客户端代理：<strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> （推荐） 、阿里的TDDL是两种比较常用的实现。</li>
<li>中间件代理：<strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
</li>
</ul>
<p><strong>分库分表之后，ID主键如何处理：</strong></p>
<ul>
<li>UUID：太长无序不可读，查询效率低，比较适合用于生成名字唯一的标识比如文件的名字。</li>
<li>自增ID：两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li>redis：性能好，灵活方便，不依赖数据库。</li>
<li>雪花算法</li>
</ul>
<h2 id="7、池化"><a href="#7、池化" class="headerlink" title="7、池化"></a>7、池化</h2><p>这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd">池化设计思想</a>介绍的还不错。</p>
<p>数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。<strong>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中</strong>。 连接池还减少了用户必须等待建立与数据库的连接的时间。</p>
<h2 id="8、常见问题："><a href="#8、常见问题：" class="headerlink" title="8、常见问题："></a>8、常见问题：</h2><h3 id="行存储与列存储"><a href="#行存储与列存储" class="headerlink" title="行存储与列存储"></a>行存储与列存储</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35622907">摘自</a></p>
<p>主流的（OLTP）数据库大多数采用行存储，随着分析性数据库（OLAP）数据库的兴起，列存储又变的流行。</p>
<p>列存储优势一方面体现在存储上节约空间，减少IO。另一方面依靠列式数据结构做了计算上的优化。</p>
<h4 id="什么是列式存储"><a href="#什么是列式存储" class="headerlink" title="什么是列式存储"></a>什么是列式存储</h4><p><img src="https://pic2.zhimg.com/80/v2-8b8fc4a44e17f2d10b82a7f802a31011_720w.jpg" alt="img"></p>
<p>传统OLTP数据库通常采用行存储，所有的列依次排列成一行，以行为单位存储，再配合B+树或者SS-Table作为索引，就能快速通过主键找到相应的行数据。</p>
<p>行存储对于OLTP场景很自然：大多数操作都是以实体为单位，把一行数据存储在相邻的位置是个很好的选择。</p>
<p>对于OLAP场景来说，一个典型的查询需要遍历整张表，进行分组、排序、聚合等操作，这样一来行存储就没有优势了。更糟糕的是，分新型SQL通常不会用到所有的列，仅仅对某些感兴趣的列运算，一行中的无关列也不得不参与扫描。</p>
<p>列存储就是为这样的需求设计的。如下图所示，同一列的数据被一个一个紧挨着放在一起，表的每列构成一个长数组。</p>
<p><img src="https://pic2.zhimg.com/80/v2-57bf414b5fc1af277cbf74d9e4412bc1_720w.jpg" alt="img"></p>
<p>列存储对于OLTP的场景不友好，一行数据的写入需要同时修改多个列。但是对于OLAP数据库有着很大的优势。</p>
<ul>
<li>当查询语句只设计到部分列时，只需要扫描相关的列。</li>
<li>每一列的数据都是相同类型，彼此间的相关性更大，对列数据存储的压缩效率高。</li>
</ul>
<blockquote>
<p><strong>Bigtable(HBase)是列存储吗？</strong></p>
<p>其实不是列存储，是按照key-value pair存储数据，和列存储无关系。</p>
<p>但是BT有列簇概念。列簇可以指定给某个locality group，决定改列簇数据的物理位置，从而让同一主键的各个列簇分别存放在最优的物理节点上，</p>
<p>由于 column family 内的数据通常具有相似性，对它做压缩要比对整个表压缩效果更好。</p>
<blockquote>
<p>列式数据库可以是关系型、也可以是 NoSQL，这和是否是列式并无关系。</p>
</blockquote>
</blockquote>
<h4 id="DSM-分页模式"><a href="#DSM-分页模式" class="headerlink" title="DSM 分页模式"></a>DSM 分页模式</h4><p>我们知道，由于机械磁盘受限于磁头寻址过程，读写通常都以一块（block）为单位，<strong>故在操作系统中被抽象为块设备</strong>，与流设备相对。这能帮助上层应用是更好地管理储存空间、增加读写效率等。这一特性直接影响了数据库储存格式的设计：数据库的 Page 对应一个或几个物理扇区，让数据库的 Page 和扇区对齐，提升读写效率。</p>
<p>大多数服务于在线查询的DBMS采用NSM即安行存储的方式，将完整的行从header开依次存放。页的最后有一个索引，存放了页内各行的起始偏移量。由于每行的长度不一定固定，索引可以帮我们快速找到需要的行，无序逐个扫描。但是缺点在于，如果每次只涉及到很小的一部分列，那多余的列依然浪费内存以及CPU cache，导致更多的IO，为了避免这一问题，分析性数据库采用DSM列存储：将relationan按照列拆分成多个sub-relation。类似的，在页尾部存放一个索引。</p>
<p>NSM可以快速取出某一行的数据，因为一行的数据保存在同一页；DSM能更好的利用CPU cache以及更紧凑的压缩。</p>
<blockquote>
<p>分布式储存系统虽然不再有页的概念，但是仍然会将文件切割成分块进行储存，但分块的粒度要远远大于一般扇区的大小（如 HDFS 的 Block Size 一般是 128MB）。更大的读写粒度是为了适应网络 IO 更低的带宽以获得更大的吞吐量，但另一方面也牺牲了细粒度随机读写。</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-f6b341f0aa6345e5fe7f1c3dc52da510_720w.jpg" alt="img"></p>
<h4 id="列存储与分布式文件系统"><a href="#列存储与分布式文件系统" class="headerlink" title="列存储与分布式文件系统"></a>列存储与分布式文件系统</h4><p>在现代的大数据架构中，GFS，HDFS等分布式文件系统已经成为存放按规模数据集的主流方式，。分布式文件系统相比单机的磁盘，具备多副本高可用容量大成本低等优势，但是也有一些单机架构没有的问题。</p>
<ul>
<li>读写均要经过网络，吞吐量可以追平甚至超过硬盘，但是<strong>延迟要比硬盘大得多</strong>，且受网络环境影响很大。</li>
<li>可以进行大吞吐量的顺序读写，但随机访问性能很差，大多<strong>不支持随机写入</strong>。为了抵消网络的 overhead，通常写入都以几十 MB 为单位。</li>
</ul>
<p>以上缺点对于重度依赖读写的OLTP场景数据库来说是致命的。所以很多定位于OLAP的列存储放弃OLTP能力，从而构建在分布式文件系统之上。</p>
<p>充分发挥分布式文件系统的性能，有以下几种方式：按块读取数据，流式读取，追加写入等。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文介绍了列式存储的存储结构设计。抛开种种繁复的细节，我们看到，以下这些思想或设计是具有共性的。</p>
<ol>
<li><strong>跳过无关的数据</strong>。从行存到列存，就是消除了无关列的扫描；ORC 中通过三层索引信息，能快速跳过无关的数据分片。</li>
<li><strong>编码既是压缩，也是索引</strong>。Dremel 中用精巧的嵌套编码避免了大量 NULL 的出现；C-Store 对 distinct 值的编码同时也是对 distinct 值的索引；PowerDrill 则将字典编码用到了极致（见下一篇文章）。</li>
<li><strong>假设数据不可变</strong>。无论 C-Store、Dremel 还是 ORC，它们的编码和压缩方式都完全不考虑数据更新。如果一定要有更新，暂时写到别处、读时合并即可。</li>
<li><strong>数据分片</strong>。处理大规模数据，既要纵向切分也要横向切分，不必多说。</li>
</ol>
<h3 id="MYSQL复制"><a href="#MYSQL复制" class="headerlink" title="MYSQL复制"></a>MYSQL复制</h3><p>摘自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/63c1a1babfd1">简书</a></p>
<blockquote>
<p>保证主服务器(master)和从服务器(Slave)的数据是一致性的，向master插入数据后，slave会自动从master把修改的数据同步过来(有一定延迟)，通过这种方式保证数据一致性，就是mysql复制。</p>
</blockquote>
<h4 id="复制能解决什么问题？"><a href="#复制能解决什么问题？" class="headerlink" title="复制能解决什么问题？"></a>复制能解决什么问题？</h4><ul>
<li><p>高可用和故障切换</p>
<p>master挂掉后可以指定一台slave充当master继续保证服务运行。</p>
</li>
<li><p>负载均衡</p>
<p>开发中可能会遇到锁表，导致暂时不能使用读的操作，使用主从复制，主库负责写，从库负责读，这样即使主库锁表，读从库也能保证业务的正常运行。</p>
<p>调查发现一般读写的比例是10:1，所以需要多个slave。保证了系统的高可用。</p>
</li>
<li><p>数据备份</p>
</li>
<li><p>业务模块化</p>
<p>可以一个业务模块读取slave，再针对不同的业务场景进行数据库的索引创建和根据业务选择mysql引擎，不同的slave可以根据不同需求设置不同的索引和存储引擎。</p>
</li>
</ul>
<p><strong>主从节点需要注意：</strong></p>
<p>(1)主从服务器操作系统版本和位数一致；<br>(2) Master和Slave数据库的版本要一致；<br>(3) Master和Slave数据库中的数据要一致；<br>(4) Master开启二进制日志，Master和Slave的server_id在局域网内必须唯一；</p>
<h4 id="复制的流程"><a href="#复制的流程" class="headerlink" title="复制的流程"></a>复制的流程</h4><ul>
<li>master将数据改变写到二进制日志(binary log)中，也就是配置文件login-bin 指定的文件。</li>
<li>slave通过线程IO读取日志文件并写入到中继日志（relay log）</li>
<li>slave重做中继日志中的事件，把中继日志的事件信息一条条的本地执行，完成数据在本地的存储，从而实现将改变反映到他自己的数据（数据重放）。</li>
</ul>
<p><strong>复制涉及到三个线程</strong>：</p>
<ul>
<li><p>主节点binary log dump线程（IO线程）</p>
<p>slave连接master时，master创建log dump线程，发送bin-log内容。在读取bin-log中的操作时，线程会给bin-log加锁。</p>
</li>
<li><p>从节点IO线程‘</p>
<p>当从节点执行<code>start slave</code>命令之后，从节点创建一个IO线程来连接主节点，请求从主库中更新bin-log。IO线程收到主节点的binlog sump线程发来的更新之后，保存在本地的relay-log中。</p>
</li>
<li><p>从节点SQL线程</p>
<p>读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据库的一致性。</p>
</li>
</ul>
<h4 id="复制类型"><a href="#复制类型" class="headerlink" title="复制类型"></a>复制类型</h4><ul>
<li><p>基于语句的复制 statement-base Replication(SBR)</p>
<p>在master上执行的SQL语句，在slave上会执行相同的语句。Mysql默认采用基于语句的复制，效率比较高。一旦发现没法精准复制时，会自动选基于行的复制。</p>
<blockquote>
<p>优点是只需要记录修改数据的sql语句到binlog，减少binlog日志量，节约IO。</p>
<p>缺点是语句很复杂的时候，slave执行消耗过多资源，而基于行复制的话，只会记录变更的行记录。</p>
</blockquote>
</li>
<li><p>基于行的复制</p>
<p>把改变的内容复制到slave，而不是把命令在slave执行一遍。</p>
<blockquote>
<p>优点：只会记录变更的行记录，哪怕一个语句很复杂，但是它最后只影响几条记录，那么行的复制，只会把影响到几条记录记录到binlog，降低slave重放日志时的资源消耗。</p>
<p>缺点：日志庞大，不利于数据库的还原。</p>
</blockquote>
</li>
<li><p>混合类型的复制</p>
<p>默认采用基于语句的复制，当发现基于语句的复制无法精确的复制时，采用基于行的复制。</p>
</li>
</ul>
<h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><ul>
<li><p><strong>第一范式</strong>(确保每列保持原子性)</p>
<p>最基本的范式。如果数据库表中所有字段都是不可分解的原子值，说明满足第一范式。如地址，有时候需要访问地址中的省份部分，有时候访问城市部分，这时候将地址拆分成省份、城市、详细地址等多个部分进行存储，这样设计就满足了第一范式。</p>
</li>
<li><p><strong>第二范式</strong>(确保表中的每列都和主键相关)</p>
<p>在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/2012040114063976.png" alt="2012040114063976"></p>
<p>例如这张表，就要拆成，订单信息表，订单项目表，商品信息表。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/2012040114082156.png" alt="2012040114082156"></p>
</li>
<li><p>第三范式(确保每列都和主键直接相关，而不是间接相关)</p>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>
</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>三种方法：</p>
<ul>
<li><p>实现Runnable：无返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现runnable接口的线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread myThread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li>
<li><p>实现Callable：有返回值，通过FutureTask封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalled</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyCalled myCalled = <span class="keyword">new</span> MyCalled();</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myCalled);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(futureTask.get());</span><br></pre></td></tr></table></figure></li>
<li><p>继承thread：实现run接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">mt.start();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程机制"><a href="#线程机制" class="headerlink" title="线程机制"></a>线程机制</h2><p><strong>Executor（线程池）</strong></p>
<p>管理多个异步程序的执行，无序coder手动管理，主要有如下三种：</p>
<ul>
<li><p>CachedThreadPool：一个任务创建一个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">&#125;</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure></li>
<li><p>FixedThreadPool：所有任务使用固定大小的线程</p>
</li>
<li><p>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p>
</li>
</ul>
<p><strong>Daemon</strong></p>
<p>守护线程，非守护线程都结束之后也随之终结，main是非守护线程，在线程启动前使用setDaemon可以设置成守护线程。</p>
<p><strong>sleep</strong></p>
<p>线程休眠</p>
<p><strong>yield</strong></p>
<p>当前线程已经完成了最重要的部分，可以切换给其他线程执行。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>InterruptedException</strong></p>
<p>中断线程，如果线程处于阻塞、等待状态，抛出InterruptedExecution，从而提前结束。但是不能中断I/O和synchronized阻塞。</p>
<p><strong>interrupted</strong></p>
<p>如果线程的run方法执行无限循环，并且没有执行sleep等抛出InterruptedException的操作，调用interrupt就不会终止。</p>
<p>但是interrupt会设置线程的中断标记，此时调用interrupted返回true，因此可以在循环体中用此方法判断线程是否处于中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!interrupted())&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Executor中断操作</strong></p>
<p>shutdown方法会等待线程都执行完毕之后关闭，如果调用的是shutdownNow方法，相当于调用每个线程的interrupt方法。</p>
<p>如果想中断Executor中的一个线程，可以通过submit提交一个线程，会返回一个Future&lt;?&gt;对象，调用对象的cancel方法可以中断线程。</p>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p><strong>synchronized</strong>：JVM实现的锁。</p>
<ul>
<li><p>代码块：只作用于同一个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    synchtonized(<span class="keyword">this</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法：只作用于同一个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类：不同实例也会锁资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态方法：作用于整个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>ReentrantLock</strong></p>
<p>是JDK实现的锁，在JUC包下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<ul>
<li>S是JVM实现，R是JDK实现</li>
<li>性能大致相同</li>
<li>R等待可中断，S不行</li>
<li>S非公平，R可公平</li>
</ul>
<p><strong>选择</strong></p>
<p>优先S。JVM实现，和JDK版本无关，天然支持。并且S锁由JVM释放，不用担心因为没有释放锁而导致的死锁问题。</p>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><p><strong>join</strong></p>
<p>将当前线程挂起，知道目标线程执行结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.线程;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhuhuihui15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/23 10:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line">        B(A a)&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出AB。</p>
<p><strong>wait/notify/notifyAll</strong></p>
<p>调用wait线程挂起，其他线程调用notify或者notifyall来唤起线程，属于Object的一部分，不属于Thread。只能应在同步方法或者同步控制块。</p>
<p>必须释放锁，如果不释放，其他方法无法进入对象的同步方法，也就无法执行notify，从而造成死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before方法&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>await/signal/signalAll</strong></p>
<p>JUC提供了Condition类来实现线程之间的协调，可以在Condition调用await方法使线程等待，相比于wait，await可以指定等待的条件，更加灵活。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JUC-AQS"><a href="#JUC-AQS" class="headerlink" title="JUC-AQS"></a>JUC-AQS</h2><p>AQS被认为是JUC的核心。</p>
<ul>
<li><p>CountDownLatch</p>
<p>用来控制一个或者多个线程等待多个线程，维护了一个cnt，每次调用countDownLatch都会使得cnt数值减少1，减少到0的时候，那些因为调用await方法等待的线程就会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Integer count = <span class="number">10</span>;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count; i++)&#123;</span><br><span class="line">            executor.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CylicBarrier</p>
<p>多个线程互相等待，多个线程都到达时，这些线程才会执行。线程执行await方法后计数器会-1,并进行等待，直到计数器为0，所有调用await方法的线程继续执行。</p>
<p>和CountDownLatch的区别是，Barrier计数器通过调用reset()方法可以循环使用，所以叫循环屏障。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CylicBarrierTest</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">          ExecutorService executor = Executors.newFixedThreadPool(totalThread);</span><br><span class="line">          CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;totalThread; i++)&#123;</span><br><span class="line">              executor.execute(()-&gt;&#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      cyclicBarrier.await();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          executor.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">+ Semaphore</span><br><span class="line"></span><br><span class="line">  类似于信号量，控制对互斥资源的访问线程数，以下程序模拟并发请求，</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> permit = <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> total = <span class="number">10</span>;</span><br><span class="line">          Semaphore semaphore = <span class="keyword">new</span> Semaphore(permit);</span><br><span class="line">          ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">              executorService.execute(()-&gt;&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      semaphore.acquire();</span><br><span class="line">                      System.out.println(<span class="string">&quot;available permit:  &quot;</span>+semaphore.availablePermits());</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                      semaphore.release();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          executorService.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="JUC-Other"><a href="#JUC-Other" class="headerlink" title="JUC-Other"></a>JUC-Other</h2><ul>
<li><p>FutureTask</p>
<p>可以用于异步封装，实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;other thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;other thread is stop now&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p>other thread is running…<br>other thread is stop now<br>4950</p>
</blockquote>
</li>
<li><p>BlockingQueue</p>
<ul>
<li>FIFO队列：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li>优先队列：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的get和set方法，队列为空时，get阻塞知道队列中有内容。队列满时，put阻塞，直到队列有空闲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;producer&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;producer..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String producer = (String) queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;consumer..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ForkJoin</p>
<p>用于并行计算，类似于Mapeduce</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTest</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(last-first&lt;=threshold)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i&lt;=last;i++)&#123;</span><br><span class="line">                result+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//任务拆分</span></span><br><span class="line">            <span class="keyword">int</span> middle = first+(last - first)/<span class="number">2</span>;</span><br><span class="line">            ForkJoinTest left = <span class="keyword">new</span> ForkJoinTest(first, middle);</span><br><span class="line">            ForkJoinTest right = <span class="keyword">new</span> ForkJoinTest(middle,last);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            result = left.join()+right.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinTest exam = <span class="keyword">new</span> ForkJoinTest(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(exam);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><p><strong>三大特征</strong></p>
<ul>
<li><p>原子性</p>
<p>AtomicInteger保证原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sychronized保证原子性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可见性：一个线程修改，其余线程可以立即知道这个修改。主要的实现方式有volatile，sychronized，final。final是在未发生this逃逸的情况下，其余线程是可见的。其中volatile只保证可见性，但不保证原子性。</p>
<blockquote>
<p>this逃逸：在构造函数完成构造之前，其余线程就拥有该对象的引用，导致程序发生莫名其妙的问题。</p>
</blockquote>
</li>
<li><p>有序性</p>
<p>线程内有序，但是线程之间无序，因为发生指令重排，volatile通过添加内存屏障的方式禁止指令重排，也可以通过sychronized。</p>
</li>
</ul>
<p><strong>先行发生原则</strong></p>
<ul>
<li>单线程：前面的操作先于后面的操作</li>
<li>管道锁定规则：unlock先行于同一个锁的Lock操作</li>
<li>volatile变量规则：对volatile变量的写操作先行于读操作</li>
<li>线程启动规则：start操作发生于其余操作之前</li>
<li>线程加入原则：Thread结束先行于join返回</li>
<li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</li>
<li>对象终结</li>
<li>传递性</li>
</ul>
<h2 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h2><ul>
<li><p>不可变：final，String，枚举等等。</p>
</li>
<li><p>互斥同步：sychronized，ReentrankLock</p>
</li>
<li><p>非阻塞</p>
<p>互斥同步是一种悲观策略，而且阻塞会产生性能影响。基于冲突检测的乐观并发策略是这样的：先进行操作，若没有其他线程争共享数据，success，否则采取补偿措施（不断重试，直到成功）</p>
<ul>
<li><p>CAS</p>
<p>全称是比较并交换(Compare-and-Swap)，CAS指令需要有3个操作数，分别是内存地址V，旧的预期值A和新的值B。执行操作时，只有当V的值等于A，才将V的值更新为B。</p>
</li>
<li><p>AtomicInteger</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ABA</p>
<p>原本是A，被改成B，然后又改成A，CAS会认为没有被改变过，JUC下有atomicStampedReference，控制变量值的版本。大部分情况下ABA不影响并发程序的正确性，需要解决的话，改成互斥同步会比原子类更高效。</p>
</li>
</ul>
</li>
<li><p>无同步</p>
<ul>
<li><p>封闭栈：多个线程访问同一个方法的局部变量，不会出现线程安全问题，因为局部变量在虚拟机栈，线程私有。</p>
</li>
<li><p>线程本地存储</p>
<p>为每个线程提供一个变量副本，线程之间相互不影响，每个线程都保存了一个<code>ThreadLocalMap</code>的成员变量，存储以ThreadLocal为Key，set方法为值。</p>
<p>内存泄漏问题：key弱引用，value强引用。系统GC出现key为null的value，尽可能手动remove().</p>
</li>
<li><p>可重入代码：感觉是一种编程思想，依赖程序员主观实现，可重入的解释是：在代码执行的时候中断他，转而去执行另外一段代码，在控制权返回后，原来的程序不会出现任何错误。</p>
</li>
</ul>
</li>
</ul>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>JVM对synchronized的优化。</p>
<p><strong>自旋锁：</strong></p>
<p>避免阻塞，遇到锁时先自旋。适用于共享数据的锁定状态很短的情况。JDK1.6开始自适应的自旋锁。自适应意味着自旋的次数不是固定，而是由前一次在同一个锁上的自旋次数和锁的拥有者状态决定。</p>
<p><strong>锁消除：</strong></p>
<p>通过逃逸分析来支持，如果Heap上的共享数据不可能逃逸出去被其他线程访问到，当成私有数据对待，消除锁。</p>
<p>例如字符串的拼接<code>sb=s1+s2+s3</code>，因为string不可变，会自动将拼接优化成stringBuffer的append操作，append是synchronized互斥，所以sb的引用不会发生逃逸，因此可以消除sb变量的加锁。</p>
<p><strong>锁粗化</strong></p>
<p>上述例子，两次字符串相加调用append会反复给同一个对象加锁解锁浪费性能，JVM将会把加锁的范围拓展粗化到整个操作序列的外部。上述代码就是第一个操作之前知道最后一个append操作之后，这样只需要加锁一次。</p>
<p><strong>轻量级锁</strong></p>
<p>JDK1.6引入偏向锁和轻量级锁，从而让锁有了四个状态：无锁，偏向锁，轻量级锁，重量级锁。</p>
<p>相对于重量级锁而言，使用CAS操作来避免重量级锁使用互斥量的开销。对于蛋白粉锁，在整个同步周期都是不存在竞争的，因此不需要都使用互斥量进行同步，可以先采用CAS操作进行同步，如果CAS失败了再改用互斥量进行同步。</p>
<p><strong>偏向锁</strong></p>
<p>对象锁第一次被线程获得时，标记为101偏向。同时使用CAS操作将线程ID记录到mark word中，如果CAS操作成功，这个线程每次进入到这个锁相关的同步块就不再需要任何的同步操作。</p>
<p>当有另外一个线程获取锁，偏向锁宣告结束，撤销偏向锁后恢复到为锁定状态或者轻量锁状态。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="一、五层协议"><a href="#一、五层协议" class="headerlink" title="一、五层协议"></a>一、五层协议</h2><p>一般折中OSI和TCP/IP，采用五层协议。（自上而下）</p>
<p><strong>5 应用层：</strong></p>
<p>[参考](<a target="_blank" rel="noopener" href="https://krains.gitee.io/blogs/Computer">https://krains.gitee.io/blogs/Computer</a> Network/应用层.html#概述)</p>
<p>应用层的任务是通过使用进程间的交互来完成特定网络应用。应用层定义的是应用进程（进程：主机中正在运行的程序）间的交互规则，对于不同的网络应用需要不同的应用协议。应用层协议很多，如DNS，HTTP协议，电子邮件SMTP协议，把应用层交互的数据称为<strong>报文</strong>。</p>
<ul>
<li><p>DNS</p>
<blockquote>
<p>域名系统，是因特网的一项核心服务，是一个将域名和IP地址映射的一个分布式数据库。</p>
</blockquote>
</li>
<li><p>HTTP协议</p>
<blockquote>
<p>超文本传输协议。所有的www文件都遵守这个标准。设计Http最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
</blockquote>
</li>
<li><p>websocket</p>
</li>
</ul>
<p><strong>4 运输层：</strong></p>
<p>[参考](<a target="_blank" rel="noopener" href="https://krains.gitee.io/blogs/Computer">https://krains.gitee.io/blogs/Computer</a> Network/传输层.html#概述)</p>
<p>负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用报文。由于一台主机可以同时运行多个线程，因此传输层具有复用和分用的功能。复用就是指多个应用进程可以同时用下面传输层的服务，分用则是把运输层把收到的消息交付到上面应用层中的相应进程。</p>
<p>运输层主要负责以下两种协议：</p>
<ul>
<li>传输控制协议TCP：提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议UDP：无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ul>
<p><strong>3 网络层：</strong></p>
<p>[参考](<a target="_blank" rel="noopener" href="https://krains.gitee.io/blogs/Computer">https://krains.gitee.io/blogs/Computer</a> Network/网络层.html#网际协议-ip)</p>
<p>在计算机网络中进行通信的两个计算机可能会讲过很多个数据链路，也可能还要经过很多通信子网。网络层的作用就是选择合适的网间路由和交换节点，确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称<strong>数据报</strong>。</p>
<blockquote>
<p>运输层的数据报UDP和网络层的IP数据报不一样，另外，无论是哪一层的数据单元，都可以笼统的用“分组”来表示。</p>
</blockquote>
<p>互联网是大型的异构网络通过路由器连接起来的。互联网使用的网络层协议是无连接的网际协议和许多路由选择协议，因此互联网的网络层也叫作<strong>网际层</strong>、<strong>IP层</strong>。</p>
<p><strong>2 数据链路层：</strong></p>
<p>简称为链路层。两台主机传输数据，是在一段一段的数据链路上传送的，需要专门的链路层协议。在两个相邻的节点传输数据时，链路层将网络层交下来的IP数据报组装成帧，在两个相邻的节点传送帧。每一帧包括数据和必要的信息（同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使得接收端能够知道一个帧从哪个比特开始到哪个比特结束。这样链路层在收到一个帧后就可以从中提取数据部分。控制信息还使得接收端能够检测到所收到的帧中有错误差。发现差错，链路层简单的丢弃这个帧，避免浪费资源。如果需要改正差错，就要采用可靠性传输协议来纠正差错。</p>
<p><strong>1 物理层：</strong></p>
<p>在物理层上传送的数据是比特。物理层的作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。使得其上面的链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.png" alt="计算机网络复习"></p>
<h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><h3 id="0、TCP报文结构"><a href="#0、TCP报文结构" class="headerlink" title="0、TCP报文结构"></a>0、TCP报文结构</h3><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/tcp_head.png" alt="tcp_head"></p>
<ul>
<li>32位序列号：建立连接时由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次。用来解决网络包乱序的问题。</li>
<li>32位确认号：希望收到的下一个数据报的序列号，表明到序列号 <code>N-1</code> 为止的所有数据已经正确收到。解决不丢包的问题。</li>
<li>TCP协议数据报头长：4位长。表明TCP头中包含多少个 4字节</li>
<li>控制位：（6位）<ul>
<li><strong>ACK</strong>：是1的时候，确认应答的字段有效，TCP规定除了最初建立时的SYN包之外必须是1</li>
<li><strong>RST</strong>：是1的时候，表示TCP连接中出现异常必须强制断开连接</li>
<li><strong>SYN</strong>：是1的时候，希望建立连接，并在序列号的字段进行序列号初始值设定</li>
<li><strong>FIN</strong>：是1的时候表示希望断开连接。当通信结束希望断开连接时，通信双方的主机之间可以交换FIN位为1的TCP字段</li>
</ul>
</li>
<li><strong>窗口大小（WIN）</strong>：16位长。表示从确认号开始，本报文的发送方（数据发送端 or 数据接收端）可以接收的字节数，即接收窗口大小。用于流量控制。</li>
<li><strong>校验和（Checksum）</strong>：16位长。是为了确保高可靠性而设置的。它校验头部、数据和伪TCP头部之和。</li>
<li>紧急指针：<code>URG=1</code>时才有意义。</li>
</ul>
<blockquote>
<p>TCP最小长度是20字节。</p>
</blockquote>
<h3 id="1、常见问题"><a href="#1、常见问题" class="headerlink" title="1、常见问题"></a>1、常见问题</h3><ul>
<li><p><strong>如何唯一确定一个TCP？</strong></p>
<p>通过TCP四元组：源地址、源端口、目的地址、目的端口，地址在IP头部，端口在TCP头部。</p>
</li>
<li><p><strong>一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？</strong></p>
<p>最大TCP连接数 = 客户端的IP数*客户端的端口数</p>
<p>对于IPv4，IP数最多是$2^{32}$,客户端端口最多是$2^{16}$，最多可能是$2^{48}$.</p>
</li>
<li><p><strong>UDP的头部格式是？</strong></p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210820151945323.png" alt="image-20210820151945323" style="zoom:50%;" /></li>
<li><p><strong>为什么client和server的序列号不一样？</strong></p>
<p>网络报文可能延迟、复制重丢失，这样会造成不同连接之前相互影响，不一样可以避免相互影响。</p>
<p>为了安全性，防止黑客伪造相同的序列号，接收到报文。</p>
</li>
<li><p><strong>序列号是如何产生的？</strong></p>
<p>最初基于时钟，每4ms+1，转一圈4.55小时。后来 $ISN = M+F(localhost,localport,remotehost,remostport)$</p>
</li>
<li><p><strong>SYN攻击？</strong></p>
<p>短时间伪造不同IP的SYN报文，服务端每次发送ACK应答但是收不到第三次回应，导致沾满SYN接收队列，使得服务器不能正常服务。</p>
<p><strong>避免？</strong></p>
<p>修改linux参数，控制队列大小和队列满的处理策略。</p>
</li>
</ul>
<h3 id="2、TCP三次握手和四次挥手"><a href="#2、TCP三次握手和四次挥手" class="headerlink" title="2、TCP三次握手和四次挥手"></a>2、TCP三次握手和四次挥手</h3><ul>
<li>客户端和服务端处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。</li>
<li>客户端随机初始化序号（client_isn），将序号放入TCP首部的序号字段，同时把SYN置1，之后客户端处于SYN-SENT状态</li>
<li>服务端收到客户端的SYN报文后，首先初始化自己的序号(server_isn)，填入序号中；其次把确认号填入client_isn+1，把SYN和ACK标志位置为1，然后把报文发给客户端，此时客户端处于SYN-RCVD状态。</li>
<li>客户端收到后，向服务端回应一个报文，ACK置1，应答号填server_isn+1，最后把报文发送给服务端，这次报文可以携带数据，之后客户端处于ESTABLISHED状态</li>
<li>服务端收到应答报文，也进入ESTABLISHED状态。</li>
</ul>
<p><strong>如何查看TCP状态</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt</span><br></pre></td></tr></table></figure>

<p><strong>为什么是三次？</strong></p>
<ul>
<li><p>避免历史连接(<strong>主要原因</strong>)：客户端发送多次SYN建立连接的报文，在网络拥堵的情况下：</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210822104906714.png" alt="image-20210822104906714" style="zoom:50%;" />

<ul>
<li>旧SYN报文比最新的SYN报文早到达了客户端</li>
<li>服务端返回SYN+ACK给客户端</li>
<li>客户端根据自身上下文，判断是历史连接，发送RST给服务端，终止连接。</li>
</ul>
</li>
<li><p>同步双方初始序列号（这个和确认收发能力的过程类似），其实四次也可以，但是能三次为啥要四次呢？</p>
</li>
<li><p>避免资源浪费：多个SYN阻塞，服务器在收到请求后会建立多个冗余连接。</p>
</li>
</ul>
<hr>
<p>断开一个TCP连接需要<strong>四次挥手：</strong></p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%203%20%E9%A1%B5.png" alt="计算机网络复习-第 3 页"></p>
<ul>
<li><strong>客户端</strong>：发送一个FIN报文，进入<code>fin_wait_1</code>状态</li>
<li><strong>服务端</strong>：收到FIN，它发回一个ACK。进入<code>closed_wait</code>状态</li>
<li>客户端：收到ACK，进入到<code>fin_wait-2</code>状态。</li>
<li><strong>服务端</strong>：关闭与客户端的连接，发送一个FIN给客户端，进入到<code>last_ack</code>状态</li>
<li><strong>客户端</strong>：发回ACK报文确认，进入<code>time_wait</code>状态</li>
<li>服务端：收到ACK，进入CLOSED状态，</li>
<li>客户端：经过2MSL一段时间后，自动进入CLOSED状态。</li>
</ul>
<p><strong>常见问题：</strong></p>
<ul>
<li><p><strong>为什么需要四次挥手？</strong></p>
<p>任何一方都可以发送连接释放的通知，对方确认后进入办关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。更具体一点：AB两人通话，A：我说完了。B：我知道了（但我可能还有话说）。B：我也说完了。A：知道了（挂断）。</p>
</li>
<li><p><strong>为什么有TIME_WAIT状态</strong></p>
<ul>
<li>防止具有相同四元组的旧数据包被收到</li>
<li>保证被动关闭连接的一方能正确关闭，即保证最后的ack被被动关闭方接收。</li>
</ul>
</li>
</ul>
<h3 id="3、TCP重传、滑动窗口、流量控制、拥塞机制"><a href="#3、TCP重传、滑动窗口、流量控制、拥塞机制" class="headerlink" title="3、TCP重传、滑动窗口、流量控制、拥塞机制"></a>3、TCP重传、滑动窗口、流量控制、拥塞机制</h3><h4 id="1-重传"><a href="#1-重传" class="headerlink" title="1.重传"></a>1.重传</h4><p><strong>超时重传</strong></p>
<p>发送数据时设定一个定时器，超出指定时间没有收到ACK，则重发。以下两种情况触发超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p>超时重传存在的问题是：超时周期可能比较长。</p>
<hr>
<p><strong>快速重传</strong></p>
<p>超时重传是时间驱动，而快速重传是数据驱动。比如：</p>
<p>发送1,2,3,4,5五个数据，先传1，ack回2，这时候2没到，3到了，ACK还是回2，然后4到了，2还是没到，ACK依然回2。收到三个ACK=2，在定时器过期之前，重传丢失的2，最后收到了2，因为3,4,5都收到了，于是ACK回6.</p>
<p>有个问题就是，在重传的时候，是重传2呢还是重传2345呢？为了解决不知道重传哪些报文，于是有了SACK方法。</p>
<hr>
<p><strong>SACK重传</strong>（选择性确认）</p>
<p>在TCP头部添加SACK，可以将缓存的地图发送给发送方，就可以只重传丢失的数据。</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210822155359858.png" alt="image-20210822155359858" style="zoom:50%;" />

<hr>
<p><strong>Duplicate SACK</strong></p>
<p>以下两个场景：</p>
<ul>
<li><p>ACK丢失</p>
<p>由于ACK丢失，导致服务端发送重复数据。这时候接收到回复SACK，表示已经接受包，这个SACK就叫做D-SACK。</p>
</li>
<li><p>网络延时</p>
</li>
</ul>
<h4 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h4><p>窗口大小就是无需等待确认应答，可以继续发送数据的最大值。</p>
<p>TCP头有个window，也就是窗口的大小，接收方告诉发送方自己还有多少缓冲区，所以窗口的大小一般是接收方决定的。</p>
<h4 id="3、流量控制"><a href="#3、流量控制" class="headerlink" title="3、流量控制"></a>3、流量控制</h4><p>一种机制，可以让发送方根据接收方的实际接收能力控制发送的数据量。</p>
<p>连接双方有缓冲空间，只允许发送缓冲区能接纳的数据，接收端来不及处理的时候提示发送方降低发送速率，防止丢包。缓冲区是可改变大小的滑动窗口协议。</p>
<h4 id="4、拥塞控制"><a href="#4、拥塞控制" class="headerlink" title="4、拥塞控制"></a>4、拥塞控制</h4><p>网络阻塞时，减少数据的发送</p>
<h3 id="4、TCP，UDP协议的区别"><a href="#4、TCP，UDP协议的区别" class="headerlink" title="4、TCP，UDP协议的区别"></a>4、TCP，UDP协议的区别</h3><p>UDP在传送数据之前不需要建立连接，远程主机收到UDP报文后，不需要给出任何确认。虽然UDP不提供可交付，但是比较有效。比如：QQ语音，视屏，直播。</p>
<p>TCP提供面向连接的服务。传送前建立连接，传送后断开连接。不提供广播或者多播服务。（可靠性体现在三次握手，在数据传输时，还有确认，窗口，重传等等，在数据传输之后，还会断开连接来释放资源）。增加很多开销，使得协议数据单元的首部增大很多。一般用于文件传输，发送和接受邮件，远程登陆。</p>
<p><strong>TCP如何保证可靠传输？</strong></p>
<p>分块，编号，校验和，流量控制，拥塞机制，ARQ，超时重传。</p>
<ul>
<li>数据被分割成TCP认为最适合传输的数据块</li>
<li>给发送的每一个包进行编号，接收方对数据报进行排序，把有序数据传给应用层。</li>
<li><strong>校验和：</strong>TCP将保持他首部和数据的校验和。这是一个端到端的检验和，目的是检验数据在传输的过程中的任何变化，有变化则丢弃并不确认收到此报文。</li>
<li>TCP接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong>连接双方有缓冲空间，只允许发送缓冲区能接纳的数据，接收端来不及处理的时候提示发送方降低发送速率，防止丢包。缓冲区是可改变大小的滑动窗口协议。</li>
<li><strong>拥塞控制：</strong>网络阻塞时，减少数据的发送</li>
<li><strong>ARQ协议：</strong>每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ul>
<h3 id="4、滑动窗口和流量控制"><a href="#4、滑动窗口和流量控制" class="headerlink" title="4、滑动窗口和流量控制"></a>4、滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="5、拥塞控制"><a href="#5、拥塞控制" class="headerlink" title="5、拥塞控制"></a>5、拥塞控制</h3><p>为了进行控制，TCP维持一个<strong>拥塞窗口</strong>的状态变量。窗口的大小取决于网络的拥塞程度，动态变化，发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p>
<p>采用了四种算法：慢开始、拥塞避免、快重传、快恢复。</p>
<ul>
<li><strong>慢开始：</strong>因为不知道情况，小到大增加发送窗口，cwnd(拥塞窗口)初始1，每次加倍。</li>
<li><strong>拥塞避免：</strong>让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT（网络时延）就把发送放的cwnd加1.</li>
<li><strong>快重传与恢复：</strong>FRR（快速重传与恢复）能快速恢复丢失的数据包，没有FRR，丢失后，TCP使用定时器要求传输暂停。有了FRR，接收方收到一个不按照顺序的数据段，立即发送于一个重复确认。如果发送方接到三个重复确认，会假定指出的数据丢失，立即重传丢失的数据。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h3 id="6、ARQ协议"><a href="#6、ARQ协议" class="headerlink" title="6、ARQ协议"></a>6、ARQ协议</h3><p><strong>自动重传请求</strong>是OSI模型汇总数据链路层和传输层的错误纠正协议之一。使用确认和超时连个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送一段时间没有收到确认帧，通常重新发送。ARQ通常包括：停止等待ARQ和连续ARQ协议。</p>
<p><strong>停止等待ARQ：</strong></p>
<ul>
<li>为了实现可靠传输，原理是：发送完停止，等待对方确认（回复ACK），超时没有收到ACK，则重新发送。</li>
<li>若接收方收到重复分组，丢弃，但需要发送确认。</li>
</ul>
<p>优点：简单</p>
<p>缺点：信道利用率低，等待时间长。</p>
<ol>
<li><p>无差错情况：</p>
<p>收到ACK，再次发送。</p>
</li>
<li><p>出现差错（超时重传）、</p>
<p>发送完一个分组需要一个超时计时器。这种重传方式通常称为：自动重传请求ARQ。</p>
</li>
<li><p>确认丢失和确认迟到</p>
<ul>
<li>确认丢失：确认消息丢失，客户端再次发送，服务端收到消息采取以下搓手：丢弃消息，不向上层交付。再次发送确认消息。</li>
<li>确认迟到：A发，B确认，但消息迟到。A再发，B第二次确认到达。传输别的。A收到第一次确认到达。处理方式：A收到重复确认直接丢弃，B收到重复的数据直接丢弃。</li>
</ul>
</li>
</ol>
<p><strong>连续ARQ</strong></p>
<p>可以提高信道利用率。发送方位置控制一个发送窗口，窗口内的分组连续发送，无需ACK，接收方累计确认，对顺序到达的最后一个分组发送ACK，表明到这个分组为止的所有分组都正确收到。</p>
<p>有点：信道利用率高，容易实现，即使确认丢失，也不不必重传。</p>
<p>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h2 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h2><h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><h4 id="请求报文头部"><a href="#请求报文头部" class="headerlink" title="请求报文头部"></a>请求报文头部</h4><ul>
<li><code>User-Agent</code>：产生请求的浏览器类型。</li>
<li><code>Accept</code>：客户端可识别的响应内容类型列表;</li>
<li><code>Accept-Language</code>：客户端可接受的自然语言;</li>
<li><code>Accept-Encoding</code>：客户端可接受的编码压缩格式;</li>
<li><code>Accept-Charset</code>：可接受的应答的字符集;</li>
<li><code>Host</code>：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;（必选）</li>
<li><code>Connection</code>：连接方式(close 或 <code>keep-alive</code>);</li>
<li><code>Cookie</code>：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;</li>
<li><code>请求包体</code>：在<code>POST</code>方法中使用。</li>
<li><code>Referer</code>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</li>
<li><code>If-Modified-Since</code>：文档的最后改动时间</li>
</ul>
<h4 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h4><ul>
<li><code>Allow</code> 服务器支持哪些请求方法（如GET、POST等）。</li>
<li><code>Content-Encoding</code> 文档的编码（Encode）方法。</li>
<li><code>Content-Length</code> 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。</li>
<li><code>Content-Type</code> 表示后面的文档属于什么MIME类型。</li>
<li><code>Date</code> 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>
<li><code>Expires</code> 应该在什么时候认为文档已经过期，从而不再缓存它。</li>
<li><code>Last-Modified</code> 文档的最后改动时间。</li>
<li><code>Refresh</code> 表示浏览器应该在多少时间之后刷新文档，以秒计。</li>
<li><code>Server</code> 服务器名字。</li>
<li><code>Set-Cookie</code> 设置和页面关联的Cookie。</li>
<li><code>ETag</code>：被请求变量的实体值。ETag是一个可以与Web资源关联的记号（MD5值）。</li>
<li><code>Cache-Control</code>：这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。</li>
</ul>
<h3 id="Q：输入URL地址，显示主页的过程"><a href="#Q：输入URL地址，显示主页的过程" class="headerlink" title="Q：输入URL地址，显示主页的过程"></a>Q：输入URL地址，显示主页的过程</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/haA2icMB7NzZnkwT88Pw4g">更详细的参考这里</a></p>
<p>主要会使用到哪些协议。</p>
<p>过程：</p>
<ul>
<li>1、浏览器查找域名的IP地址（浏览器缓存，路由器缓存,DNS缓存）</li>
<li>2、浏览器向WEB服务器发送http请求（cookies会随着请求发送给服务器）</li>
<li>3、服务器处理请求</li>
<li>4、服务器发回一个HTML响应。</li>
<li>5、浏览器开始显示HTML</li>
</ul>
<p>协议：</p>
<ul>
<li>DNS</li>
<li>TCP：与服务器建立TCP连接</li>
<li>IP：建立TCP协议，需要发送数据，发送数据再网络层使用IP协议</li>
<li>OPSF：IP数据包在路由器期间，路由选择使用此协议。</li>
<li>ARP：路由器与服务器通信，将IP转化为mac地址</li>
<li>HTTP：TCP建立后，通过HTTP访问网页。</li>
</ul>
<h3 id="Q-状态码"><a href="#Q-状态码" class="headerlink" title="Q-状态码"></a>Q-状态码</h3><table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1..</td>
<td>信息性状态码</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2..</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3..</td>
<td>重定向状态码</td>
<td>需要进行附加操作完成请求</td>
</tr>
<tr>
<td>4..</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5..</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<ul>
<li><p>3</p>
<p>重定向，需要进一步的操作以完成请求</p>
<ul>
<li><code>301 Moved Permanently</code>。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
</ul>
</li>
<li><p><code>302 Moved Temporarily</code>。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>
<ul>
<li><code>304 Not Modified</code>。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。<strong>客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</strong>。</li>
</ul>
</li>
<li><p>4</p>
<p>客户端错误，请求包含语法错误或无法完成请求</p>
<ul>
<li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li>
</ul>
</li>
<li><p><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<ul>
<li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li>
</ul>
</li>
<li><p>5</p>
<p>服务器错误，服务器在处理请求的过程中发生了错误</p>
<ul>
<li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>
</ul>
</li>
<li><p><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</p>
</li>
</ul>
<h3 id="Q-各种协议与HTTP协议的关系"><a href="#Q-各种协议与HTTP协议的关系" class="headerlink" title="Q-各种协议与HTTP协议的关系"></a>Q-各种协议与HTTP协议的关系</h3><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210320222328026.png" alt="image-20210320222328026"></p>
<h3 id="Q-HTTP长连接、短连接"><a href="#Q-HTTP长连接、短连接" class="headerlink" title="Q-HTTP长连接、短连接"></a>Q-HTTP长连接、短连接</h3><p><strong>HTTP/1.0默认短连接</strong>，客户端每次访问某个html或者其他类型的web中包含其他的web资源（JS文件，图像，CSS），每次遇到这样一个web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>从HTTP/1.1默认使用长连接，会在响应头加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPYconnection：keep-alive</span><br></pre></td></tr></table></figure>

<p>长连接，每次一个网页打开，客户端和服务器之间用于传输HTTP数据的TCP连接不关闭。不会持久保持，有保持时间，可以在不同的服务器软件设定。实现长连接的客户端和服务器都需要支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接短连接。</p>
<h3 id="Q-HTTP如何保存用户状态"><a href="#Q-HTTP如何保存用户状态" class="headerlink" title="Q-HTTP如何保存用户状态"></a>Q-HTTP如何保存用户状态</h3><p>HTTP是<strong>无状态</strong>协议，自身不对请求体和响应体之间的通信状态进行保存。Session机制，通过服务端记录用户状态。典型的场景是购物车，当你添加商品到购物车时，系统不知道是哪个用户，服务器给特定的用户创建特定的Session来标识这个用户并跟踪。（过期销毁）。</p>
<p>在服务端保存session方法：内存和数据库（redis），既然session在服务端，那如何实现session跟踪呢？通过在cookie中添加一个session ID 的方式来实现追踪。</p>
<p><strong>cookie被禁用了怎么办？</strong></p>
<p>URL重写，直接把Session ID附加在URL路径的后面。</p>
<h3 id="Q-Cookie"><a href="#Q-Cookie" class="headerlink" title="Q-Cookie"></a>Q-Cookie</h3><p>Cookie和Session都用来跟踪浏览器用户身份的会话方式，但是场景不太一样。</p>
<p>Cookie一般保存用户信息：</p>
<ul>
<li>在cookie中保存已经登录过的用户信息，下次访问网站可以自动填写基本信息。</li>
<li>保持登录，在cookie中存放了token。</li>
<li>登录一次网站后访问网站其他页面不需要登陆。</li>
</ul>
<p>Cookie数据保存在客户端，Session保存在服务器端。</p>
<p>Session安全性更高。</p>
<h3 id="Q-HTTP-1-0和HTTP-1-1"><a href="#Q-HTTP-1-0和HTTP-1-1" class="headerlink" title="Q-HTTP/1.0和HTTP/1.1"></a>Q-HTTP/1.0和HTTP/1.1</h3><ul>
<li>1.0默认长连接。1.1的持续连接有流水线和非流水线方式。流水线是客户端收到HTTP的响应报文之前能接着发送新的请求报文。非流水线是客户端在收到前一个响应后才能发送下一个请求。</li>
<li>错误状态响应码：新增了24个状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化以及网络连接的使用：1.0存在浪费带宽，例如客户端要对象的一部分，但是服务端把整个对象都穿过来，不支持断点续传。1.1在请求头引入range头域，允许只请求资源的某个部分，返回206。</li>
</ul>
<h3 id="Q-URL和URI"><a href="#Q-URL和URI" class="headerlink" title="Q-URL和URI"></a>Q-URL和URI</h3><p>URI：统一资源标志符，唯一表示一个资源</p>
<p>URL：统一资源定位符，可以提供资源的路径。是具体的URI。</p>
<p>URI像身份证，URL像家庭住址。不仅标识资源，还提供定位资源的信息。</p>
<h3 id="Q-HTTP和HTTPS"><a href="#Q-HTTP和HTTPS" class="headerlink" title="Q-HTTP和HTTPS"></a>Q-HTTP和HTTPS</h3><ol>
<li><strong>有哪些区别：</strong><ul>
<li>HTTP明文传输。HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文加密传输。</li>
<li>HTTP在TCP三握只有就可以报文传输，HTTPS在TCP的三握之后还需要进行TLS的握手</li>
<li>HTTTP端口80，S是443</li>
<li>HTTPS需要向CA(证书权威机构)申请数字证书，保证服务器的身份是可靠的。</li>
</ul>
</li>
<li><strong>HTTPS解决了哪些问题</strong></li>
</ol>
<ul>
<li><p><strong>混合加密</strong>的方式实现了信息的机密性，解决了窃听的风险。</p>
</li>
<li><p><strong>摘要算法</strong>实现完整性，为数据生成独一无二的指纹，指纹用于校验数据的完整性，解决了篡改的风险。</p>
</li>
<li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
<p><strong>混合加密</strong></p>
<p>HTTPS采用对称加密和非对称加密结合，在通信建立前使用非对称加密的方式交换会话秘钥，通信过程采用对称加密的会话秘钥加密明文数据。</p>
<p>为什么采用混合？</p>
<ul>
<li>对称加密只有一个秘钥，运算速度快，秘钥必须加密，无法做到安全的密钥交换。</li>
<li>非对称加密使用公钥和私钥，公钥可以任意分发而私钥保密。</li>
</ul>
<p><strong>摘要算法</strong></p>
<p>实现完整性，为数据生成独一无二的指纹，防止篡改。</p>
<p>客户端在发送明文之前通过摘要算法算出明文的指纹，发送的时候指纹+明文一起加密发送，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的指纹和当前算出的指纹进行比较，指纹相同说明数据是完整的。</p>
<p><strong>数字证书</strong></p>
<p>客户端索取公钥的时候如何防止不被篡改？需要借助第三方权威机构CA（数字证书认证机构），将服务器公钥放在数字证书中，只要证书是可信的，公钥就是可信的。</p>
</li>
</ul>
<ol start="3">
<li><p><strong>HTTPS如何建立连接</strong></p>
<p>基本流程是：客户端索要公钥，双方协商产生会话秘钥，双方使用会话秘钥进行加密通信。前两步是SSL/TLS建立过程，是握手阶段。</p>
<ul>
<li><p>clientHello</p>
<p>客户端向服务器发起加密通信请求，主要发送以下信息：</p>
<ul>
<li>客户端支持的SSL/TLS协议斑版本</li>
<li>客户端生产的随机数</li>
<li>客户端支持的密码套件列表，如RSA加密算法</li>
</ul>
</li>
<li><p>ServerHello</p>
<p>服务器收到请求后，向客户端发送响应。有以下内容：</p>
<ul>
<li>确认SSL/TLS协议版本，如果浏览器不支持，则关闭加密通信</li>
<li>服务器产生的随机数</li>
<li>确认的密码套件列表，如RSA</li>
<li>服务器的数字证书</li>
</ul>
</li>
<li><p>客户端回应</p>
<p>客户端在收到服务器的回应后，通过浏览器或者OS中的CA公钥，确认服务器数字证书的真实性，没问题的话从证书抽取公钥，使用公钥加密报文，发送如下信息：</p>
<ul>
<li>一个随机数，会被公钥加密</li>
<li>加密通信算法改变通知，表示随后的信息使用会话秘钥加密通信</li>
<li>客户端握手结束通知，同时把之前所有内容的发生的数据做个摘要，用来服务端校验。</li>
</ul>
<p>现在一共有了三个随机数，接着用双方协商的加密算法，各自生成本次通信的会话秘钥。</p>
</li>
<li><p>服务器最后回应</p>
<p>服务端收到客户端的第三个随机数，通过协商的加密算法，计算本次通信的会话秘钥，然后向客户端发生最后的信息：</p>
<ul>
<li>加密通信算法改变的通知，随后都使用会话秘钥加密通信</li>
<li>服务器握手结束，表示服务器的握手阶段结束，把之前所有内容发生的数据做个摘要，用来客户端校验。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>HTTP1.1、HTTP2、HTTP3的演变</strong></p>
<p>1.1相比于1.0多了长连接和管道，但是还是有性能瓶颈，HTTP2有以下改进：</p>
<ul>
<li><p>头部压缩</p>
<p>同时发出多个请求，头是一样的或者相似的，协议会消除重复的部分，这就是HPACK算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提⾼速度</strong>了。</p>
</li>
<li><p>二进制格式：不传输明文，直接传输二进制，统称为帧</p>
</li>
<li><p>数据流：HTTP2不是按照顺序发送，同一个连接里面连续的数据报，可能属于不同响应。因此要对数据做标记，指出属于哪个回应。</p>
<p>客户端还能指定数据流的优先级。</p>
</li>
<li><p>多路复用：移除了1.1中的串行请求，不需要排队等待，不会出现队头阻塞问题。</p>
</li>
<li><p>服务器推送：可以主动发送信息，例如在浏览器刚请求html页面的时候，提前吧可能用到的JS ,CSS 文件返回。</p>
</li>
</ul>
</li>
<li><p><strong>HTTP2有哪些缺陷？HTTP3有哪些优化</strong></p>
<p>缺陷：</p>
<ul>
<li>管道传输中有一个请求阻塞了，队列后的请求也阻塞</li>
<li>2中多路复用，一旦丢包，就会阻塞所有的HTTP请求。</li>
</ul>
<p>所以在3中把http下层的TCP协议改成了UDP，UDP不管顺序和丢包，不会出现1.1队头阻塞和2中的丢包全部重传问题。UDP不可靠，但是基于UDP的<strong>QUIC</strong>可以实现类似TCP的可靠性传输。QUIC是一个在UDP之上的伪TCP+TLS+HTTP/2的多路复用协议。</p>
</li>
<li><p><strong>HTTP1.1如何优化</strong></p>
<ul>
<li><p>keep_alive长连接</p>
</li>
<li><p>避免http请求-缓存，服务端会返回预估的过期时间。</p>
</li>
<li><p>减少HTTP请求次数</p>
<ul>
<li><p>减少重定向次数：重定向工作让代理服务器完成</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210820132932346.png" alt="image-20210820132932346" style="zoom:50%;" />

<p>在知道重定向规则后，可以进一步减少消息传递，如下：</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210820133050808.png" alt="image-20210820133050808" style="zoom:50%;" /></li>
<li><p>合并请求</p>
<p>多个访问小文件的请求合并成一个大的请求，减少了请求次数，也就减少了重复发送的http头部。比如用<code>CSS Image Sprites</code>技术把他们合成一个大图片，再根据CSS数据切割。或者使用webpack将js,css资源合并打包成大文件。存在的问题就是，当大资源的某个小资源发生变化后，客户端必须下载整个完整的大资源文件，带来额外的网络消耗。</p>
</li>
<li><p>延迟发送请求：请求⽹⻚的时候，没必要把全部资源都获取到，⽽是只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时</p>
<p>候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p>
</li>
</ul>
</li>
<li><p>减少HTTP响应的数据大小：对返回的资源进行有损压缩或者无损压缩</p>
<p>content-encoding: gzip</p>
<p>Accept: audio/*;q=0.2,audio/basic</p>
</li>
</ul>
</li>
<li><p><strong>HTTPS如何优化</strong></p>
<p>性能消耗主要是两个环节，一是TLS协议握手的过程，二是握手后的加密报文传输。对于2来说，主流的对称加密算法如AES，ChaCha20性能都很好，主要是解决1的性能消耗。</p>
<ul>
<li><p>硬件优化，计算密集型，考虑更好的CPU</p>
</li>
<li><p>软件优化：软件优化方向，可以吧软件升级成比较新的版本，例如将linux内核2.X升级成4.X等等</p>
<p>对于协议优化，密钥交换选择ECDHE算法，不用RSA算法 ；将TSL1.2升级成TSL1.3.</p>
</li>
<li><p>证书优化：</p>
<ul>
<li>选择ECDSA，因为更短</li>
<li>开启OCSP Stapling功能，</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="五、websocket"><a href="#五、websocket" class="headerlink" title="五、websocket"></a>五、websocket</h2><p>一种与HTTP不同的协议。两者都位于OSI模型的应用层，依赖TCP协议。虽然不同，但是RFC规定：WebSocket设计为通过80和443端口工作，支持HTTP代理和中介，从而和HTTP兼容，为了实现兼容，W握手使用HTTP ，Upgrade头从HTTP协议更改为W协议。</p>
<p>与H不同，W提供权全双工通信。此外，W还可以在TCP之上启用消息流。TCP单独处理字节流，没有固定的消息概念。</p>
<p>WebSocket协议规范将 <code>ws</code>（WebSocket）和 <code>wss</code> （WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>较小的控制开销：</strong></li>
<li><strong>更强的实时性：</strong>由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；</li>
<li><strong>保持连接状态：</strong>与 HTTP 不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li><strong>更好的二进制支持：</strong>Websocket 定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li><strong>可以支持拓展：</strong>Websocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
<li><strong>更好的压缩效果：</strong>相对于HTTP压缩，Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
<p><strong>连接过程：</strong></p>
<p>W是独立的、创建在TCP上的协议，W通过HTTP/1.1协议的101状态码进行握手。为了创建W连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为握手。</p>
<ul>
<li><p>客户端请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">COPYGET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP&#x2F;n9NdMgdcy2VJFQ&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></li>
<li><p>服务器回应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COPYHTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s&#x3D;</span><br><span class="line">Sec-WebSocket-Location: ws:&#x2F;&#x2F;example.com&#x2F;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1、JVM架构"><a href="#1、JVM架构" class="headerlink" title="1、JVM架构"></a>1、JVM架构</h2><p>java源码通过javac编译为java字节码，java字节码是java虚拟机执行的一套代码格式，抽象了计算机的基本操作。大多数指令只有一个字节，有些操作符需要参数，导致多使用了一些字节。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="java虚拟机"></p>
<p>JVM的基础架构如上图所示：主要包含三大块：</p>
<ul>
<li>类加载器：负责动态加载JAVA类到JAVA虚拟机的内存空间。</li>
<li>运行时数据区：存储JVM运行时的所有数据。</li>
<li>执行引擎：提供JVM在不同平台的运行能力。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在JVM中运行着很多线程，一部分是程序创建来执行代码逻辑的<strong>应用线程</strong>，剩下的是JVM创建来执行后台任务的<strong>系统线程</strong>。</p>
<p>主要的系统线程：</p>
<ul>
<li>Compile：运行时将字节码编译为本地代码使用的线程。</li>
<li>GC：包含所有和GC有关的操作。</li>
<li>Period Task：JVM周期性任务调度的线程，主要包含JVM内部的采样分析。</li>
<li>Singal Dispatcher：处理OS发来的信号。</li>
<li>VM：某些操作需要等待 JVM 到达 <strong>安全点（Safe Point）</strong>，即堆区没有变化。比如：GC 操作、线程 Dump、线程挂起 这些操作都在 VM Thread 中进行。</li>
</ul>
<p>类型来分，JVM内部有两种线程：</p>
<ul>
<li>守护线程：JVM自己使用，程序也可以把自己的线程标记为守护线程<code>（public final void setDaemon(boolean on)</code>，必须在start()方法之前调用。</li>
<li>非守护线程：main方法执行的线程，也称为用户线程。</li>
</ul>
<p>只要有非守护进程运行，java程序就会继续运行，非守护都终止时，虚拟机也会自动退出。</p>
<p>守护进程不适合进行IO，计算等操作，因为守护进程在非守护进程结束自动释放，不能判断该守护进程是否完成了操作。</p>
<h2 id="2、类加载器"><a href="#2、类加载器" class="headerlink" title="2、类加载器"></a>2、类加载器</h2><p>负责动态加载类到虚拟机的内存空间。通常是按需加载，类第一次使用才加载。有了类加载器，java在运行时系统不需要知道文件与文件系统。每个java类都要由类加载器装入到内存。</p>
<p>除了定位和导入二进制文件，还验证类的正确性，为变量分配初始化内存，帮助解析符号引用。按照以下顺序完成：</p>
<ul>
<li><strong>装载：</strong>查找并装载二进制数据。</li>
<li><strong>链接：</strong>执行验证、准备、解析。<ul>
<li>验证：确保被导入类型的正确性。</li>
<li>准备：为类变量分配内存，并将其初始化为默认值。</li>
<li>解析：把类型中的符号引用转化为直接引用。</li>
</ul>
</li>
<li><strong>初始化：</strong>把类变量初始化为正确的初始值。</li>
</ul>
<h3 id="1-装载"><a href="#1-装载" class="headerlink" title="1.装载"></a>1.装载</h3><p>多个类装载器，应用程序可以使用两种类装载器：</p>
<ul>
<li><strong>Bootstrap ClassLoader</strong>：原生C编写，不继承自java.lang.ClassLoder。加载核心类库，启动类加载器通常使用某种默认的方式从本地磁盘中加载，包括java API。</li>
<li><strong>Extention Classloader</strong>：用来在<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code> ,或 <code>java.ext.dirs</code> 中指明的目录中加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。</li>
<li><strong>Application Classloader</strong>：根据应用程序的类路径java.class.path或者CLASSPATH加载类。一般来说，java应用的类它加载。可以通过<code>ClassLoader.getSystemClassLoader()</code> 来获取它。</li>
<li><strong>自定义类加载器</strong>：继承java.lang.ClassLoder来实现自己的类加载器。</li>
</ul>
<p><strong>全盘负责双亲委托机制：</strong></p>
<p>一个JVM系统至少3种类加载器，如何平配合工作？通过全盘负责双亲委托机制来协调类加载器。</p>
<ul>
<li>全盘负责：当一个ClassLoder装载一个类时，除非显示的使用另一个，该类及其所依赖的类都用这个装载。</li>
<li>双亲委托机制：指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。</li>
</ul>
<p>全盘负责双亲委托是java推荐的机制，不是强制。实现自己的类加载器，保持机制，重写findClass(name)方法；破坏此机制，重写loadClass(name)方法。</p>
<p><strong>装载入口：</strong></p>
<p>所有java虚拟机实现必须在每个类或者接口首次主动使用时初始化。以下情况符合主动使用的要求：</p>
<ul>
<li>创建某个类的新实例（new、反射、克隆、序列化）</li>
<li>调用某个类的静态方法</li>
<li>使用类或者接口的静态字段，或对该字段赋值。final</li>
<li>调用java API 的某些反射方法时。</li>
<li>初始化某个类的子类时、</li>
<li>当虚拟机启动时被表明为自动类的类。</li>
</ul>
<p>除了以上全是被动，不会导致java类型的初始化。</p>
<p>对于接口来说，只有在此接口声明的非常量字段被使用，才会初始化，不会因为事先这个接口的子接口或者类要初始化而被初始化。</p>
<p>父类需要在子类之前初始化。当实现了接口的类被初始化时，不需要初始化父接口。然而，当实现了父接口的子类（或者拓展了父接口的子接口）被装载时，父接口也要被装载（装载但不实例化）。</p>
<h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保装载后的类型符合java语言的语义，并且不会危害整个虚拟机的完整性。</p>
<ul>
<li>装载时验证：检查二进制数据保证是预期格式。确保除object外的每个类都有父类，确保该类的父类已经被装载。</li>
<li>正式验证阶段：检查final类不能有子类，确保 final 方法不被覆盖、确保在类型和超类型之间没有不兼容的方法声明(比如拥有两个名字相同的方法，参数在数量、顺序、类型上都相同，但返回类型不同)。</li>
<li>符号引用的验证：当虚拟机搜寻一个被符号引用的元素(类型、字段或方法)时，必须首先确认该元素存在。如果虚拟机发现元素存在，则必须进一步检查引用类型有访问该元素的权限。</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>虚拟机为类变量分配内存，设置默认初始值。初始化阶段之前，类变量都没有被初始化为真正的初始值。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
</tr>
<tr>
<td align="center">blooean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>直白一点就是，将符号引用转化为直接引用，比如，将package com.source….转化为物理地址。</p>
<p>在类型的常量池中寻找类、接口、字段和方法的符号占用，把这些符号引用替换成直接引用的过程。</p>
<ul>
<li>类、接口的解析：判断所要转化成的直接引用是数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li>
<li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</li>
</ul>
<h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><p>所有类变量（静态量）初始化语句和类型的静态初始化器都被java编译器收集在一起，放到一个特殊的方法。对于类来说，方法叫初始化方法；对于接口来说，称为接口初始化方法。在类和接口的class文件中，称为&lt;clinit&gt;</p>
<ol>
<li>存在直接父类且父类没被初始化，先初始化直接父类。</li>
<li>类存在一个类初始化方法， 执行此方法。</li>
</ol>
<p>递归执行，所以第一个初始化的类一定是object。</p>
<p>虚拟机须确保初始化过程正确同步。如果多个县城需要初始化一个类，仅仅允许一个，其余的等待。</p>
<h4 id="Clinit方法"><a href="#Clinit方法" class="headerlink" title="Clinit方法"></a>Clinit方法</h4><ul>
<li>对于静态变量和静态初始化语句来说：执行的顺序和它们在类或接口中出现的顺序有关。</li>
<li><strong>并非所有的类都需要在它们的<code>class</code>文件中拥有<code>&lt;clinit&gt;()</code>方法，</strong> 如果类没有声明任何类变量，也没有静态初始化语句，那么它就不会有<code>&lt;clinit&gt;()</code>方法。如果类声明了类变量，但没有明确的使用类变量初始化语句或者静态代码块来初始化它们，也不会有<code>&lt;clinit&gt;()</code>方法。如果类仅包含静态<code>final</code>常量的类变量初始化语句，而且这些类变量初始化语句采用编译时常量表达式，类也不会有<code>&lt;clinit&gt;()</code>方法。**只有那些需要执行Java代码来赋值的类才会有<code>&lt;clinit&gt;()</code>**’</li>
<li><code>final</code>常量：Java虚拟机在使用它们的任何类的常量池或字节码中直接存放的是它们表示的常量值。</li>
</ul>
<h2 id="3、内存模型"><a href="#3、内存模型" class="headerlink" title="3、内存模型"></a>3、内存模型</h2><p>运行时数据区保存JVM在运行过程中产生的数据。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%202%20%E9%A1%B5.png" alt="java虚拟机-第 2 页"></p>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>各线程共享的内存区域，是虚拟机管理内存区域最大的一块。几乎所有的对象实例和数组实例都是在堆上分配，但是对着JIT编译器以及逃逸分析技术的发展，也可能被优化为在栈上分配。</p>
<p>还包含字符串字面量常量池。包含一个新生代，一个老年代。</p>
<p>新生代三个区，大部分对象在Eden去生成，survivor总有一个是空的。</p>
<p>老年代保存一些生命周期比较长的对象，当一个对象经过对此GC还没被回收，将移动到老年代。</p>
<h3 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h3><p>方法区的数据所有线程共享，为安全使用方法区的数据，需要注意线程安全问题。</p>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>主要保存类级别的数据，包括：</p>
<ul>
<li>ClassLoader Reference</li>
<li>Runtime Constant Pool<ul>
<li>数字常量</li>
<li>类属性引用</li>
<li>方法引用</li>
</ul>
</li>
</ul>
<p>在JVM1.8之前，方法区的实现为永久代。经常内存溢出。在JVM1.8方法区的实现改为<strong>元空间</strong>，元空间是在Native的一块内存空间。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>JVM线程启动时，分配独立的运行时栈，来保存方法调用。每个方法调用，都会入栈一个栈帧。</p>
<p>栈帧保存三个引用：<strong>本地变量表</strong>，<strong>操作数帧</strong>和当前方法<strong>所属类的运行时常量池</strong>。由于本地变量表和操作数栈的大小都在编译时确定，所以栈帧的大小是固定的。</p>
<p>被调用的方法返回或抛出异常，栈帧弹出。栈帧内的数据是线程安全的。</p>
<p>栈大小可以动态拓展，但是如果一个线程需要栈的大小超出允许的大小，抛出<code>StackOverflowError</code>。</p>
<h3 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h3><p>对于每个JVM线程，线程启动时有一个独立的PC计数器，保存当前执行的代码地址。如果是Native方法， PC的值是NULL。一旦执行完成，PC计数器会被更新为下一个需要执行代码的地址。</p>
<h3 id="Native-Method-Stack"><a href="#Native-Method-Stack" class="headerlink" title="Native Method Stack"></a>Native Method Stack</h3><p>本地方法栈执行的是native方法。native方法就是C++写的方法。</p>
<h3 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h3><p>可以直接调用的内存。堆外内存。D可以使用堆外内存。</p>
<p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为 <strong>避免了在 Java 堆和 Native 堆中来回复制数据</strong>。</p>
<h2 id="4、垃圾收集"><a href="#4、垃圾收集" class="headerlink" title="4、垃圾收集"></a>4、垃圾收集</h2><h3 id="对象存活检测"><a href="#对象存活检测" class="headerlink" title="对象存活检测"></a>对象存活检测</h3><p>垃圾回收器回收内存之前，先要确定哪些对象是活的，哪些对象可以回收。</p>
<ul>
<li><p>引用计数算法</p>
<p>对象添加引用计数器，引用时+1,引用失效-1。致命缺陷就是两个对象相互引用导致两个都无法回收。</p>
</li>
<li><p>根搜索算法</p>
<p>实际上是追踪从根节点开始的引用图。通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为<strong>引用链</strong>，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p>在根搜索算法追踪的过程，起点是GC Root，根据JVM的实现不同而不同，但是总会包含以下几个方面（堆外引用）：</p>
<ul>
<li>虚拟机栈中引用的对象 </li>
<li>方法区中的类静态属性引用的变量</li>
<li>方法区中的常量引用的变量</li>
<li>本地方法JNI的引用对象</li>
</ul>
<p>从GC Root开始的引用图，有向图，节点时对象，边是引用类型。JVM分为四种引用类型：<strong>强引用，软引用，弱引用，虚引用。</strong></p>
<p>一个对象的引用类型有多个，如何确定回收策略：</p>
<ul>
<li>单条引用链以链上最弱的一个引用类型来决定；</li>
<li>多条引用链以多个单条引用链中最强的一个引用类型来决定；</li>
</ul>
<p>在引用图，如果一个节点没有任何路径可达，确定回收。</p>
<p><strong>强引用：</strong></p>
<p>在java中普遍存在，类似于<code>Object o = new Object;</code>和其他引用的区别是：强引用禁止引用目标被GC收集，其他引用不禁止。</p>
<p><strong>软引用：</strong></p>
<p><strong>JVM 的实现需要在抛出 OutOfMemoryError 之前清除 SoftReference</strong>，但在其他的情况下可以选择清理的时间或者是否清除它们。</p>
<p>有用但不是必须，使用<code>java.lang.red.SoftReferencr</code>类表示，这个特性很适合做缓存，比如：网页缓存，图片缓存。</p>
<p><strong>弱引用：</strong></p>
<p>垃圾收集器在GC的时候会回收所有的弱引用，如果该弱引用和引用队列相关联，他会把该弱引用加入到队列。</p>
<p><strong>虚引用：</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="1、复制回收"><a href="#1、复制回收" class="headerlink" title="1、复制回收"></a>1、复制回收</h4><p>可用内存等分两份，同一时刻值使用其中一份。用完后将还存活的对象赋值到另一份，然后将这一份清空。能够有效避免内存碎片，但是减低了内存使用率。</p>
<p>解决了标记清除回收可能会产生大量不连续内存的问题。</p>
<h4 id="2、标记清除算法"><a href="#2、标记清除算法" class="headerlink" title="2、标记清除算法"></a>2、标记清除算法</h4><p>先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后恢复运行线程。标记清除后会产生大量不连续的内存碎片，造成空间浪费。</p>
<h4 id="3、标记整理算法"><a href="#3、标记整理算法" class="headerlink" title="3、标记整理算法"></a>3、标记整理算法</h4><p>和标记清除相似，不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而集成空闲时间。</p>
<h4 id="4、增量回收"><a href="#4、增量回收" class="headerlink" title="4、增量回收"></a>4、增量回收</h4><p>将程序拥有的内存空间分成若干区。程序的存储对象会分布在分区中，每次只对其中一个分区进行回收，从而避免程序全部运行线程暂停来进行回收，允许部分线程在不影响回收行为的情况下保持运行，降低回收时间，增加线程响应速度。</p>
<h4 id="5、分代回收"><a href="#5、分代回收" class="headerlink" title="5、分代回收"></a>5、分代回收</h4><p>对象拥有不同的生命周期，不同生命周期的对象采用不同的回收算法，以提高效率。</p>
<p><strong>记忆集：</strong></p>
<p>对象C在新生代，只被一个在老年代的D引用。如果运行新生代GC，要确定C是否被堆外引用，需要遍历老年代，代价比较大。JVM在对象引用的时候，会有个记忆集，记录从老年代到新生代的引用关系，并把记忆集中的老年代作为GC ROOT构建索引图，这样在新生代GC的时候就不需要遍历老年代。</p>
<p>但是记忆集有缺点：C &amp; D 其实都可以进行回收，但是由于记忆集的存在，不会将 C 回收。这里其实有一点 <strong>空间换时间</strong> 的意思。不过无论如何，它依然确保了垃圾回收所遵循的原则：<strong>垃圾回收确保回收的对象必然是不可达对象，但是不确保所有的不可达对象都会被回收</strong>。</p>
<h3 id="垃圾回收触发条件"><a href="#垃圾回收触发条件" class="headerlink" title="垃圾回收触发条件"></a>垃圾回收触发条件</h3><h4 id="1、堆内内存"><a href="#1、堆内内存" class="headerlink" title="1、堆内内存"></a>1、堆内内存</h4><p>对于HotSpot VM实现，GC只有两大种：</p>
<ol>
<li>Partial GC：并不收集整个GC堆<ul>
<li>Young GC：只收集新生代的GC</li>
<li>Old GC：只收集老年代的GC。只有 CMS的 Concurrent Collection 是这个模式</li>
<li>Mixed GC：收集整个 Young Gen 以及部分 Old Gen 的 GC。只有 G1 有这个模式</li>
</ul>
</li>
<li>Full GC：收集整个堆，包括 Young Gen、Old Gen、Perm Gen（如果存在的话）等所有部分的 GC 模式。</li>
</ol>
<p>最简单的分代式GC策略，按照HotSpot的serial GC的实现看，触发条件是：</p>
<ul>
<li>Young GC：新生代的eden区分配满的时候触发，把eden区存货的对象复制到一个Survivor区，当这个Survivor区满时，存活的对象被复制到另一个survivor区。</li>
<li>Full GC<ul>
<li>当准备要触发一次 Young GC 时，如果发现之前 Young GC 的平均晋升大小比目前 Old Gen剩余的空间大，则不会触发 Young GC 而是转为触发 Full GC</li>
<li>如果有 Perm Gen 的话，要在 Perm Gen分配空间但已经没有足够空间时</li>
<li><code>System.gc()</code></li>
<li>Heap dump</li>
</ul>
</li>
</ul>
<p>并发 GC 的触发条件就不太一样。以 CMS GC 为例，它主要是定时去检查 Old Gen 的使用量，当使用量超过了触发比例就会启动一次 GC，对 Old Gen做并发收集。</p>
<h4 id="2、堆外内存"><a href="#2、堆外内存" class="headerlink" title="2、堆外内存"></a>2、堆外内存</h4><p>DirectByteBuffer的引用是直接分配在堆的old区，回收时机是在FULLGC，因此需要避免频繁的分配directByteBuffer，这样就很容易导致Native Memory溢出。</p>
<p>DirectByteBuffer申请的直接内存，不在G范围内，无法自动回收。JDK提供一种机制，可以为堆内存对象注册一个钩子函数(其实就是实现 <code>Runnable</code> 接口的子类)，当堆内存对象被GC回收的时候，会回调run方法，我们可以在这个方法中执行释放 <code>DirectByteBuffer</code> 引用的直接内存，即在run方法中调用 <code>Unsafe</code> 的 <code>freeMemory</code> 方法。注册是通过<code>sun.misc.Cleaner</code> 类来实现的。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>内存回收的具体实现，以下为7种不同分代的收集器，有连线表示可以搭配使用。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%203%20%E9%A1%B5.png" alt="java虚拟机-第 3 页"></p>
<h4 id="1、Serial-收集器"><a href="#1、Serial-收集器" class="headerlink" title="1、Serial 收集器"></a>1、Serial 收集器</h4><p>最基本的收集器，单线程。是JVM在client模式下的默认新生代收集器。优点是：简单高效。此收集器没有线程交互的开销，效率高。在用户桌面的场景下，分配给JVM的内存不会太多，停顿时间在几十到一百多毫秒之间，只要不频繁收集，完全可以接受。</p>
<h4 id="2、Serial-Old收集器"><a href="#2、Serial-Old收集器" class="headerlink" title="2、Serial Old收集器"></a>2、Serial Old收集器</h4><p>Serial的老年代版本，单线程，采用“标记-整理算法”进行垃圾回收。</p>
<h4 id="3、ParNew-收集器"><a href="#3、ParNew-收集器" class="headerlink" title="3、ParNew 收集器"></a>3、ParNew 收集器</h4><p>Serial的多线程版本，是许多运行在Server模式下的默认新生代GC，主要与CMS收集器配合工作。</p>
<h4 id="4、Parallel-Scavenge-收集器"><a href="#4、Parallel-Scavenge-收集器" class="headerlink" title="4、Parallel Scavenge 收集器"></a>4、Parallel Scavenge 收集器</h4><p>新生代GC，多线程收集器。更关注可控制的吞吐量，吞吐量等于运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）。</p>
<h4 id="5、Parallel-Old"><a href="#5、Parallel-Old" class="headerlink" title="5、Parallel Old"></a>5、Parallel Old</h4><p>是Parallel Scavenge的老年代版本，多线程，通常与Parallel Scavenge配合使用。</p>
<h4 id="6、CMS-收集器"><a href="#6、CMS-收集器" class="headerlink" title="6、CMS 收集器"></a>6、CMS 收集器</h4><p>目标是获取最短停顿时间，采用“标记-清除”算法，运行在老年代，包含以下步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>其中初始标记和重新标记仍然需要stop the world。初始标记仅仅标记GC ROOT能直接关联的对象，并发标记是为了记性GC ROOT Tracing过程，重新标记是为了修正并发标记期间，因为用户程序继续运行而导致标记变动的那部分对象的标记记录。</p>
<p>最耗时的是并发表标记和并发清除，收集线程和用户线程一起工作，总体来说，CMS GC回收和用户程序并行。优点是并发收集、低停顿，但是有三个缺点：</p>
<ul>
<li>对CPU资源很敏感：并发阶段不停用用户进程，但是占用线程导致程序变慢。</li>
<li>不能处理浮动垃圾：浮动垃圾就是在并发标记阶段，用户程序运行产生新的垃圾，这部分垃圾在标记后，CMS无法在当次集中处理，只能在下一次GC处理，这部分垃圾就称为浮动垃圾。</li>
</ul>
<p>正是由于在垃圾收集阶段程序还需要运行，即还需要预留足够的内存空间供用户使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎填满才进行收集，需要预留一部分空间提供并发收集时程序运作使用。要是 CMS 预留的内存空间不能满足程序的要求，这是 JVM 就会启动预备方案：<strong>临时启动 Serial Old 收集器来收集老年代</strong>，这样停顿的时间就会很长。</p>
<h4 id="6、G1收集器"><a href="#6、G1收集器" class="headerlink" title="6、G1收集器"></a>6、G1收集器</h4><p>比GMS有很大改进：</p>
<ul>
<li>标记整理算法：采用标记整理算法实现</li>
<li>增量回收模式：将Heap分割成多个Region，并在后台维护一个优先列表，每次根据允许的时间，优先回收垃圾最多的区域。</li>
</ul>
<p>因此G1收集器可以实现在基本不牺牲吞吐量的情况下完成低停顿的内存回收，这是正式由于他极力的避免全区域回收。</p>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th align="center">垃圾收集器</th>
<th align="center">特性</th>
<th align="center">算法</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">串行</td>
<td align="center">复制</td>
<td align="center">高效：无线程切换</td>
<td align="center">无法利用多核CPU</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">并行</td>
<td align="center">复制</td>
<td align="center">可利用多核CPU、唯一能与CMS配合的并行收集器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">并行</td>
<td align="center">复制</td>
<td align="center">高吞吐量</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">串行</td>
<td align="center">标记整理</td>
<td align="center">高效</td>
<td align="center">无法利用多核CPU</td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">并行</td>
<td align="center">标记整理</td>
<td align="center">高吞吐量</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">并行</td>
<td align="center">标记清除</td>
<td align="center">低停顿</td>
<td align="center">CPU敏感，浮动垃圾，内存碎片</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">并行</td>
<td align="center">增量回收</td>
<td align="center">低停顿。高吞吐量</td>
<td align="center">内存使用效率低：分区导致内存不能充分使用</td>
</tr>
</tbody></table>
<h2 id="5、Java分配机制"><a href="#5、Java分配机制" class="headerlink" title="5、Java分配机制"></a>5、Java分配机制</h2><p>java中符合“编译时可知，运行时不可变”要求的主要是静态方法和私有方法。因此适合在类加载时进行解析。</p>
<p>java虚拟机中有四种方法调用指令：</p>
<ul>
<li>invokestatic：调用静态方法。</li>
<li>invokespecial：调用实例构造方法，私有方法和super</li>
<li>invokeinterface：调用接口方法</li>
<li>invokevirtual：调用以上指令不能调用的方法（虚方法）。</li>
</ul>
<p>只要能被static和special指令调用的方法，都可以在解析阶段唯一确定调用版本，符合条件的有：静态方法，私有方法，实例构造器，父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法， 反之称为虚方法，（final除外）。</p>
<blockquote>
<p>虽然final方法是使用virtual指令来调用，但是无法被覆盖，多态的选择是唯一的，所以是一种虚方法。</p>
</blockquote>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><blockquote>
<p>对于类字段的访问也采用静态分派</p>
</blockquote>
<p><code>People man =  new Man()</code></p>
<p>静态分派主要针对重载，方法调用时如何选择。在上面的代码，Peopel被称为变量的引用类型，Man称为变量的实际类型。静态类型在编译时可知，动态类型在运行时可知。</p>
<p>编译器在重载时候通过参数的静态类型而不是实际类型作为判断依据。并且静态类型咋编译时可知，所以编译器根据重载的参数的静态类型进行方法选择。</p>
<blockquote>
<p>在某些情况下有多个重载，那编译器如何选择呢？ 编译器会选择”最合适”的函数版本，那么怎么判断”最合适“呢？越接近传入参数的类型，越容易被调用。</p>
</blockquote>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>主要针对重写，使用virtual指令调用，virtual指令多态查找过程：</p>
<ul>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果权限校验不通过，返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常。</li>
</ul>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>动态分配很繁琐，而且动态分派的方法版本的选择需要考虑运行时咋类的方法数据中搜索合适的目标方法，因为在虚拟机的实现中基于性能的考虑，在方法区中建立一个虚方法表来提高性能。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210324125440920.png" alt="image-20210324125440920"></p>
<p>虚方法表中存放各个方法的实际入口地址。如果某个方法在子类中没有重写，那么子类的虚方法表里的入口和父类入口一致，如果子类重写了这个方法，那么子类方法表中的地址会被替换成子类实现版本的入口地址。</p>
<h2 id="6、String常量池"><a href="#6、String常量池" class="headerlink" title="6、String常量池"></a>6、String常量池</h2><p>常量池类似于一个JAVA系统级别提供的缓存。</p>
<p>String类型的常量池比较特殊，使用方法：</p>
<ul>
<li>直接使用双引号声明的String对象会直接存储在常量池。</li>
<li>不是使用双引号，可以使用String提供的inter方法，该方法会从字符串常量池中查询当前字符串是否存在，不存在则放入常量池。</li>
</ul>
<h3 id="Intern"><a href="#Intern" class="headerlink" title="Intern"></a>Intern</h3><p>java使用Jni调用C++实现的StringTable的Intern方法，StringTable跟java中的HashMap实现差不多，但是不能扩容。默认大小是<code>1009</code></p>
<p>要注意的是， <code>String</code> 的 <code>String Pool</code> 是一个固定大小的 <code>Hashtable</code> ，默认值大小长度是 <code>1009</code> ，如果放进 <code>String Pool</code> 的 <code>String</code> 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 <code>String.intern</code> 时性能会大幅下降。</p>
<p>JDK6中StringTable固定，但是JDK7可以通过参数指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：StringTableSize&#x3D;99991</span><br></pre></td></tr></table></figure>

<p>在6和以前的版本，字符串的常量池存放在Perm区，7的版本中，转移到正常的Heap区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s &#x3D; new String(&quot;1&quot;);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 &#x3D; &quot;1&quot;;</span><br><span class="line">    System.out.println(s &#x3D;&#x3D; s2);</span><br><span class="line"></span><br><span class="line">    String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 &#x3D; &quot;11&quot;;</span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>JDK6：false false</li>
<li>JDK7：fale true</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s &#x3D; new String(&quot;1&quot;);</span><br><span class="line">    String s2 &#x3D; &quot;1&quot;;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s &#x3D;&#x3D; s2);</span><br><span class="line"></span><br><span class="line">    String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">    String s4 &#x3D; &quot;11&quot;;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>6：false false</li>
<li>7：false false</li>
</ul>
<p>由于7将字符串常量池放到Heap中，导致差异。</p>
<h4 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h4><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/1.png" alt="1"></p>
<p>黑色线表示String对象的内容指向，红色代表地址指向。</p>
<p>在jdk6中所有打印都是false，因为常量池在Perm中，Perm和正常的Heap是分开的，引号声明的字符串直接在常量池生成，而new出来的String存放在Heap，地址肯定不同，及时调用String.intern()方法也是没有很合关系。</p>
<h3 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h3><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%205%20%E9%A1%B5.png" alt="java虚拟机-第 5 页"></p>
<ul>
<li>第一段代码，<code>String s3 = new String(&quot;1&quot;)+new String(&quot;1&quot;);</code>，代码生成两个最终对象，是常量池中的“1”和Heap中S3引用指向的对象。此时S3引用的对象是“11”，但是常量池没有“11”对象。</li>
<li>接下来S3.intern()是讲S3中的“11”放入常量池。但是7中的常量池不在Perm区域了，常量池中不需要再存储一份对象，可以直接存储占中的引用。这份引用指向S3的对象。引用地址是相同的。</li>
<li>最后 <code>String s4 = &quot;11&quot;;</code> 这句代码中 <code>”11”</code> 是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 <code>s3</code> 引用对象的一个引用。所以 <code>s4</code> 引用就指向和 <code>s3</code> 一样了。因此最后的比较 <code>s3 == s4</code> 是 <code>true</code> 。</li>
<li>再看 <code>s</code> 和 <code>s2</code> 对象。 <code>String s = new String(&quot;1&quot;);</code> 第一句代码，生成了2个对象。常量池中的 <code>“1”</code> 和 <code>JAVA Heap</code> 中的字符串对象。<code>s.intern();</code> 这一句是 <code>s</code> 对象去常量池中寻找后发现 <code>“1”</code> 已经在常量池里了。</li>
<li>接下来 <code>String s2 = &quot;1&quot;;</code> 这句代码是生成一个 <code>s2</code> 的引用指向常量池中的 <code>“1”</code> 对象。 结果就是 <code>s</code> 和 <code>s2</code> 的引用地址明显不同。</li>
</ul>
<p>接下来是第二段代码：</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%206%20%E9%A1%B5.png" alt="java虚拟机-第 6 页"></p>
<ul>
<li>第一段代码和第二段代码的改变就是 <code>s3.intern();</code> 的顺序是放在 <code>String s4 = &quot;11&quot;;</code> 后了。这样，首先执行 <code>String s4 = &quot;11&quot;;</code> 声明 <code>s4</code> 的时候常量池中是不存在 <code>“11”</code> 对象的，执行完毕后， <code>“11“</code> 对象是 <code>s4</code> 声明产生的新对象。然后再执行 <code>s3.intern();</code> 时，常量池中 <code>“11”</code> 对象已经存在了，因此 <code>s3</code> 和 <code>s4</code> 的引用是不同的。</li>
<li>二段代码中的 <code>s</code> 和 <code>s2</code> 代码中，<code>s.intern();</code>，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码<code>String s = new String(&quot;1&quot;);</code> 的时候已经生成 <code>“1”</code> 对象了。下边的 <code>s2</code> 声明都是直接从常量池中取地址引用的。 <code>s</code> 和 <code>s2</code> 的引用地址是不会相等的。</li>
</ul>
<h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p>对intern和常量池都做了一定的修改，主要包括：</p>
<ul>
<li>将String常量池从Perm区移动到了Heap区</li>
<li>String.intern方法时，如果heap中存在对象，将会直接保存对象的引用，而不是重新创建对象。</li>
</ul>
<h4 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static final int MAX &#x3D; 1000 * 10000;</span><br><span class="line">static final String[] arr &#x3D; new String[MAX];</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Integer[] DB_DATA &#x3D; new Integer[10];</span><br><span class="line">    Random random &#x3D; new Random(10 * 10000);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; DB_DATA.length; i++) &#123;</span><br><span class="line">        DB_DATA[i] &#x3D; random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">	long t &#x3D; System.currentTimeMillis();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; MAX; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;arr[i] &#x3D; new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span><br><span class="line">         arr[i] &#x3D; new String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	System.out.println((System.currentTimeMillis() - t) + &quot;ms&quot;);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一条是使用 intern，一条是未使用 intern。</p>
<p>通过上述结果，我们发现不使用 <code>intern</code> 的代码生成了 <code>1000w</code> 个字符串，占用了大约 <code>640m</code> 空间。 使用了 <code>intern</code> 的代码生成了 <code>1345</code> 个字符串，占用总空间 <code>133k</code> 左右。其实通过观察程序中只是用到了 <code>10</code> 个字符串，所以准确计算后应该是正好相差 <code>100w</code> 倍。虽然例子有些极端，但确实能准确反应出 intern 使用后产生的巨大空间节省。</p>
<p> <code>intern</code> 方法后时间上有了一些增长。这是因为程序中每次都是用了 <code>new String</code> 后，然后又进行 <code>intern</code> 操作的耗时时间，这一点如果在内存空间充足的情况下确实是无法避免的，但我们平时使用时，内存空间肯定不是无限大的，不使用 <code>intern</code> 占用空间导致 <code>jvm</code> 垃圾回收的时间是要远远大于这点时间的。</p>
<h2 id="7、对象生命周期"><a href="#7、对象生命周期" class="headerlink" title="7、对象生命周期"></a>7、对象生命周期</h2><h3 id="类实例化"><a href="#类实例化" class="headerlink" title="类实例化"></a>类实例化</h3><p>实例化类的四个途径：</p>
<ul>
<li>new</li>
<li>调用class或者java.lang.reflect.Constructor对象的NewInstance</li>
<li>调用任何现有对象的clone</li>
<li>通过<code>java.io.ObjectInputStream.getObject()</code>反序列化。</li>
</ul>
<p>隐含的实例化：</p>
<ul>
<li>保存命令行参数的String对象</li>
<li>虚拟机装载的每个类，都会暗中实例化一个class对象来代表这个类型。</li>
<li>当Java虚拟机装载了在常量池中包含<code>CONSTANT_String_info</code>入口的类的时候，它会创建新的<code>String</code>对象来表示这些常量字符串。</li>
<li>执行包含字符串连接操作符的表达式会产生新的对象。</li>
</ul>
<h3 id="垃圾收集和对象的终结"><a href="#垃圾收集和对象的终结" class="headerlink" title="垃圾收集和对象的终结"></a>垃圾收集和对象的终结</h3><p>程序可以分配内存但不能释放内存，一个对象不再为程序引用，虚拟机必须回收那部分内存。</p>
<h3 id="卸载类"><a href="#卸载类" class="headerlink" title="卸载类"></a>卸载类</h3><p>虚拟机中类的生命周期和对象的生命周期相似。当程序不再使用某个类的时候，可以选择卸载他们。</p>
<p>虚拟机通过判断类是否在被引用来实现垃圾收集。判断动态装载类的Class实例在正常的垃圾收集过程中是否可触及有两种方式：</p>
<ul>
<li>如果实例非Class实例的明确引用。</li>
<li>如果在堆中还存在一个可触及对象，在方法区中它的类型数据指向一个Class实例。</li>
</ul>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210324173320715.png" alt="image-20210324173320715"></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1、Spring"><a href="#1、Spring" class="headerlink" title="1、Spring"></a>1、Spring</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul>
<li>Spring：春天—-&gt;给软件行业带来了春天！</li>
<li>2002，首次推出了Spring框架的雏形：interface21框架！</li>
<li>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富内涵，于2004年3月24日，发布了1.0正式版。</li>
<li><strong>Rod Johnson</strong>，Spring Framework创始人，著名作者。很难想象其学历，真的让好多人大吃一惊，他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。</li>
<li>spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。</li>
<li><strong>SSH：Struct2+Spring+Hibernate!</strong></li>
<li><strong>SSM：SpringMVC+Spring+Mybatis!</strong></li>
</ul>
<p>​    </p>
<p>官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a></p>
<p>官方下载地址：<a target="_blank" rel="noopener" href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>Github：<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<p>Maven仓库：导入webmvc包会自动导入相关依赖；jdbc用于和Mybatis整合。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li><p>Spring是一个开源的免费的框架（容器）！</p>
</li>
<li><p>Spring是一个轻量级的、非入侵式的框架！</p>
</li>
<li><p>控制反转（IOC）、面向切面编程（AOP）！</p>
</li>
<li><p>支持事务的处理，对框架整合的支持！</p>
<p><strong>总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程的框架！</strong></p>
</li>
</ul>
<h3 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h3><p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185352.png" alt="image-20200102001447503"></p>
<h3 id="1-4-拓展"><a href="#1-4-拓展" class="headerlink" title="1.4 拓展"></a>1.4 拓展</h3><p>在Spring的官网有这个介绍：现代化的java开发！说白了就是基于Spring的开发！</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185356.png" alt="image-20200102001823229"></p>
<ul>
<li>Spring Boot<ul>
<li>一个快速开发的脚手架。</li>
<li>基于Spring Boot可以快速的开发单个微服务。</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>SpringCloud是基于SpringBoot实现的。</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring以及SpringMVC！承上启下的作用。</p>
<p><strong>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”。</strong></p>
<h2 id="2、-IOC理论推导"><a href="#2、-IOC理论推导" class="headerlink" title="2、 IOC理论推导"></a>2、 IOC理论推导</h2><p>1.UserDao接口</p>
<p>2.UserDaoImpl实现类</p>
<p>3.UserService业务接口</p>
<p>4.UserServiceImpl业务实现类</p>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码!如果程序代码量十分大，修改一次的成本代价十分昂贵！</p>
<p>我们使用一个Set接口实现，已经发生了革命性的变化！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用set进行动态实现值的注入！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！</li>
</ul>
<p>这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注在业务的实现上。这是IOC的原型！</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185402.png" alt="image-20200102111735712"></p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185410.png" alt="image-20200102111753076"></p>
<h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p><strong>控制反转IOC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IOC的一种方法，</strong>也有人认为DI是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入（Dependency Injection,DI）</strong>。</p>
<h2 id="3、-Hello-Spring"><a href="#3、-Hello-Spring" class="headerlink" title="3、 Hello Spring"></a>3、 Hello Spring</h2><p>beans.xml官网配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>bean对象添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoMysqlImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;oracleImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoOracleImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;UserServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ref：引用Spring容器中已经创建好的对象</span></span><br><span class="line"><span class="comment">        value：具体的值，基本数据类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mysqlImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析beans.xml文件，生成管理相应的Bean对象</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="comment">//getBean:参数即为spring配置文件中bean的id</span></span><br><span class="line">Hello hello = (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(hello.toString());</span><br></pre></td></tr></table></figure>

<h3 id="思考问题？"><a href="#思考问题？" class="headerlink" title="思考问题？"></a><strong>思考问题</strong>？</h3><ul>
<li><p>Hello对象是谁创建的？</p>
<p>hello对象是由Spring创建的。</p>
</li>
<li><p>Hello对象的属性是怎么设置的？</p>
<p>hello对象的属性是由Spring容器设置的。</p>
</li>
</ul>
<p>这个过程就叫做控制反转：</p>
<p>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。</p>
<p>反转：程序本身不创建对象，而变成被动的接收对象。</p>
<p>依赖注入：就是利用set方法来进行注入。</p>
<p>IoC是一种编程思想，由主动的编程编程被动的接收。</p>
<p>可以通过new ClassPathXmlApplicationContext去浏览一下底层源码。</p>
<p><strong>OK，到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IoC，一句话搞定：对象由Spring来创建，管理，装配！</strong></p>
<p>IDEA快捷创建beans.xml文件，自动导入spring配置信息：</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185416.png" alt="image-20200102152125077"></p>
<h2 id="4、-IoC创建对象的方式"><a href="#4、-IoC创建对象的方式" class="headerlink" title="4、 IoC创建对象的方式"></a>4、 IoC创建对象的方式</h2><ol>
<li><p>使用无参构造创建对象，默认方式！</p>
</li>
<li><p>假设我们要使用有参构造创建对象。</p>
<p>1.下标赋值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种，下标赋值！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.类型赋值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二种，通过类型创建，不建议使用，重复类型难以分辨--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大憨批&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.参数名赋值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种，直接通过参数名来设置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;臭憨批&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</p>
<h2 id="5、-Spring配置"><a href="#5、-Spring配置" class="headerlink" title="5、 Spring配置"></a>5、 Spring配置</h2><h3 id="5-1-别名"><a href="#5-1-别名" class="headerlink" title="5.1 别名"></a>5.1 别名</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--别名，如果添加了别名，我们也可以使用别名获取到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-Bean的配置"><a href="#5-2-Bean的配置" class="headerlink" title="5.2 Bean的配置"></a>5.2 Bean的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id:bean的唯一标识符，相当于我们学的对象名；</span></span><br><span class="line"><span class="comment">    class：bean对象所对应的全限定名：包名+类名；</span></span><br><span class="line"><span class="comment">    name：也是别名，可以同时取多个别名，逗号分割</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2,u2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-import"><a href="#5-3-import" class="headerlink" title="5.3 import"></a>5.3 import</h3><p>这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个。</p>
<p>假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！</p>
<ul>
<li>张三</li>
<li>李四</li>
<li>王五</li>
<li>applicationContext.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans2.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans3.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用的时候，直接使用总的配置就可以了。</p>
<h2 id="6、-依赖注入"><a href="#6、-依赖注入" class="headerlink" title="6、 依赖注入"></a>6、 依赖注入</h2><h3 id="6-1-构造器注入"><a href="#6-1-构造器注入" class="headerlink" title="6.1 构造器注入"></a>6.1 构造器注入</h3><p>之前已经介绍过。</p>
<h3 id="6-2-Set方式注入【重点】"><a href="#6-2-Set方式注入【重点】" class="headerlink" title="6.2 Set方式注入【重点】"></a>6.2 Set方式注入【重点】</h3><ul>
<li>依赖注入：Set注入！<ul>
<li>依赖：bean对象的创建依赖于容器！</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<p>【环境搭建】</p>
<ol>
<li><p>复杂类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>真实测试对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>beans.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一种，普通值注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    <strong>完善注入：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;address&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.Address&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;student&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span><br><span class="line">        &lt;!--第一种，普通值注入，value--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;憨批&quot;</span>/&gt;</span><br><span class="line">        &lt;!--第二种，Bean注入，ref--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;address&quot;</span> ref=<span class="string">&quot;address&quot;</span>/&gt;</span><br><span class="line">        &lt;!--数组注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;books&quot;</span>&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;红楼梦&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;西游记&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;水浒传&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;三国演义&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--List注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;hobbies&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;听歌&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;敲代码&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;看电影&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--Map--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;身份证&quot;</span> value=<span class="string">&quot;1555555555&quot;</span>/&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;银行卡&quot;</span> value=<span class="string">&quot;5555555555&quot;</span>/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--Set--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;games&quot;</span>&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;lol&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;wow&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--<span class="keyword">null</span>--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;wife&quot;</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">null</span>/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--Properties--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">&quot;url&quot;</span>&gt;jdbc:mysql:<span class="comment">//localhost:3306/news&lt;/prop&gt;</span></span><br><span class="line">                &lt;prop key=&quot;root&quot;&gt;root&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-3-拓展方式注入"><a href="#6-3-拓展方式注入" class="headerlink" title="6.3 拓展方式注入"></a>6.3 拓展方式注入</h3><p>我们可以使用c和p命令空间进行注入：</p>
<p>使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;憨批&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--c命名空间注入，通过构造器注入：construct-args--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;userBeans.xml&quot;</span>);</span><br><span class="line">    User user = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：p和c命名空间不能直接使用，需要导入xml约束！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-bean的作用域"><a href="#6-4-bean的作用域" class="headerlink" title="6.4 bean的作用域"></a>6.4 bean的作用域</h3><ol>
<li><p>代理模式（Spring默认机制）：get到的都是同一个对象！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;憨批&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>原型模式：每次从容器中get的时候，都会产生一个新的对象！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;憨批&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其余的request、session、application、这些个只能在web开发中使用。</p>
</li>
</ol>
<h2 id="7、-Bean的自动装配"><a href="#7、-Bean的自动装配" class="headerlink" title="7、 Bean的自动装配"></a>7、 Bean的自动装配</h2><ul>
<li>自动装配是Spring满足bean依赖的一种方式！</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性！</li>
</ul>
<p>在Spring中有三种装配的方式：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的自动装配bean</li>
</ol>
<h3 id="7-1-测试"><a href="#7-1-测试" class="headerlink" title="7.1 测试"></a>7.1 测试</h3><p>环境搭建：一个人有两个宠物！</p>
<h3 id="7-2-ByName自动装配"><a href="#7-2-ByName自动装配" class="headerlink" title="7.2 ByName自动装配"></a>7.2 ByName自动装配</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    byName:会自动在容器上下文中查找和自己对象set方法后面的值对应的beanid！</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-ByType自动装配"><a href="#7-3-ByType自动装配" class="headerlink" title="7.3 ByType自动装配"></a>7.3 ByType自动装配</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean！必须保证类型全局唯一。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！</li>
<li>byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！</li>
</ul>
<h3 id="7-4-使用注解实现自动装配"><a href="#7-4-使用注解实现自动装配" class="headerlink" title="7.4 使用注解实现自动装配"></a>7.4 使用注解实现自动装配</h3><p>jdk1.5支持注解，Spring2.5开始支持注解。</p>
<p>要使用注解须知：</p>
<ol>
<li><p>导入约束：context约束。</p>
</li>
<li><p>配置注解的支持：<a href="context:annot-config/">context:annot-config/</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>@Autowired</strong></p>
<p>直接在属性上使用即可！也可以在set方式上使用！</p>
<p>使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IoC（Spring）容器中存在，且符合名字byName！</p>
<p>科普：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span>	字段标记了这个注解，说明这个字段可以为<span class="keyword">null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(<span class="meta">@Nullable</span> String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果显式定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired完成的时候，我们可以使用@Qualifier(value=”xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;dog11&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier(value=&quot;cat11&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Resource注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;cat2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>@Resource和@Autowired的区别：</p>
<ul>
<li><p>都是用来自动装配的，都可以放在属性字段上；</p>
</li>
<li><p>@Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】</p>
</li>
<li><p>@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！</p>
</li>
<li><p>执行顺序不同：@Autowired通过byType的方式实现，@Resource默认通过byName的方式实现。</p>
</li>
</ul>
<h2 id="8、-使用注解开发"><a href="#8、-使用注解开发" class="headerlink" title="8、 使用注解开发"></a>8、 使用注解开发</h2><p>在spring4之后，要使用注解开发，必须要保证aop的包导入了。</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185433.png" alt="image-20200103105725321"></p>
<p>使用注解需要导入context约束，增加注解的支持！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定要扫描的包，这个包下的注解会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>bean</p>
</li>
<li><p>属性如何注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="comment">//@Component 组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于&lt;property name=&quot;name&quot; value=&quot;小憨批&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;小憨批&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>衍生的注解</p>
<p>@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！</p>
<ul>
<li>dao【@Repository】</li>
<li>service【@Service】</li>
<li>controller【@Controller】</li>
</ul>
<p>这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean！</p>
</li>
<li><p>自动装配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-@Autowired:自动装配通过类型，名字</span><br><span class="line">	如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value&#x3D;&quot;xxx&quot;)</span><br><span class="line">-@Nullable:字段标记了这个注解，说明这个字段可以为null</span><br><span class="line">-@Resource:自动装配通过名字，类型</span><br></pre></td></tr></table></figure></li>
<li><p>作用域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于&lt;property name=&quot;name&quot; value=&quot;小憨批&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;小憨批&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>小结</p>
<p>xml与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单方便。</li>
<li>注解，不是自己的类使用不了，维护相对复杂！</li>
</ul>
<p>xml与注解最佳实践：</p>
<ul>
<li>xml用来管理bean；</li>
<li>注解只负责完成属性的注入；</li>
<li>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--指定要扫描的包，这个包下的注解会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="9、-使用java的方式配置Spring"><a href="#9、-使用java的方式配置Spring" class="headerlink" title="9、 使用java的方式配置Spring"></a>9、 使用java的方式配置Spring</h2><p>我们现在要完全不适用Spring的xml配置了，全权交给java来做！</p>
<p>javaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能。</p>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;小笨蛋&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个也会被Spring容器托管，注册到容器中，因为本来就是一个@Component</span></span><br><span class="line"><span class="comment">//@Configuration代表这是一个配置类，就和我们之前看的beans.xml</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.kuang.pojo&quot;)</span></span><br><span class="line"><span class="meta">@Import(KuangConfig2.class )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KuangConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册一个bean，就相当于我们之前写的一个bean标签</span></span><br><span class="line">    <span class="comment">//这个方法的名字，就相当于bean标签中的id属性</span></span><br><span class="line">    <span class="comment">//这个方法的返回值，就相当于bean标签中的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();<span class="comment">//就是返回要注入到bean的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载！</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(KuangConfig.class);</span><br><span class="line">        User getUser = (User) context.getBean(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">        System.out.println(getUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种纯java的配置方式，在SpringBoot中随处可见！</p>
<h2 id="10、-代理模式"><a href="#10、-代理模式" class="headerlink" title="10、 代理模式"></a>10、 代理模式</h2><p>为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP 和 SpringMVC  面试必问】</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185442.png" alt="image-20200104125508118"></p>
<h3 id="10-1-静态代理"><a href="#10-1-静态代理" class="headerlink" title="10.1 静态代理"></a>10.1 静态代理</h3><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作。</li>
<li>客户：访问代理对象的人！</li>
</ul>
<p>代码步骤：</p>
<ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>真实角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东要出租房子！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代理角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.rent();</span><br><span class="line">        hetong();</span><br><span class="line">        fee();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介带你看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//签合同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hetong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收取中介费用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//房东要租房子</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理，中介帮房东租房子，但是呢？代理角色一般会有一些附属操作！</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低</li>
</ul>
<h3 id="10-2-加深理解"><a href="#10-2-加深理解" class="headerlink" title="10.2 加深理解"></a>10.2 加深理解</h3><p>代码：对应08-demo02</p>
<p>聊聊AOP</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185513.png" alt="image-20200105210505898"></p>
<h3 id="10-3-动态代理"><a href="#10-3-动态代理" class="headerlink" title="10.3 动态代理"></a>10.3 动态代理</h3><ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的。</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul>
<li>基于接口——JDK动态代理</li>
<li>基于类：cglib</li>
<li>java字节码实现：javasisit</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序</p>
<p>动态代理的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
<li>一个动态代理类代理类代理的是一个接口，一般就是对应的一类业务</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可！</li>
</ul>
<h2 id="11、-AOP"><a href="#11、-AOP" class="headerlink" title="11、 AOP"></a>11、 AOP</h2><h3 id="11-1-什么是AOP"><a href="#11-1-什么是AOP" class="headerlink" title="11.1 什么是AOP"></a>11.1 什么是AOP</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的频率。</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185518.png" alt="image-20200106085441897"></p>
<h3 id="11-2-AOP在Spring中的作用"><a href="#11-2-AOP在Spring中的作用" class="headerlink" title="11.2 AOP在Spring中的作用"></a>11.2 AOP在Spring中的作用</h3><p>==提供声明式事务；允许用户自定义切面==</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点，如日志、安全、缓存、事务等等……</li>
<li>切面（ASPECT）：横切关注点被模块化的特殊对象，即是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作，即是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知执行的“地点”的定义。</li>
<li>连接点（jointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185523.png" alt="image-20200106090325307"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185528.png" alt="image-20200106090428369"></p>
<p>即AOP在不改变原有代码的情况下，去增加新的功能。</p>
<h3 id="11-3-使用Spring实现AOP"><a href="#11-3-使用Spring实现AOP" class="headerlink" title="11.3 使用Spring实现AOP"></a>11.3 使用Spring实现AOP</h3><p>【重点】使用AOP织入，需要导入一个依赖包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>方式一：使用Spring的API接口【主要SpringAPI接口实现】</p>
<p>方式二：自定义来实现AOP【主要是切面定义】</p>
<p>方式三：使用注解实现</p>
<h2 id="12、-整合Mybatis"><a href="#12、-整合Mybatis" class="headerlink" title="12、 整合Mybatis"></a>12、 整合Mybatis</h2><p>步骤：</p>
<ol>
<li>导入相关jar包<ul>
<li>junit</li>
<li>Mybatis</li>
<li>mysql数据库</li>
<li>spring相关的</li>
<li>aop织入</li>
<li>mybatis-spring【new知识点】</li>
</ul>
</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h3 id="12-1-回忆mybatis"><a href="#12-1-回忆mybatis" class="headerlink" title="12.1 回忆mybatis"></a>12.1 回忆mybatis</h3><ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写Mapper.xml</li>
<li>测试</li>
</ol>
<h3 id="12-2-Mybatis-Spring"><a href="#12-2-Mybatis-Spring" class="headerlink" title="12.2 Mybatis-Spring"></a>12.2 Mybatis-Spring</h3><ol>
<li>编写数据源配置</li>
<li>sqlSessionFactory</li>
<li>sqlSessionTemplate</li>
<li>需要给接口加实现类</li>
<li>将自己写的实现类，注入到Spring中</li>
<li>测试</li>
</ol>
<h2 id="13、-声明式事务"><a href="#13、-声明式事务" class="headerlink" title="13、 声明式事务"></a>13、 声明式事务</h2><h3 id="13-1-回顾事务"><a href="#13-1-回顾事务" class="headerlink" title="13.1 回顾事务"></a>13.1 回顾事务</h3><ul>
<li>把一组业务当成一个业务来做：要么都成功，要么都失败。</li>
<li>事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎。</li>
<li>确保完整性和一致性。</li>
</ul>
<p>事务ADID原则：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性<ul>
<li>多个业务可能操作同一个资源，防止数据损坏</li>
</ul>
</li>
<li>持久性<ul>
<li>事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中。</li>
</ul>
</li>
</ul>
<p>13.2 Spring中的事务管理</p>
<ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要在代码中，进行事务的管理</li>
</ul>
<p>思考：</p>
<p>为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况</li>
<li>如果我们不在Spring中去配置声明式事务，我们就需要在代码中手动配置事务</li>
<li>事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">参考自javaGuide</a></p>
<h3 id="什么是Spring框架"><a href="#什么是Spring框架" class="headerlink" title="什么是Spring框架"></a>什么是Spring框架</h3><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<h3 id="列举一些重要的Spring模块"><a href="#列举一些重要的Spring模块" class="headerlink" title="列举一些重要的Spring模块"></a>列举一些重要的Spring模块</h3><ul>
<li>core：基础，主要提供IOC依赖注入功能。</li>
<li>AOP：面向切面编程的实现</li>
<li>JDBC ：java数据库连接</li>
<li>JMS：消息服务</li>
<li>WEB：创建web应用程序提供支持</li>
<li>Test：提供了对JUnit和TestNG测试的支持。</li>
</ul>
<h3 id="RestController和-Controller"><a href="#RestController和-Controller" class="headerlink" title="@RestController和@Controller"></a>@RestController和@Controller</h3><p>restcontroller在spring4之后才有，之前必须使用controller+responsebody</p>
<h3 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h3><ul>
<li><p>对IOC和AOP的理解</p>
<p>IOC容器实际上就是一个Map(key,value)，存放的是各种对象。spring时代通过xml配置bean，在boot时代通过注解配置bean。</p>
<p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。基于动态代理的。如果代理的对象，实现了某个接口，使用JDK，没有实现的使用CGLAB代理。</p>
</li>
</ul>
<h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><ul>
<li><p>作用域</p>
<ul>
<li>singleton：唯一bean实例，默认是单例。</li>
<li>protype：每次请求都会创建一个新的bean实例</li>
<li>request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session ：每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。</li>
</ul>
</li>
<li><p>单例bean的线程安全</p>
<p>一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p>常见的两种解决办法：</p>
<ul>
<li>在类中定义threadLocal成员变量。</li>
<li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li>
</ul>
</li>
<li><p>@Compnen和@Bean的区别</p>
</li>
<li><p>将一个类声明为Sprng的bean的注解</p>
<p>一般使用<code>@Autowired</code>注解自动装配bean，想把类标识成可用于autowired自动装配的类，可以使用以下注解：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
</li>
<li><p>bean的生命周期</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><ul>
<li><p>对MVC的理解</p>
<p>是一种设计模式。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg" alt="img"></p>
<ul>
<li>Model1时代JSP</li>
<li>Model2时代Bean（model）+JSP（View）+Servlet（controller）</li>
</ul>
</li>
<li><p>MVC的工作原理</p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
</li>
</ul>
<h3 id="Spring框架中用到的设计模式"><a href="#Spring框架中用到的设计模式" class="headerlink" title="Spring框架中用到的设计模式"></a>Spring框架中用到的设计模式</h3><ul>
<li>工厂模式：创建Bean</li>
<li>代理模式：AOP</li>
<li>单例模式：Bean单例模式</li>
<li>包装器设计模式：Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li>观察者模式：事件驱动</li>
</ul>
<h3 id="Spring管理事务"><a href="#Spring管理事务" class="headerlink" title="Spring管理事务"></a>Spring管理事务</h3><ul>
<li><p>管理事务的方式</p>
<ul>
<li><p>编程式，不推荐。</p>
</li>
<li><p>声明式事务</p>
<ul>
<li>基于XML</li>
<li>基于注解</li>
</ul>
</li>
</ul>
</li>
<li><p>事务的隔离级别</p>
</li>
<li><p>哪几种事务传播行为五种</p>
</li>
<li><p>Transactional(rollback=Exception.class)</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
</li>
</ul>
<h3 id="使用JPA在数据库中非持久化一个字段。"><a href="#使用JPA在数据库中非持久化一个字段。" class="headerlink" title="使用JPA在数据库中非持久化一个字段。"></a>使用JPA在数据库中非持久化一个字段。</h3><p>@Transient</p>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>使用C语言开发的k-v数据库，数据存储在内存，读写速度很快，一般用于缓存方向，也可以用来做分布式锁，消息队列。提供了五中数据类型String,hash,list,set,zset。支持事务，持久化，lua脚本，多重集群方案。</p>
<h2 id="分布式缓存常见的技术选型"><a href="#分布式缓存常见的技术选型" class="headerlink" title="分布式缓存常见的技术选型"></a>分布式缓存常见的技术选型</h2><p>Memcached和Redis。</p>
<p>前者是分布式缓存刚兴起，后来随着Redis发展，都是用redis了。分布式缓存主要解决的问题是，单击缓存的容量收到服务器限制且无法保存通用的消息。因为本地缓存只在当前服务有效。</p>
<h2 id="redis和Memcached的区别和共同点"><a href="#redis和Memcached的区别和共同点" class="headerlink" title="redis和Memcached的区别和共同点"></a>redis和Memcached的区别和共同点</h2><p><strong>共同点：</strong></p>
<ul>
<li>基于内存</li>
<li>过期策略</li>
<li>高性能</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>redis数据类型更丰富-五种，后者只是简单的k-v</li>
<li>redis数据持久化，重启的时候可以再次加载使用。后者单纯放在内存。</li>
<li>redis灾难恢复机制。因为可以持久化</li>
<li>redis在内存用完之后，可以将数据放磁盘，后者直接报异常。</li>
<li>M没有原生的集群模式。redis原生支持cluster模式</li>
<li>M多线程非阻塞IO复用的网络模型；R单线程多路IO复用模型（R6.0之后引入多线程）</li>
<li>R支持发布订阅模型，Lua脚本，事务。M不支持。</li>
<li>M过期数据只用了惰性删除，R使用了惰性删除和定期删除。</li>
</ul>
<h2 id="缓存数据的处理流程"><a href="#缓存数据的处理流程" class="headerlink" title="缓存数据的处理流程"></a>缓存数据的处理流程</h2><ul>
<li>数据在缓存直接返回</li>
<li>不在缓存查数据库</li>
<li>数据库存在更新缓存</li>
<li>数据库不在返回空</li>
</ul>
<h2 id="为什么用R缓存"><a href="#为什么用R缓存" class="headerlink" title="为什么用R缓存"></a>为什么用R缓存</h2><p><strong>高性能：</strong></p>
<p>直接访问数据库会比较慢，因为要从次硬盘读取。对于某些不常改变的高频数据，可以放在缓存中，访问时直接存缓存读取，这样比较快。需要保证数据一致性，当数据库的数据改变时，缓存的数据也要同步更新。</p>
<p><strong>高并发：</strong></p>
<p>MYSQL的QPS在1W左右（4core 8G），使用R之后可以达到10W-30W+。</p>
<blockquote>
<p>QPS：服务器每秒可以执行的查询次数。</p>
</blockquote>
<h2 id="R单线程模型"><a href="#R单线程模型" class="headerlink" title="R单线程模型"></a>R单线程模型</h2><blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，文本事件处理器主要是4个部分：</p>
<ul>
<li>多个socket（客户端连接）</li>
<li>IO多路复用（支持多个客户端连接的关键）</li>
<li>文本事件分派器（将socket关联到相应的时间处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210325164739624.png" alt="image-20210325164739624"></p>
<h2 id="R为什么不使用多线程"><a href="#R为什么不使用多线程" class="headerlink" title="R为什么不使用多线程"></a>R为什么不使用多线程</h2><p>单线程模型，但是在4.0之后就加入了对多线程的支持。但是多线程主要是针对一些大键值对的删除操作的命令。</p>
<p>大体来说R还是单线程处理，为何不使用多线程？</p>
<ul>
<li>单线程编程容易且易维护</li>
<li>性能瓶颈不在CPU，在于内存和网络</li>
<li>多线程存在死锁，线程上下文切换问题，甚至影响性能。</li>
</ul>
<h2 id="为什么6-0引入多线程。"><a href="#为什么6-0引入多线程。" class="headerlink" title="为什么6.0引入多线程。"></a>为什么6.0引入多线程。</h2><p>主要是为了提高网络IO性能瓶颈。</p>
<p>虽然6.0引入多线程，但是只在网路数据的读写这类耗时操作使用，执行命令仍然是单线程。默认是禁用的。</p>
<p>开多线程之后，还需要设置线程数，否则不生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPYio-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span><br></pre></td></tr></table></figure>

<h2 id="缓存数据设置过期时间有啥用"><a href="#缓存数据设置过期时间有啥用" class="headerlink" title="缓存数据设置过期时间有啥用"></a>缓存数据设置过期时间有啥用</h2><p>内存有限。</p>
<p>业务场景需要。(token，短信验证码)</p>
<h2 id="R如何判断数据是否过期呢？"><a href="#R如何判断数据是否过期呢？" class="headerlink" title="R如何判断数据是否过期呢？"></a>R如何判断数据是否过期呢？</h2><p>过期字典来保存过期时间。过期字典的k指向数据库的某个key，保存了数据库键的过期时间（毫秒精度的unix时间戳)</p>
<h2 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h2><ul>
<li>惰性删除：取出key的时候过期检查。CPU友好，但是可能太多过期K没删除</li>
<li>定期删除：每隔一段时间抽取K删除过期K。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
</ul>
<p>一种是内存友好，一种CPU友好，所以R是定期+惰性。</p>
<p>仅仅通过K的过期时间有问题，因为可能存在定期删除和惰性漏掉的问题，这样导致大量过期K堆积在内存。–内存淘汰机制。</p>
<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><ul>
<li>volatile-lru：从已设置过期时间的数据集挑选最少使用的数据淘汰</li>
<li>V-ttl：从已设置过期时间的数据集挑选将要过期的数据淘汰。</li>
<li>V-random：字面意思</li>
<li>allkeys-lru：当内存不足以容纳写入新数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li>a-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-evition：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ul>
<p>4.0版本以后增加了两种：</p>
<ul>
<li>v-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>a-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p><strong>快照和只追加文件</strong></p>
<ul>
<li><p>快照持久化</p>
<p>通过创建快照的方式获得存储在内存里面的数据的某个时间节点的副本。创建快照后可以进行备份，或者复制到其他服务器从而常创建具有相同数据的服务器副本（主从结构）。</p>
<p>快照是默认的持久化方式</p>
</li>
<li><p>AOF持久化</p>
<p>实时性更好，成为主流的方案，默认不开启，通过appendonly yes开启。</p>
<p>开启后，每次执行一条更改Redis的命令，redis就会将命写入AOF文件。默认的文件时appendonly.aof。</p>
<p>在redis存在三种不同的AOF持久化方式，分别是：</p>
<ul>
<li>appendsync always # 每次更细都写AOF</li>
<li>appendsync everysec # 每秒钟同步一次</li>
<li>appendsync no # OS决定什么时候同步</li>
</ul>
<p>兼顾数据和写入性能，选择everysec。对性能几乎没影响。</p>
</li>
</ul>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>通过<code>MULTI</code>,<code>EXEC</code>,<code>DISCARD</code>,<code>WATCH</code>命令实现事务。使用 <a target="_blank" rel="noopener" href="https://redis.io/commands/multi">MULTI</a>命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了<a target="_blank" rel="noopener" href="https://redis.io/commands/exec">EXEC</a>命令将执行所有命令。</p>
<p>R的事务和数据库的事务不太一样，事务四大特性：</p>
<ul>
<li>原子性：动作要么全部完成，要么不起作用。</li>
<li>一致性：事务提交后，数据保持一致，多个事务对同一个数据库读取的结果是相同的。</li>
<li>隔离性：并发访问数据库，一个用户的事务不被打扰，并发事务之间数据库是独立的。</li>
<li>持久性：一个事物提交后，对数据的改变是持久的，及时数据库发生故障也不能有任何影响。</li>
</ul>
<p>Redis不支持回滚，不满足原子性。而且不满足持久性。为啥呢？因为他们认为没必要回滚，这样更简单且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p>R的事务可以理解为：提供了一种将多个命令请求打包的功能，然后再按照顺序执行所有命令，并且不会被中途打断。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li><p>是啥？</p>
<p>大量请求的Key不在缓存，直接到数据库。黑客故意制造缓存中不存在的Key请求，导致大量请求落到数据库。</p>
</li>
<li><p>如何解决？</p>
<p>最基本的是做好参数校验，不合法的参数直接返回客户端，例如ID不小于0，邮箱格式等。</p>
<ul>
<li><p>缓存无效key</p>
<p>缓存和数据库都查不到，就缓存这个无效key，适用于key变化不频繁的情况。会导致缓存大量无效key，可以尽量将key的过期时间设置短一点，例如1min。</p>
</li>
<li><p>布隆过滤器</p>
<p>通过它可以方便的判断一个给定数据是否存在于海量数据中。具体的做法是：把所有可能的请求的值放在过滤器，请求过来，先判断请求的值是否在过滤器，不存在的话，返回参数信息错误。存在的话，再去走缓存的流程。</p>
<p>过滤器时候存在，小概率<strong>误判</strong>；说不存在，一定不存在。</p>
<ul>
<li><p>元素加入过滤器</p>
<p>1.使用过滤器中的哈希函数对元素值计算，得到哈希值。(几个哈希函数得到几个哈希值)</p>
<p>2.根据得到的哈希值，数组中对应的下标标记为1</p>
</li>
<li><p>判断是否存在</p>
<p>1.对给定元素计算哈希值。</p>
<p>2.得到值之后判断数组中的每个元素位置是否都为1，是，说明在过滤器，存在一个值不是1，说明不在。</p>
</li>
</ul>
<p>有一种情况：不同字符串可能哈希出来的位置相同。(哈希冲突,最原始的问题)</p>
</li>
</ul>
</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>就是一个很长的数组，在存入数据的过程中，先通过三次（也可能是更多次）的哈希计算，然后把这些hash的值都标记为1，在查询的时候，先通过三次hash值，然后去查数组，有一个不是1，则数据一定不存在。但是过滤器很难实现删除操作，本质原因是没有解决哈希冲突。</p>
<p>有点是插入和删除很快。保密性好，因为只存0和1.</p>
<p>缺点就是不好删除；容易出现误判，原因是哈希冲突。问题就是如何去计量避免误判呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic class test&#123;</span><br><span class="line">        private static int size &#x3D; 1000000;</span><br><span class="line">        &#x2F;&#x2F;期望的误判率</span><br><span class="line">        private static double fpp &#x3D; 0.01;</span><br><span class="line">        &#x2F;&#x2F;布隆过滤器</span><br><span class="line">        private static BloomFilter&lt;Integer&gt; bloomFilter &#x3D; BloomFilter.create(Funnels.integerFunnel(),size,fpp);</span><br><span class="line">        private static int total &#x3D; 1000000;</span><br><span class="line">        psvm&#123;</span><br><span class="line">            &#x2F;&#x2F;插入10万样本数据</span><br><span class="line">            for(int i &#x3D; 0;i&lt;total;i++)&#123;</span><br><span class="line">                bloomFilter.put(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;用另外十万测试数据，测试误判率</span><br><span class="line">            int count &#x3D; 0;</span><br><span class="line">            for(int i &#x3D; total;i&lt;total+100000;i++)&#123;</span><br><span class="line">                if(bloomFilter.mightContain(i))&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sout(i+&quot;误判了&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sout(&quot;总的误判数是：&quot;+count);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是误判率不能设置成无线小，这会拖慢过滤器的计算速度。</p>
<blockquote>
<p>误判率的底层原理：</p>
<p>给出更多的哈希函数和数组空间，使用多个哈希函数算出来的哈希位置也不一样，多对应的二进制数据也就越多，这样就可以减少重复的概率。</p>
</blockquote>
<p><strong>使用布隆过滤器解决redis缓存穿透的问题：</strong></p>
<p>将数据库的数据全部存放在布隆过滤器上，先查过滤器。没有返回，有的哈，从redis查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic class RedisBloomFilter&#123;</span><br><span class="line">    psvm&#123;</span><br><span class="line">        Config config &#x3D; new Config();</span><br><span class="line">        config.useSingleServer.setSddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;);</span><br><span class="line">        config.useSingleServer().setPassword(&quot;1234&quot;);</span><br><span class="line">        &#x2F;&#x2F;构造过滤器</span><br><span class="line">        RedissonClient redisson &#x3D; Redisson.create(config);</span><br><span class="line">        RBloomFilter&lt;String&gt; bloomFilter &#x3D; redisson.getBloomFilter(&quot;phoneList&quot;);</span><br><span class="line">        &#x2F;&#x2F;初始化过滤器，预计元素是1000000L,误差率是3%</span><br><span class="line">        bloomFilter.tryInit(10000L,0.03);</span><br><span class="line">        &#x2F;&#x2F;将号码10086插入到过滤器</span><br><span class="line">        bloomFilter.put(&quot;10086&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;判断号码是否在过滤器</span><br><span class="line">        sout(bloomFilter.contains(&quot;123456&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存在同一时间大面积失效,后面的请求落在数据库，造成短时间内数据库承受大量请求。（缓存模块宕机）</p>
<p>还有一种是有一些被大量访问的数据在某一时刻失效，导致请求落在数据库。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>缓存服务宕机<ul>
<li>redis集群</li>
<li>限流，避免同时处理大量请求。</li>
</ul>
</li>
<li>热点缓存失效：<ul>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ul>
</li>
</ul>
<h2 id="如何保证缓存和数据库的一致性"><a href="#如何保证缓存和数据库的一致性" class="headerlink" title="如何保证缓存和数据库的一致性"></a>如何保证缓存和数据库的一致性</h2><p><strong>旁路缓存模式</strong></p>
<p>遇到写请求是这样的，更新DB，直接删除缓存。</p>
<p>数据库更新成功缓存删除失败。两个方案：</p>
<ul>
<li>缓存失效时间变短（不推荐）：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li>增加cache更新重试机制（常用）：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><strong>进程与线程</strong></p>
<p><strong>进程状态的切换</strong></p>
<p><strong>进程调度算法</strong></p>
<ul>
<li><p>批处理系统：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">扫盲</a></p>
<p>没有太多用户操作，调度算法的目的是保证吞吐量和周转时间</p>
<ul>
<li>先来先服务FCFS：不利于短作业</li>
<li>短作业优先SJF：长作业可能饿死</li>
<li>最短剩余时间</li>
</ul>
</li>
<li><p>交互式系统</p>
<p>有大量的用户交互操作，调度算法的目标是快速的进行响应。</p>
<ul>
<li><p>时间片轮转</p>
<p>就绪进程FCFS进队，给队首分配时间片，用完之后计时器发出时钟中断，送至队尾，然胡队首分时间片。</p>
<p>效率和时间片大小有关系，时间片太小进程切换频繁，太长则不能保证实时性。</p>
</li>
<li><p>优先级调度</p>
<p>为进程分配优先级，为防止优先级低的进程饿死，可以随着时间推移增加进程的优先级。</p>
</li>
<li><p>多级反馈队列</p>
<p>采用时间片轮转，一个需要100次时间片的线程需要切换100次。在多级队列中，设置多个队列，时间片大小不太能，例如是1,2,4,8，第一个进程没执行完就移入第二个队列，这样只需要交换7次。</p>
</li>
</ul>
</li>
<li><p>实时系统：要求一个请求在确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对时间，后者有一定的容忍时间。</p>
</li>
</ul>
<p><strong>进程同步</strong></p>
<ul>
<li><p>临界区</p>
</li>
<li><p>同步与互斥</p>
</li>
<li><p>信号量：一个整型变量，可以进行down和up操作，也就是P和V操作。</p>
<p><strong>down：</strong>如果信号量大大于0，执行-1操作；等于0，进程睡眠，等待信号量大于0.</p>
<p><strong>up：</strong>信号量执行+1操作，唤醒睡眠的进程完成down操作。</p>
<p>PV操作需要设计成<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43896318/article/details/113378328">原语</a>，通常的做法是在执行操作的时候屏蔽中断。</p>
<p>如果信号量只能取值0和1，就成了互斥量，0表示临界区加锁，1表示临界区解锁。</p>
<p>使用信号量解决生产者-消费者问题：</p>
<p>信号量记录缓冲区物品的数量，empty记录缓冲区空的信号量，full记录缓冲区满的信号量。empty在生产过程使用，不是0的时候可以放入，full在消费过程使用，不是0才可以消费。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="comment">//缓冲区，down是申请锁操作，up是释放锁操作</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>管程：使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
</li>
</ul>
<p><strong>经典同步问题</strong></p>
<ul>
<li>哲学家进餐问题</li>
<li>读者-写者问题</li>
</ul>
<p><strong>进程通信</strong></p>
<p>进程通信是手段，进程同步是目的。</p>
<ul>
<li><p>管道：通过pipe函数创建，fd[0]用于读，fd[1]用于写，具有以下限制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>只支持半双工协议(单向交替传输)</li>
<li>只能在父子进程或兄弟进程中使用</li>
</ul>
</li>
<li><p>FIFO：命名管道，去除了管道只能在父子进程中使用的限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>常用于客户-服务器应用程序中，FIFO作为汇聚点，在客户进程和服务器进程之间传递数据。</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630105001363.png" alt="image-20210630105001363" style="zoom: 67%;" /></li>
<li><p>消息队列：相比于FIFO有以下优点</p>
<ul>
<li>可以独立于读写进程存在，避免了FIFO中同步管道的打开和关闭时可能产生的困难。</li>
<li>避免了FIFO的同步阻塞问题</li>
<li>读进程可以根据消息类型有选择的接收消息，不像FIFO只能默认接收。</li>
</ul>
</li>
<li><p>信号量：为多个进程提供对共享数据的访问。</p>
</li>
<li><p>共享存储：多个进程共享一个给定的存储区，数据不需要在进程之间进行赋值，也是最快的一种IPC。</p>
<p>使用信号量同步对共享存储的访问。</p>
</li>
<li><p>套接字：可以用于不同机器间的进程通信。</p>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>产生条件：</strong></p>
<ul>
<li>互斥：资源任一时刻只能一个线程占用</li>
<li>请求与保持：进程因为资源阻塞，不释放已持有资源</li>
<li>不剥夺：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p><strong>处理方法：</strong></p>
<p>主要有：鸵鸟策略，死锁检测与死锁恢复，死锁预防，死锁避免。</p>
<ul>
<li><p>鸵鸟策略：假装没发生。</p>
</li>
<li><p>检测与恢复：不阻止死锁，而是检测到时，采取措施进行恢复。</p>
<ul>
<li><p>每种类型一个资源的检测：检测有向图是否存在环。</p>
</li>
<li><p>每种类型多个资源的检测：</p>
<p>E是资源总量，A是资源剩余，C是进程拥有，R是进程需要。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630114906686.png" alt="image-20210630114906686"></p>
<p>每个进程开始时都不标记，执行过程可能标记，算法结束时，任何没有被标记的进程都是死锁进程，</p>
<ul>
<li>找到一个没有标记的进程Pi，请求的资源小于等于A</li>
<li>找到了就把C中的i行向量加到A中，标记进程，并转回1</li>
<li>没有这样的进程，算法终止。</li>
</ul>
</li>
</ul>
<p>而恢复主要是：抢占，回滚，杀死进程。</p>
</li>
<li><p>死锁预防</p>
<ul>
<li>破坏互斥条件</li>
<li>破坏占有和等待条件</li>
<li>破坏不可抢占条件</li>
<li>破坏环路等待</li>
</ul>
</li>
<li><p>死锁避免</p>
<ul>
<li><p>安全状态：</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630120412962.png" alt="image-20210630120412962"></p>
<p>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也依然存在某种调度程序能够使得每一个进程运行完毕，则称该状态是安全的的。</p>
</li>
<li><p>单个资源的银行家算法</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630120447059.png" alt="image-20210630120447059"></p>
<p>C不是安全状态，算法会拒绝之前的请求，从而避免进入C</p>
</li>
<li><p>多个资源的银行家算法</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630120733895.png" alt="image-20210630120733895"></p>
<p>E总资源，P已分配资源，A可用资源，是向量而不是数值，算法如下：</p>
<ul>
<li>检查右边的矩阵是否有一行小于A，不存在则死锁，不安全状态</li>
<li>找到则进程标记终止，已分配资源加到A</li>
<li>知道所有进程都标记，则状态安全。</li>
</ul>
<p>如果任何一个状态是不安全的，则拒绝进入这个状态。</p>
</li>
</ul>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>虚拟内存</strong></p>
<p>OS将内存抽象成地址空间，每个程序拥有自己的地址空间，地址空间被分为多个块，每个块称为一个页，页映射到物理内存。当程序引用到不在物理内存中的页时，硬件执行必要的映射，将缺失的部分装入物理内存并重新计算失败的指令。<strong>虚拟内存</strong>允许程序不用将地址空间中的每一页都映射到物理内存，使得运行大程序成为可能。</p>
<p><strong>分页系统地址映射</strong></p>
<p>内存管理单元管理地址空间和物理内存的转换，页表存储着页(地址空间)和页框(物理内存空间)的映射表。一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630153409898.png" alt="image-20210630153409898" style="zoom: 68%;" />

<p>页表存放16个页，需要用4个bit位来索引定位，对于逻辑地址，前4位找到页面号是2，2的内容是1101，最后一位表示是否在内存中，1表示在内存中。后12位存储偏移量。最后得到物理地址。</p>
<p><strong>页面置换算法</strong></p>
<p>虚拟内存的存在，缺页中断将页调入内存的时候，如果内存中没有空闲，必须从内存中调出一个页面到磁盘对换区中腾出空间。页面置换算法的主要目标是使得页面置换频率最低，也就是说缺页率最低。</p>
<ul>
<li><p>最佳(OPT)：最长时间不再被访问，是一种理论算法，因为无法知道一个页面多长时间不再被访问到。</p>
</li>
<li><p>最近最久未使用(LRU)：实现LRU需要维护链表，参考LinkedHashMap。因为每次访问都需要更新链表，所以代价比较高。</p>
</li>
<li><p>最近未使用(NRU)：页面有两个状态位，R与M。页面被访问时设置页面的R=1，页面被修改M=1。R位会定时清0，所以可能有：</p>
<table>
<thead>
<tr>
<th align="center">R</th>
<th align="center">M</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>优先置换出已经被修改的脏页面(0,1)，而不是频繁使用的(1,0)。</p>
</li>
<li><p>先进先出：会将经常访问的页面置换，缺页率高。</p>
</li>
<li><p>第二次机会算法：</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630160729702.png" alt="image-20210630160729702"></p>
<p>为了弥补FIFO的不足，页面访问时设置R位为1，替换的时候，检查最老页面的R位，是0则立刻替换；是1，R清零，放到链表末尾，修改装入时间，然后吃那个链表头开始搜索。</p>
</li>
<li><p>时钟：第二次机会算法需要在链表中移动页面，降低效率。始终使用环形链表将页面连接起来，使用指针指向最老的页面。</p>
</li>
<li><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630161110256.png" alt="image-20210630161110256"></p>
</li>
</ul>
<p><strong>分段</strong></p>
<p>页大小固定，下图是一个编译器在编译过程中建立的多个表，有4个表示动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630161556159.png" alt="image-20210630161556159"></p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。段的长度可以不同，可以动态增长。</p>
<p><strong>段页式</strong></p>
<p>地址空间被划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页，这样既拥有分段系统的共享和保护，也拥有分页系统的虚拟内存的功能。</p>
<p><strong>分段与分页的比较</strong></p>
<ul>
<li>分页透明，分段需要coder显式划分</li>
<li>分页是一维地址空间，分段是二维</li>
<li>页大小不变，段大小可以动态变化</li>
<li>分页主要用于实现虚拟存储；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p><strong>磁盘结构</strong></p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630162721693.png" alt="image-20210630162721693"></p>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<p><strong>磁盘调度算法</strong></p>
<p>读写一个磁盘块的时间的影响因素有：旋转时间(主轴转动盘面，使得磁头移动到适当的扇区)；寻道时间(制动手臂移动，使得磁头移动到适当的磁道)；实际的数据传输时间。其中寻道时间最长，调度的主要目标就是使得平均寻道时间最短。</p>
<ul>
<li>先来先服务：公平但平均寻道时间可能长。</li>
<li>最短寻道时间：优先调度与当前磁头所在磁道最近的磁道，两端的磁道请求更容器出现饥饿现象。</li>
<li>电梯算法：朝着一个方向调度，知道该方向没有未完成的磁盘请求，然后改变方向，解决了饥饿问题。</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>编译系统</strong></p>
<p><code>gcc -o hello hello.c</code>的过程大致如下：</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630164718917.png" alt="image-20210630164718917" style="zoom: 67%;" />

<ul>
<li>预处理阶段：处理以#开头的预处理命令</li>
<li>编译阶段：翻译成汇编文件</li>
<li>汇编阶段：将汇编文件编译成可重定位目标文件</li>
<li>链接阶段：将可重定位目标文件和printf.o等单独编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<p><strong>静态链接</strong></p>
<p>以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。连接器主要完成以下工作：</p>
<ul>
<li>符号解析：每个符号对应一个函数、全局变量或者静态变量，目的是把每个符号引用与一个符号定义关联起来。</li>
<li>重定位：连接器通过每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得他们指向这个内存位置。</li>
</ul>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630165915208.png" alt="image-20210630165915208" style="zoom: 67%;" />

<p><strong>目标文件</strong></p>
<ul>
<li>可执行目标文件：可以直接在内存中运行。</li>
<li>可重定位目标文件：可与其他可重定位目标文件在连接阶段合并，创建一个可执行文件(好家伙，递归定义)</li>
<li>共享目标文件：特殊的可重定位目标文件，可以在运行时被动态加载到内存并链接。</li>
</ul>
<p><strong>动态链接</strong></p>
<p>静态库有以下两个问题：</p>
<ul>
<li>静态库更新时，整个程序都要重新进行链接</li>
<li>对于printf这种标准函数库，如果每个程序都要有代码，会造成浪费。</li>
</ul>
<p>共享库解决这个问题，在linux中用<code>.so</code>后缀表示，windows称为DLL。有以下特点：</p>
<ul>
<li><p>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，不会被复制到引用他的可执行文件中。</p>
</li>
<li><p>在内存中，一个共享库.text节(已编译程序的机器码)的一个副本可以被不同的正在运行的进程共享。</p>
<img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210630170757139.png" alt="image-20210630170757139" style="zoom: 67%;" /></li>
</ul>
<h1 id="tidb"><a href="#tidb" class="headerlink" title="tidb"></a>tidb</h1><p>接下来来谈谈这个contribute–<strong>表达式向量化</strong></p>
<p>TIDB为了鼓励参与，在很简单的向量化这里留下了很多口子，对于小白来说非常友好。</p>
<h2 id="如何访问和修改向量"><a href="#如何访问和修改向量" class="headerlink" title="如何访问和修改向量"></a>如何访问和修改向量</h2><p>在TIDB中有变长类型和定长类型，有如下读写方式：</p>
<ul>
<li>定长类型(int64为例)<ul>
<li><code>ResizeInt64s(size, isNull)</code>：预分配 size 个元素的空间，并把所有位置的 <code>null</code> 标记都设置为 <code>isNull</code>；</li>
<li><code>Int64s()</code>：返回一个 <code>[]int64</code> 的 Slice，用于直接读写数据；</li>
<li><code>SetNull(rowID, isNull)</code>：标记第 <code>rowID</code> 行为 <code>isNull</code>。</li>
</ul>
</li>
<li>变长类型(String为例)<ul>
<li><code>ReserveString(size)</code>：预估 size 个元素的空间，并预先分配内存；</li>
<li><code>AppendNull()</code>：追加一个 <code>null</code> 到向量末尾；</li>
<li><code>GetString(rowID)</code>：读取下标为 <code>rowID</code> 的 string 数据。</li>
</ul>
</li>
</ul>
<h2 id="向量表达式计算框架"><a href="#向量表达式计算框架" class="headerlink" title="向量表达式计算框架"></a>向量表达式计算框架</h2><p>向量化的计算接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPYvectorized() bool</span><br><span class="line">vecEvalXType(input *Chunk, result *Column) error</span><br></pre></td></tr></table></figure>

<ul>
<li>xType：类型</li>
<li>input：输入数据，类型为<code>\*Chunk</code></li>
<li><code>result</code>存放结果数据。</li>
</ul>
<p>对于任意表达式，只有在其中所有的函数都支持向量化后，才认为表达式支持向量化。</p>
<h2 id="为函数实现向量化接口"><a href="#为函数实现向量化接口" class="headerlink" title="为函数实现向量化接口"></a>为函数实现向量化接口</h2><p>向量化需要实现<code>vecEvalXType()</code>和<code>vectorized</code>接口</p>
<ul>
<li>在 <code>vectorized()</code> 接口中返回 <code>true</code> ，表示该函数已经实现向量化计算；</li>
<li>在 <code>vecEvalXType()</code> 实现此函数的计算逻辑。</li>
</ul>
<p>向量化的代码存放在_vec.go中，文件头加上licence说明。</p>
<p>以下是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">COPYfunc (b *builtinMicroSecondSig) vectorized() bool &#123;</span><br><span class="line">	return false</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *builtinMicroSecondSig) vecEvalInt(input *chunk.Chunk, result *chunk.Column) error &#123;</span><br><span class="line">	return errors.Errorf(&quot;not implemented&quot;)</span><br><span class="line">	n :&#x3D; input.NumRows()</span><br><span class="line">	buf, err :&#x3D; b.bufAllocator.get(types.ETDuration, n)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	defer b.bufAllocator.put(buf)</span><br><span class="line">	if err &#x3D; b.args[0].VecEvalDuration(b.ctx, input, buf); err !&#x3D; nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result.ResizeInt64(n, false)</span><br><span class="line">	result.MergeNulls(buf)</span><br><span class="line">	i64s :&#x3D; result.Int64s()</span><br><span class="line">	ds :&#x3D; buf.GoDurations()</span><br><span class="line">	for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">		if result.IsNull(i) &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		i64s[i] &#x3D; int64((ds[i] % time.Second) &#x2F; time.Microsecond)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://victor-huihui.gitee.io/2019/08/23/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/03/01/%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            基础记录
          
        </div>
      </a>
    
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "zUWoNtJddoKIUUWCugVrSkqY-gzGzoHsz",
    app_key: "yegbJ1Yoz3JfCVfJUSQloPqX",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Victor
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="http://www.beian.miit.gov.cn/" target="_black" rel="nofollow">皖ICP备20004655号-1</a>
        </li>
        
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Victor&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://victor13881.lofter.com/">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>