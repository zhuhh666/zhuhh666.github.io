<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CORS如何解决</title>
    <url>/2020/03/19/CORS%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>前端开发经常会遇到跨域问题。比如当前请求1baidu.com，如果想要从1请求2taobao.com的资源就会出现跨域的资源共享问题。不跨域就是我们就是请求1下的资源，不请求2的资源，就不是跨域问题：<img src="https://i.loli.net/2020/03/19/bj14tEa78Nmi6eT.png" alt="微信截图_20200319112724.png"></p>
<p>在开发环境中经常会遇到这样的问题，接口在一台服务器或者一个端口上，而页面服务在另一个服务器或者端口，这样从前端获得接口的数据就会出现跨域的问题，那么如何解决跨域的问题？以下两种方案:</p>
<p>先写一个服务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = required(<span class="string">&#x27;expresss&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//90端口服务，将当前目录当成http服务，默认加载index.html</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(express.static(_dirname))</span><br><span class="line">app.listen(<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//91端口服务，返回数据</span></span><br><span class="line"><span class="keyword">var</span> app2 = express();</span><br><span class="line">app2.get(<span class="string">&quot;/&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">         res.send(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">         &#125;)</span><br><span class="line">qpp2.listen(<span class="number">91</span>)</span><br></pre></td></tr></table></figure>

<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        hello!!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        	fetch(<span class="string">&quot;http://localhost:91/&quot;</span>)</span></span><br><span class="line"><span class="javascript">                .then(<span class="function"><span class="params">res</span>=&gt;</span>res.txt())</span></span><br><span class="line"><span class="javascript">                .then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;alert(data)&#125;)</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里接口不一致出现首图所示跨域问题</p>
<ul>
<li><p>修改相应头</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var express = required(&#x27;expresss&#x27;);</span><br><span class="line"></span><br><span class="line">//90端口服务，将当前目录当成http服务，默认加载index.html</span><br><span class="line">var app = express();</span><br><span class="line">app.use(express.static(_dirname))</span><br><span class="line">app.listen(90)</span><br><span class="line"></span><br><span class="line">//91端口服务，返回数据</span><br><span class="line">var app2 = express();</span><br><span class="line">app2.get(&quot;/&quot;,function(req,res)&#123;</span><br><span class="line">		 res.header(&quot;Access-Contorl-Allow-Origin&quot;,&quot;*&quot;)</span><br><span class="line">         res.send(&quot;你好&quot;)</span><br><span class="line">         &#125;)</span><br><span class="line">qpp2.listen(91)</span><br></pre></td></tr></table></figure></li>
<li><p>jsonp</p>
<p>服务：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var express = required(&#x27;expresss&#x27;);</span><br><span class="line"></span><br><span class="line">//90端口服务，将当前目录当成http服务，默认加载index.html</span><br><span class="line">var app = express();</span><br><span class="line">app.use(express.static(_dirname))</span><br><span class="line">app.listen(90)</span><br><span class="line"></span><br><span class="line">//91端口服务，返回数据</span><br><span class="line">var app2 = express();</span><br><span class="line">app2.get(&quot;/&quot;,function(req,res)&#123;</span><br><span class="line">		 var funcname = req.query.callback;</span><br><span class="line">		 res.send(funcname+)</span><br><span class="line">         res.send(funcname+&quot;(&#x27;你好&#x27;)&quot;)</span><br><span class="line">		 //f(&quot;你好&quot;)</span><br><span class="line">         &#125;)</span><br><span class="line">qpp2.listen(91)</span><br></pre></td></tr></table></figure>

<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        hello!!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line">                alert(data)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:91?callback=f&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>、、、、、、</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Frp内网穿透</title>
    <url>/2020/04/07/Frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>疫情在家太久了，经常需要用服务器资源做一些事情，部署项目啊，跑作业啊。今天就用有公网Ip的服务器实现frp内网穿透。</p>
<p>内网穿透说白了就是，我们实验室分配了一台服务器资源，但是是内网环境，外网访问不到。我们想在本地环境访问内网服务器，就要做内网穿透才可以。当然连vpn也可以访问，但是每次连vpn不仅麻烦，而且挂着vpn会影响看片的速度。那么内网穿透实现的原理是怎样的？看图：<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407214912.png" alt="image-20200407214903850"></p>
<p>就是借助具有公网IP的服务器当做跳板来访问内网服务器。所以了，前提是你要有一台具有公网IP的服务器，或者你的宽带有公网IP，这就得咨询运营商了(一般不可能主动提供的)。</p>
<h2 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h2><p><a href="https://github.com/fatedier/frp/releases">官网点这</a></p>
<p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。首先要下载frp到你的内网服务器和公网代理机上，进去选择相应的版本。我这里是amd架构。</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407215351.png" alt="image-20200407215349375"></p>
<p>解压后进入文件夹，可以看到这些文件，这里注意一下，我们在<strong>内网服务器用的都是frpc，在公网代理机用的是frps。</strong>或者你直接记住，frps就是代理机，frpc就是内网服务器。</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407215602.png" alt="image-20200407215600600"></p>
<h3 id="Frps"><a href="#Frps" class="headerlink" title="Frps"></a>Frps</h3><p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407220003.png" alt="image-20200407220002335"></p>
<p>可以看到代理机的配置非常少，只要配置一个端口就行，我这里是8881端口，如果你的8881端口有服务，换成别的端口就行。</p>
<h3 id="Frpc"><a href="#Frpc" class="headerlink" title="Frpc"></a>Frpc</h3><p>现在打开内网服务器，进入frp的目录，看一下frpc的配置有哪些：</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407220235.png" alt="image-20200407220234019"></p>
<ul>
<li>server_addr：这个就是跳转机的公网IP</li>
<li>server_port：服务端口</li>
<li>ssh的配置不用管，但是这个6000端口是我们要用的。</li>
</ul>
<h2 id="启动frp，访问测试"><a href="#启动frp，访问测试" class="headerlink" title="启动frp，访问测试"></a>启动frp，访问测试</h2><p><strong>启动跳转机frp(在frp目录下)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407221648.png" alt="image-20200407221646951"></p>
<p><strong>启动内网服务器frp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407221754.png" alt="image-20200407221752608"></p>
<p>再回头看注册机也已经发生了变化，代理成功：</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407221855.png" alt="image-20200407221854764"></p>
<p><strong>测试访问</strong></p>
<p>直接通过xshell新建一个连接，主机写公网IP，端口写6000，发现已经通过公网IP连接上来了。</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200407222400.png" alt="image-20200407222359320"></p>
<h2 id="配置访问gitlab"><a href="#配置访问gitlab" class="headerlink" title="配置访问gitlab"></a>配置访问gitlab</h2><p>再接下来的配置都是一个思路了，我们上边是配置了一个ssh。配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ssh]</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000</span><br></pre></td></tr></table></figure>

<p>因为ssh的默认端口是22端口，这个配置就是把22端口代理到远程的6000端口。</p>
<p>现在查看gitlab的端口是8072，我们代理到1235端口，在froc,ini添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[gitlab]</span><br><span class="line">local_ip&#x3D;127.0.0.1</span><br><span class="line">local_port&#x3D;8072</span><br><span class="line">remote_port&#x3D;1235</span><br></pre></td></tr></table></figure>

<p>然后重启frp，访问公网IP：1235发现gitlab已经打开了。</p>
<p>别的端口代理也是一个道理，直接去frpc.ini添加相应配置就行了</p>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><ul>
<li><p><strong>connection time-out</strong></p>
<p>看看端口有没有放行，阿里云要去控制台放行才会生效。</p>
<p>关闭防火墙。</p>
</li>
<li><p>我们这种方式启动占据了命令窗口，可以后台驻留启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">服务端： nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">客户端： nohup ./frpc -c frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">说明：&gt;/dev/null 2&gt;&amp;1 &amp;，表示丢弃。</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitee-Pages 自定义域名</title>
    <url>/2020/04/21/Gitee-Pages-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h2 id="Bug来源"><a href="#Bug来源" class="headerlink" title="Bug来源"></a>Bug来源</h2><p>利用hexo写博客，把代码托管到gitee上。但是gitee的Gitee-Pages服务是不支持自定义域名的，需要买会员才可以，一年99块。这99块去阿里云买个学生机不香吗？之前领取了一个月的会员，今天过期了，所以自定义的域名也就没办法访问了。</p>
<h2 id="Bug解决"><a href="#Bug解决" class="headerlink" title="Bug解决"></a>Bug解决</h2><p>又不想买会员，又想自定义域名怎么办呢？</p>
<p>简单，如果你手里有服务器的话，把原来解析的指向gitee的域名重新指向公网IP，然后建个站做反向代理就行了。好吧，今天有点水。。。。。<img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200421233538.png" alt="微信截图_20200421233344"></p>
]]></content>
      <categories>
        <category>Bug合集</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git版本回退</title>
    <url>/2020/03/20/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
    <content><![CDATA[<p>git冲突是再正常不过的了，在某些情况下，我们不得不进行版本回退，以解决代码冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看历史库</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">//本地回滚</span><br><span class="line">git reset --hard 版本号</span><br><span class="line">//仓库回滚</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>但是切记，这种情况下要进行代码的本地备份，因为回滚之后会冲掉你之前的代码。</p>
<p>我有认真的思考过git的协作方式，在没查谷歌的情况下我是这么认为的，如果两个协作者使用git上传代码，个人写个人的模块，代码没有交集，这样就不会造成冲突。而当两个人的代码有交集时，可能出现两个人同时修改一个代码的情况，这时git就报了冲突，解决的方式就是，如果对方已经向仓库提交了改动代码，我们的代码还在本地，在确认对方代码无误的情况下，可以手动把我们本地的代码修改成对方的代码，然后再进行push操作。所以当我们在pull代码的时候，如果代码不冲突，直接修改成对方的代码，这时候的pull操作是不会影响你的本地代码的，毕竟，没冲突，也就没交集。</p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Read a Paper</title>
    <url>/2020/04/20/How-to-Read-a-Paper/</url>
    <content><![CDATA[<blockquote>
<p>过去的几个月，因为不熟悉和不适应，项目占据了绝大多数的时间，甚至有些很好的课程也落下了。昨天蒲总和我们兄弟仨开了个很长的会，大概是12个月要准备开题了(我们的毕业要求是首先Paper要发一篇，然后才是毕业论文)。Paper的阅读真的要提上日程了。之前读的论文都是拿来应付课程了，先来借鉴别人的阅读方法。</p>
</blockquote>
<p><a href="https://paper-reading.oss-cn-zhangjiakou.aliyuncs.com/paper01.pdf">原文下载</a></p>
<h2 id="三遍法读Paper"><a href="#三遍法读Paper" class="headerlink" title="三遍法读Paper"></a>三遍法读Paper</h2><p>主要观点是文章读三遍，第一遍：<code>gives you a general idea about the paper</code>。第二遍：<code>lets you grasp the paper’s content</code>。第三遍：<code>helps you understand the paper in depth.</code></p>
<h2 id="The-first-pass-5-10分钟"><a href="#The-first-pass-5-10分钟" class="headerlink" title="The first pass(5-10分钟)"></a>The first pass(5-10分钟)</h2><p><strong>阅读步骤：</strong></p>
<ul>
<li>认真的读题目、摘要和介绍</li>
<li>阅读小节和小节标题</li>
<li>阅读总结</li>
<li>浏览参考文献，看有没有阅读过的文献</li>
</ul>
<p><strong>读后5C：</strong></p>
<ul>
<li><code>Category</code>：知道Paper的类型，是测量？现有系统的分析还是原型研究？</li>
<li><code>Context</code>：与哪些paper相关，理论基础是？</li>
<li><code>Correctness</code>：假设的正确性？</li>
<li><code>Contributions</code>：主要贡献？</li>
<li><code>Clarity</code>：写得好吗？？？</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>第一遍要知道是否要接着阅读这篇文章，可能是不吸引你或者假设不正确</li>
<li>自己写paper，大小标题要写清楚，简洁而全面。审稿人<code>阅读一次</code>不理解要点，凉凉。读者<code>五分钟</code>不理解亮点，失败。</li>
</ul>
<h2 id="The-second-pass-一小时"><a href="#The-second-pass-一小时" class="headerlink" title="The second pass(一小时)"></a>The second pass(一小时)</h2><p>第二遍更加仔细的阅读文章，忽略诸如证据之类的细节，草草记下要点，在空白处发表评论。</p>
<p><strong>阅读步骤：</strong></p>
<ul>
<li>仔细看数字，图标和插图，特别关注插图表的标签是否正确，结果是否有误差条显示。没有的可以，有问题的话，一般是粗制滥造的paper，不读也罢。</li>
<li>标记相关未读参考文献(了解论文背景的好方法)</li>
</ul>
<p><strong>读后：</strong></p>
<ul>
<li>掌握论文内容</li>
<li>向别人分享论文主旨，提供佐证</li>
<li>这种程度适用于你感兴趣但和你研究领域无关的论文</li>
</ul>
<p><strong>总结：</strong></p>
<p>可能你在第二遍结束后并不了解这篇文章，这也很正常。可能因为是新领域，使用不熟悉的术语和缩略语，或者这篇文章写的很烂，也可能是因为夜太深。。。这种情况你可以选择：</p>
<ul>
<li>劳资不读了。用阿Q精神安慰自己，这些晦涩的术语对你的科研生涯没有用。</li>
<li>稍后读。可以先看看背景资料。</li>
<li>坚持下去，third pass来咯。</li>
</ul>
<h2 id="The-third-pass-4-5小时"><a href="#The-third-pass-4-5小时" class="headerlink" title="The third pass(4-5小时)"></a>The third pass(4-5小时)</h2><blockquote>
<p>新手4-5小时，老油条1小时就够了</p>
</blockquote>
<p>第三遍才是重头戏。关键是<strong>尝试虚拟的重新实施这篇文章的内容</strong>。和作者做一样的假设，重新开始做论文中的工作。通过这种重新创作与实际论文比较，可以和容易发现文章的闪光点，还可以发现其中隐藏的缺陷和假设(发现了，一篇新的论文不就来了吗)</p>
<p><strong>阅读步骤：</strong></p>
<ul>
<li>找出并对每一个假设提出质疑</li>
<li>考虑你自己如何提出一个特定的假设。</li>
<li>写下对未来工作的想法。</li>
</ul>
<p><strong>读后：</strong></p>
<ul>
<li>根据记忆重建论文的结构</li>
<li>识别出亮点和不足</li>
<li><strong>指出隐藏的假设、相关工作引用的遗漏，实验和分析的潜在问题</strong></li>
</ul>
]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>小知识集锦-1</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现Word转html预览</title>
    <url>/2020/04/04/Java%E5%AE%9E%E7%8E%B0Word%E8%BD%AChtml%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<p>项目需求，把doc和docx类型转换成html放在富文本预览，从前端传过来multipartfile类型，后端转换成html字符串返回给前端。</p>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-scratchpad<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>fr.opensagres.xdocreport<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xdocreport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml-schemas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ooxml-schemas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interest.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hwpf.HWPFDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hwpf.converter.WordToHtmlConverter;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.converter.xhtml.XHTMLConverter;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFDocument;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.OutputKeys;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Transformer;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.TransformerException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.TransformerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.dom.DOMSource;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.stream.StreamResult;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * docx文件带格式转换成html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hhzhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Created on 2020/4/1 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word2HtmlUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Word2007ToHtml</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//File file01 = new File();</span></span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty() || file.getSize() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//log.info(&quot;Sorry File does not Exists!&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.getOriginalFilename().endsWith(<span class="string">&quot;.docx&quot;</span>) || file.getOriginalFilename().endsWith(<span class="string">&quot;.DOCX&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1) 加载word文档生成 XWPFDocument对象</span></span><br><span class="line">                InputStream in = file.getInputStream();</span><br><span class="line">                XWPFDocument document = <span class="keyword">new</span> XWPFDocument(in);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 也可以使用字符数组流获取解析的内容</span></span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                XHTMLConverter.getInstance().convert(document, baos, <span class="keyword">null</span>);</span><br><span class="line">                String content = baos.toString();</span><br><span class="line">                baos.close();</span><br><span class="line">                content.replaceAll(<span class="string">&quot;\r\n&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> content;</span><br><span class="line">                <span class="comment">//return baos;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//log.info(&quot;Enter only MS Office 2007+ files&quot;);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Word2003ToHtml</span><span class="params">(MultipartFile file)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ParserConfigurationException, TransformerException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty() || file.getSize() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//log.info(&quot;Sorry File does not Exists!&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.getOriginalFilename().endsWith(<span class="string">&quot;.doc&quot;</span>) || file.getOriginalFilename().endsWith(<span class="string">&quot;.DOC&quot;</span>)) &#123;</span><br><span class="line">                InputStream input = file.getInputStream();</span><br><span class="line">                HWPFDocument wordDocument = <span class="keyword">new</span> HWPFDocument(input);</span><br><span class="line">                WordToHtmlConverter wordToHtmlConverter = <span class="keyword">new</span> WordToHtmlConverter(</span><br><span class="line">                        DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument());</span><br><span class="line">                <span class="comment">// 解析word文档</span></span><br><span class="line">                wordToHtmlConverter.processDocument(wordDocument);</span><br><span class="line">                Document htmlDocument = wordToHtmlConverter.getDocument();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 也可以使用字符数组流获取解析的内容</span></span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                DOMSource domSource = <span class="keyword">new</span> DOMSource(htmlDocument);</span><br><span class="line">                StreamResult streamResult = <span class="keyword">new</span> StreamResult(baos);</span><br><span class="line"></span><br><span class="line">                TransformerFactory factory = TransformerFactory.newInstance();</span><br><span class="line">                Transformer serializer = factory.newTransformer();</span><br><span class="line">                serializer.setOutputProperty(OutputKeys.ENCODING, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                serializer.setOutputProperty(OutputKeys.INDENT, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">                serializer.setOutputProperty(OutputKeys.METHOD, <span class="string">&quot;html&quot;</span>);</span><br><span class="line">                serializer.transform(domSource, streamResult);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 也可以使用字符数组流获取解析的内容</span></span><br><span class="line">                String content = <span class="keyword">new</span> String(baos.toByteArray());</span><br><span class="line">                baos.close();</span><br><span class="line">                <span class="comment">//去除\r\n</span></span><br><span class="line">                content = content.replaceAll(<span class="string">&quot;\r\n&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> content;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//log.info(&quot;Enter only MS Office 2003 files&quot;);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xls2html接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String ok</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParserConfigurationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TransformerException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">chart2html</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException, ParserConfigurationException, TransformerException </span>&#123;</span><br><span class="line">        InputStream input = file.getInputStream();</span><br><span class="line">        HSSFWorkbook excelBook = <span class="keyword">new</span> HSSFWorkbook(input);</span><br><span class="line">        ExcelToHtmlConverter excelToHtmlConverter = <span class="keyword">new</span> ExcelToHtmlConverter(</span><br><span class="line">                DocumentBuilderFactory</span><br><span class="line">                .newInstance()</span><br><span class="line">                .newDocumentBuilder()</span><br><span class="line">                .newDocument());</span><br><span class="line">        excelToHtmlConverter.processWorkbook(excelBook);</span><br><span class="line"></span><br><span class="line">        Document htmlDocument = excelToHtmlConverter.getDocument();</span><br><span class="line">        ByteArrayOutputStream outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DOMSource domSource = <span class="keyword">new</span> DOMSource(htmlDocument);</span><br><span class="line">        StreamResult streamResult = <span class="keyword">new</span> StreamResult(outStream);</span><br><span class="line">        TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">        Transformer serializer = tf.newTransformer();</span><br><span class="line">        serializer.setOutputProperty(OutputKeys.ENCODING, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        serializer.setOutputProperty(OutputKeys.INDENT, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        serializer.setOutputProperty(OutputKeys.METHOD, <span class="string">&quot;html&quot;</span>);</span><br><span class="line">        serializer.transform(domSource, streamResult);</span><br><span class="line">        outStream.close();</span><br><span class="line"></span><br><span class="line">        String content = <span class="keyword">new</span> String(outStream.toByteArray());</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;doc文件转换成html返回&quot;)</span></span><br><span class="line">	<span class="meta">@PostMapping</span> (<span class="string">&quot;/public/getFile&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ResponseWrapper&lt;String&gt; <span class="title">getFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(file.getOriginalFilename().endsWith(<span class="string">&quot;.doc&quot;</span>)||file.getOriginalFilename().endsWith(<span class="string">&quot;.DOC&quot;</span>))&#123;</span><br><span class="line">			result = Word2HtmlUtil.Word2003ToHtml(file);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.getOriginalFilename().endsWith(<span class="string">&quot;.docx&quot;</span>)||file.getOriginalFilename().endsWith(<span class="string">&quot;.DOCX&quot;</span>))&#123;</span><br><span class="line">			result =Word2HtmlUtil.Word2007ToHtml(file);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.getOriginalFilename().endsWith(<span class="string">&quot;.xls&quot;</span>))&#123;</span><br><span class="line">            result = word2HtmlUtil.chartToHtml(file);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseWrapper(<span class="string">&quot;不支持的文档类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseWrapper(result);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200404082544.png" alt="image-20200404082536271"></p>
<p>在项目开发的过程中，提取工具类的思维一是可以实现代码的复用，二是可以让代码的逻辑更加清晰。所以要有提取工具类的常规思维。</p>
<p>这里在转换的时候，\r\n会识别成原生的字符，暴力去掉就行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content = content.replaceAll(<span class="string">&quot;\r\n&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的IO流</title>
    <url>/2020/03/09/Java%E7%9A%84IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="1、汇总"><a href="#1、汇总" class="headerlink" title="1、汇总"></a>1、汇总</h1><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul>
<li>Reader<ul>
<li>BufferReader</li>
<li>InputStreamReader-&gt;FileReader</li>
<li>StringReader</li>
<li>PipeReader</li>
<li>ByteArrayReader</li>
<li>FilterReader-&gt;PushbackReader</li>
</ul>
</li>
<li>Writer<ul>
<li>BufferedWriter</li>
<li>OutputStreamWriter-&gt;FileWriiter</li>
<li>PrinterWriter</li>
<li>StringWriter</li>
<li>PiperWriter</li>
<li>CharArrayWriter</li>
<li>FilterWriter</li>
</ul>
</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><ul>
<li>InputStream<ul>
<li>FileInputStream</li>
<li>FilterInputStream<ul>
<li>BufferedInputStream</li>
<li>DataInputStream</li>
<li>PushbakInputStream</li>
</ul>
</li>
<li>ObjectInputStream</li>
<li>PipedInputStream</li>
<li>SequenceInputStream</li>
<li>StringBuffereInputStream</li>
<li>ByteArrayInputStraam</li>
</ul>
</li>
<li>OutputStream<ul>
<li>FileOutputStream</li>
<li>FilterOutputStream<ul>
<li>BufferedOutputStream</li>
<li>DataOutputStream</li>
<li>PrintStream</li>
</ul>
</li>
<li>ObjectOutputStream</li>
<li>PipedOutputStream</li>
<li>ByteArrayOutputStream</li>
</ul>
</li>
</ul>
<h1 id="2、流"><a href="#2、流" class="headerlink" title="2、流"></a>2、流</h1><blockquote>
<p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
</blockquote>
<p><strong>IO流的分类：</strong></p>
<ul>
<li>根据处理数据类型的不同：字符流和字节流</li>
<li>流向不同：输入流和输出流</li>
</ul>
<p><strong>字符流和字节流的区别是：</strong></p>
<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（图片，avi等），字符流只能处理字符类型的数据。</li>
<li>字节流：一次读入出8位二进制</li>
<li>字符流：16位二进制</li>
</ul>
<p>——&gt;纯文本有限字符流，除此之外使用字节流</p>
<p><strong>输入字节流InputStream：</strong></p>
<ul>
<li><code>InputStream</code>：所有的输入字节流的父类，是一个抽象类</li>
<li><code>ByteArrayInputStream</code>、<code>StringBufferInputStream</code>、<code>FileInputStream</code>是种基本的介质流，他们分别从Byte数组、StringBuffer、和本地文件中读取数据</li>
<li><code>PipedInputStream</code>是从其他线程公用的管道中读取数据</li>
<li><code>ObjectInputStream</code>和所有的<code>FilterInputStream</code>的子类都是装饰流</li>
</ul>
<p><strong>输出字节流OutputStream</strong>：</p>
<ul>
<li><code>OutputStream</code> 是所有的输出字节流的父类，它是一个抽象类。</li>
<li><code>ByteArrayOutputStream</code>、<code>FileOutputStream</code> 是两种基本的介质流，它们分别向<code>Byte 数组</code>、和<code>本地文件</code>中写入数据。</li>
<li><code>PipedOutputStream</code> 是向与其它线程共用的管道中写入数据。</li>
<li><code>ObjectOutputStream</code> 和所有<code>FilterOutputStream</code> 的子类都是装饰流。</li>
</ul>
<p><strong>节点流：</strong>直接与数据源相连，读入或读出</p>
<p>直接使用节点流，读写不方便，为了更快读写文件，才有了处理流</p>
<ul>
<li><p>常用的字节流：</p>
<ul>
<li>父类：<code>InputStream</code>、<code> OutputStream</code>、 <code>Reader</code>、 <code>Writer</code></li>
<li>文件：<code>FileInputStream</code> 、 <code>FileOutputStrean</code> 、<code>FileReader</code> 、<code>FileWriter</code> 文件进行处理的节点流</li>
<li>数组：数　组 ：<code>ByteArrayInputStream</code>、 <code>ByteArrayOutputStream</code>、 <code>CharArrayReader</code> 、<code>CharArrayWriter</code> 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）</li>
<li>字符串 ：<code>StringReader</code>、 <code>StringWriter</code> 对字符串进行处理的节点流</li>
<li>管　道 ：<code>PipedInputStream</code> 、<code>PipedOutputStream</code> 、<code>PipedReader</code> 、<code>PipedWriter</code> 对管道进行处理的节点流</li>
</ul>
</li>
<li><p><strong>处理流：</strong>处理流和节点流一块使用，在节点流的基础上，在套接一层，套接的就是处理流。如BufferedReader，处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，成为<strong>流的链接</strong></p>
</li>
<li><p>常用的处理流：</p>
<ul>
<li><p>缓冲流：<code>BufferedInputStrean</code> 、<code>BufferedOutputStream</code>、 <code>BufferedReader</code>、 <code>BufferedWriter</code> 增加缓冲功能，避免频繁读写硬盘。</p>
</li>
<li><p>转化流：<code>InputStreamReader</code> 、<code>OutputStreamReader</code>实现字节流和字符流之间的转换。</p>
<ul>
<li><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader(InputStream);        <span class="comment">//通过构造函数初始化，使用的是本系统默认的编码表GBK。</span></span><br><span class="line">InputStreamReader(InputStream,String charSet);   <span class="comment">//通过该构造函数初始化，可以指定编码表。</span></span><br><span class="line">OutputStreamWriter(OutputStream);      <span class="comment">//通过该构造函数初始化，使用的是本系统默认的编码表GBK。</span></span><br><span class="line">OutputStreamwriter(OutputStream,String charSet);   <span class="comment">//通过该构造函数初始化，可以指定编码表。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数据流：<code>DataInputStream</code>、<code>DataOuputStream</code>等提供将基础数据类型写入文件中，或者读取出来。</p>
</li>
</ul>
</li>
</ul>
<h1 id="3、实战操作"><a href="#3、实战操作" class="headerlink" title="3、实战操作"></a>3、实战操作</h1><ul>
<li><p>FileInputStream类的使用：读取文件内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[],args)</span></span>&#123;</span><br><span class="line">        A1 a1 = <span class="keyword">new</span> A1();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//电脑d盘中的abc.txt文档</span></span><br><span class="line">        String filePath = <span class="string">&quot;D:/abc.txt&quot;</span>;</span><br><span class="line">        String result = a1.readFile(filePath);</span><br><span class="line">        syso(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取指定文件的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//根据相同的路径实例化一个输入流对象</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">            <span class="comment">//返回这个输入流中可以被读的剩下的byte字节的估计值</span></span><br><span class="line">            <span class="keyword">int</span> size = fis.available();</span><br><span class="line">            <span class="comment">//根据输入流中的字节数创建byte数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">            <span class="comment">//数据读到数组中</span></span><br><span class="line">            fis.read(array);</span><br><span class="line">            <span class="comment">//根据获得的byte新建一个字符串，然后输出</span></span><br><span class="line">            result = <span class="keyword">new</span> String(arrar);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fis!=ull)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>FileOutputStream类的使用：讲内容写入文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.app;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A2 a2 = <span class="keyword">new</span> A2();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//电脑d盘中的abc.txt 文档</span></span><br><span class="line">		String filePath = <span class="string">&quot;D:/abc.txt&quot;</span> ;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//要写入的内容</span></span><br><span class="line">		String content = <span class="string">&quot;今天是2017/1/9,天气很好&quot;</span> ;</span><br><span class="line">		a2.writeFile( filePath , content  ) ;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">( String filePath , String content )</span></span>&#123;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">null</span> ;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1、根据文件路径创建输出流</span></span><br><span class="line">			fos  = <span class="keyword">new</span> FileOutputStream( filePath );</span><br><span class="line"></span><br><span class="line">			<span class="comment">//2、把string转换为byte数组；</span></span><br><span class="line">			<span class="keyword">byte</span>[] array = content.getBytes() ;</span><br><span class="line">			<span class="comment">//3、把byte数组输出；</span></span><br><span class="line">			fos.write( array );</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ( fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fos.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>文件复制从D到E</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.app;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A3 a2 = <span class="keyword">new</span> A3();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//电脑d盘中的cat.png 图片的路径</span></span><br><span class="line">		String filePath1 = <span class="string">&quot;D:/cat.png&quot;</span> ;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//电脑e盘中的cat.png 图片的路径</span></span><br><span class="line">		String filePath2 = <span class="string">&quot;E:/cat.png&quot;</span> ;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//复制文件</span></span><br><span class="line">		a2.copyFile( filePath1 , filePath2 );</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 文件复制 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> filePath_old : 需要复制文件的路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> filePath_new : 复制文件存放的路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">( String filePath_old  , String filePath_new)</span></span>&#123;</span><br><span class="line">		FileInputStream fis=<span class="keyword">null</span> ;</span><br><span class="line">		FileOutputStream fout = <span class="keyword">null</span> ;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 根据path路径实例化一个输入流的对象</span></span><br><span class="line">			fis  = <span class="keyword">new</span> FileInputStream( filePath_old );</span><br><span class="line"></span><br><span class="line">			<span class="comment">//2. 返回这个输入流中可以被读的剩下的bytes字节的估计值；</span></span><br><span class="line">			<span class="keyword">int</span> size =  fis.available() ;</span><br><span class="line">			<span class="comment">//3. 根据输入流中的字节数创建byte数组；</span></span><br><span class="line">			<span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">			<span class="comment">//4.把数据读取到数组中；</span></span><br><span class="line">			fis.read( array ) ; </span><br><span class="line"></span><br><span class="line">			<span class="comment">//5、根据文件路径创建输出流</span></span><br><span class="line">			fout = <span class="keyword">new</span> FileOutputStream( filePath_new ) ;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//5、把byte数组输出；</span></span><br><span class="line">			fout.write( array );</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ( fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fis.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ( fout != <span class="keyword">null</span> ) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fout.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">+ java读取远程文件实例</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//读取远程文件</span></span><br><span class="line">  	<span class="meta">@ApiOperation(&quot;通过URL读取远程文件&quot;)</span></span><br><span class="line">  	<span class="meta">@GetMapping(&quot;getFileByURL&quot;)</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> ResponseWrapper&lt;String&gt; <span class="title">getFileByUrl</span><span class="params">(<span class="meta">@RequestParam(&quot;location&quot;)</span> String location)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  		<span class="keyword">int</span> b;</span><br><span class="line">  			String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  			URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">  			InputStream is = url.openStream();</span><br><span class="line">  			BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">  </span><br><span class="line">  			<span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">  				str = str + (<span class="keyword">char</span>) b;</span><br><span class="line">  			&#125;</span><br><span class="line">  			is.close();</span><br><span class="line">  			bis.close();</span><br><span class="line">  			str = <span class="keyword">new</span> String(str.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">new</span> ResponseWrapper&lt;&gt;(str);</span><br><span class="line">  		&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2021/03/24/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a><strong>ArrayList和linkedList的区别</strong></h1><ul>
<li>两者都不同步，也就是不保证线程安全。</li>
<li>底层数据结构：A用的是Object数组，L使用双向链表。（1.6之前是循环列表，JDK1.7取消循环）</li>
<li>插入和删除元素是否受元素位置影响：A是数组，默认追加到末尾，但是如果指定i位置插入和删除（<code>add(int index, E element)</code>）时间复杂度是$O(n-i)$，因为顺序后移。L是链表，插入删除是O（1）。如果是在I位置插入删除，时间复杂度是O(n)，因为需要先移动都指定位置。</li>
<li>快速随机访问：L不支持，A支持。</li>
<li>内存占用空间：A浪费体现在list列表的结尾会预留一定的容量空间。而L体现在他的每一个元素消耗更多空间（存放直接后继和前驱以及数据）。</li>
</ul>
<h1 id="ArrayList和Vector区别，为什么用A取代V"><a href="#ArrayList和Vector区别，为什么用A取代V" class="headerlink" title="ArrayList和Vector区别，为什么用A取代V"></a><strong>ArrayList和Vector区别，为什么用A取代V</strong></h1><ul>
<li>A是List的主要实现类，适用于频繁的查找，线程不安全。</li>
<li>V是List的古老实现类，底层Object数组，线程安全。</li>
</ul>
<h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a><strong>ArrayList的扩容机制</strong></h1><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90?id=_3-arraylist-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90">扩容机制</a></p>
<h1 id="hashMap和Hashtable区别"><a href="#hashMap和Hashtable区别" class="headerlink" title="hashMap和Hashtable区别"></a><strong>hashMap和Hashtable区别</strong></h1><ul>
<li><p>线程安全</p>
<p>M非线程安全，T线程安全。因为T内部的方法经过synchronized修饰</p>
</li>
<li><p>效率</p>
<p>因为线程安全，M效率高，T淘汰，不使用。</p>
</li>
<li><p>对null key和Null value的支持</p>
<p>M可以存储null的K和V，但是null作为K只能有一个，作为V可以多个。T不可。</p>
</li>
<li><p>初始容量大小和每次扩充容量大小的不同</p>
<ul>
<li>不指定初始：T默认11，每次扩2n+1；M初始16，每次2倍</li>
<li>给定：T直接使用给定大小，M将其扩充为2的幂次方。</li>
</ul>
</li>
<li><p>底层数据结构</p>
<p>DK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ul>
<p>M带有初始容量的构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">      if (initialCapacity &lt; 0)</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">      if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      this.loadFactor &#x3D; loadFactor;</span><br><span class="line">      this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">   public HashMap(int initialCapacity) &#123;</span><br><span class="line">      this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面的方法保证了M总是使用2的幂次方作为哈希表的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns a power of two size for the given target capacity.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h1><p>S底层就是基于M实现的。</p>
<table>
<thead>
<tr>
<th align="center">M</th>
<th align="center">S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了Map接口</td>
<td align="center">实现了Set接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用put添加元素</td>
<td align="center">调用Add添加元素</td>
</tr>
<tr>
<td align="center">使用键计算hashcode</td>
<td align="center">成员对象计算hashcode。对象hash可能相等，用equals()判断对象的相等性</td>
</tr>
</tbody></table>
<h1 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h1><p>先计算hashcode值判断对象加入位置，同时与其他加入的对象的hc值比较，没有相符，假设对象没有重复出现。有相同，调用equals()方法检查hc相等的对象是否真的相等。相等，就不会加入。</p>
<p><strong>hashcode和equals()的规定</strong></p>
<ul>
<li>对象相等，则hashcode相同</li>
<li>对象相等，对两个equals()返回true</li>
<li>两个对象有相同的hashcode值，也不一定相等。</li>
</ul>
<p>综上，如果一个类的equals()方法被覆盖过，则hashcode()也必须被覆盖。</p>
<p><strong>==与equals的区别</strong></p>
<ul>
<li>基本类型来说，==比较的是值相等</li>
<li>对于引用类型，==比较的是两个引用是否指向同一个对象地址。</li>
<li>对于引用类型，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</li>
</ul>
<h1 id="hashMap的底层实现原理"><a href="#hashMap的底层实现原理" class="headerlink" title="hashMap的底层实现原理"></a>hashMap的底层实现原理</h1><p>Node对象，有key,value,hash,next.</p>
<p>hash字段的值是key.hashcode()二次加工得到的，高16位于低16位异或(实际的table长度不会很大，一般在16位以内，这么一来，高16位就浪费了)。寻址算法是hash&amp;(table.length-1)，长度一定是2的次方树，length转化为二进制一定是1高位。其余是0，减1之后，就全是1了。</p>
<p>Put写数据的流程。先获得slot，这里有四种情况：</p>
<ul>
<li>slot是null，直接放。</li>
<li>slot不是null，但是没有链化。先判断node对象的key和当前对象的key是不是完全相等，相等就replace操作，否则就是hash冲突。</li>
<li>slot链化，但是没有树化。不一致则加链。判断有没有达到树化阈值，有的话则转化为红黑树</li>
<li>slot已经树化，则红黑树的平衡操作。</li>
</ul>
<h2 id="在JDK1-8之前"><a href="#在JDK1-8之前" class="headerlink" title="在JDK1.8之前"></a>在JDK1.8之前</h2><p>在1.8之前，HashMap的底层是散列表。通过Key的hashcode经过扰动函数处理得到hash值，通过(n-1)&amp;hash判断当前元素的存放位置，位置存在元素，判断该元素与要存入的元素的hash值以及Key是否相同，相同直接覆盖，不相同通过拉链法解决冲突。</p>
<p>扰动函数就是hash方法，是为了防止一些实现比较长的hashcode()方法，减少碰撞。</p>
<h2 id="在JDK1-8之后"><a href="#在JDK1-8之后" class="headerlink" title="在JDK1.8之后"></a>在JDK1.8之后</h2><p>解决冲突有大变化，当链表长度大于阈值（默认是8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，减少搜索时间。</p>
<h2 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h2><p>为了存取高效，减少碰撞，尽量把数据分配均匀。hash的值范围是-2147483648到2147483647，加起来大概40亿的映射空间，只要哈希函数映射的比较均匀，一般不太容易碰撞。但是40亿长度的数组，内存放不下。所以这个散列值不能直接拿来用。用之前还要对数组的长度取模运算，得到的余数才是要存放的数组下标。数组下标的计算方法是<code>(n-1)&amp;hash</code>。n是数组长度，这也就解释了为什么长度是2的幂次方。</p>
<p><strong>算法如何设计？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p>
<h2 id="M多线程导致死循环问题"><a href="#M多线程导致死循环问题" class="headerlink" title="M多线程导致死循环问题"></a>M多线程导致死循环问题</h2><p>并发情况下的Rehash会造成元素之间形成一个循环链表。不过jdk1.8之后解决了这个问题，但是多线程可能导致其他的问题比如数据丢失，并发情况下推荐使用ConcurrenthashMap。</p>
<h1 id="ConcurrentHashMap和hashTable的区别"><a href="#ConcurrentHashMap和hashTable的区别" class="headerlink" title="ConcurrentHashMap和hashTable的区别"></a>ConcurrentHashMap和hashTable的区别</h1><p>主要体现在实现线程安全的方式不同。</p>
<ul>
<li><p>底层数据结构</p>
<p>1.7的C底层采用分段的数组+链表实现，1.8的数据结构是数组+链表/红黑树。</p>
<p>T是数组+链表，数组是主体，链表是为了解决冲突。</p>
</li>
<li><p>**实现线程安全的方式(重要)**：</p>
<ul>
<li>1.7的时候，C对数组进行分割，锁只锁一部分数据，多线程访问不同数据段的数据，不存在锁竞争。1.8的时候摒弃分段的概念，直接采用Nod数组+链表+红黑树的数据结构，并发使用synchronized和CAS来操作。看起来就像是优化且线程安全的hashMap，虽然在1.8还能看到分割的数据结构，但是简化了属性。</li>
<li>T使用synchronized保证线程安全，效率低下，当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或者轮训状态，如果使用put添加元素，另一个线程就不能put，也不能get。</li>
</ul>
<p>DK1.8 的 <code>ConcurrentHashMap</code> 不在是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
</li>
</ul>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210326194343000.png" alt="image-20210326194343000"></p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210326194354519.png" alt="image-20210326194354519"></p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210326194403284.png" alt="image-20210326194403284"></p>
<h1 id="ConcurrentHashMap线程安全的具体实现方式"><a href="#ConcurrentHashMap线程安全的具体实现方式" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式"></a>ConcurrentHashMap线程安全的具体实现方式</h1><h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><p>数据分段，每段加锁，当一个线程占用锁访问数据时，其他的数据可以被其他线程访问。</p>
<p>SegMent实现了<code>ReentranLock</code>，所以是一种可重入锁，扮演锁的角色，HashEntry用于存储键值对数据。</p>
<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
<h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><p>采用CAS和synchronized保证线程安全。数据结构是数组+链表/红黑树，超过8就转化为红黑树。</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h1 id="hashSet、LinkedHashSet和treeSet三者异同"><a href="#hashSet、LinkedHashSet和treeSet三者异同" class="headerlink" title="hashSet、LinkedHashSet和treeSet三者异同"></a>hashSet、LinkedHashSet和treeSet三者异同</h1><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p>
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p>
<p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>
<h1 id="底层数据结构总结"><a href="#底层数据结构总结" class="headerlink" title="底层数据结构总结"></a>底层数据结构总结</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>List<ul>
<li>ArrayList：Object[]数组</li>
<li>Vector：Object[]数组</li>
<li>LinkedList：双向链表</li>
</ul>
</li>
<li>Set<ul>
<li>hashSet：基于hashMap实现，底层采用hashMap来保存元素。</li>
<li>LinkedHashSet：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h1 id="如何选用"><a href="#如何选用" class="headerlink" title="如何选用"></a>如何选用</h1><p>根据特点，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MPI分布式计算</title>
    <url>/2021/04/07/MPI%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="1、并行计算简介"><a href="#1、并行计算简介" class="headerlink" title="1、并行计算简介"></a>1、并行计算简介</h1><h2 id="都得从性能提升说起"><a href="#都得从性能提升说起" class="headerlink" title="都得从性能提升说起"></a>都得从性能提升说起</h2><ul>
<li>不断提升的计算能力成为许多飞速发展领域的核心力量<ul>
<li>人类基因解码、更精准的医疗成像等等</li>
<li>气候模拟、蛋白质折叠、药物发现、数据分析等等</li>
</ul>
</li>
<li>需要更加强大的计算能力</li>
<li>并行计算是云计算的重要支撑技术之一</li>
</ul>
<h2 id="为什么要构建并行系统"><a href="#为什么要构建并行系统" class="headerlink" title="为什么要构建并行系统"></a>为什么要构建并行系统</h2><ul>
<li>单处理器的性能提升已经接近极限。</li>
<li>通过继续增快集成电路的速度来提高处理器性能的方法不再可行。但集成电路晶体管的密度还在增加，如何利用不断增加的晶体管密度来提高计算能力？<strong>答案是并行</strong></li>
<li>与其构建更快更复杂的但处理器，不如在单个芯片放置多个相对简单的处理器。这样的集成电路为多核处理器。传统的成为单核处理器。</li>
</ul>
<h2 id="为什么要编写并行程序"><a href="#为什么要编写并行程序" class="headerlink" title="为什么要编写并行程序"></a>为什么要编写并行程序</h2><ul>
<li>单核系统编写的程序无法利用多核处理器，所以需要将串行程序改为并行程序。</li>
<li>自动将串行改为并行鲜有突破，需要手动编写</li>
<li>最好的并行化实现是通过一步步的回溯，然后发现一个全新的算法来获得</li>
</ul>
<h2 id="怎么编写并行程序"><a href="#怎么编写并行程序" class="headerlink" title="怎么编写并行程序"></a>怎么编写并行程序</h2><ul>
<li>任务并行：将待解决问题所需要执行的各个任务分配到各个核上执行</li>
<li>数据并行：将待解决问题的数据分配给各个核，每个核在分配到的数据集上执行大致相似操作。</li>
</ul>
<h2 id="并行计算的难点"><a href="#并行计算的难点" class="headerlink" title="并行计算的难点"></a>并行计算的难点</h2><ul>
<li>核之前独立，和串行相似。核之间需要协调工作，复杂</li>
<li>协调包括：通信，负载平衡，同步</li>
<li>核的执行顺序不确定，存在共享内存临界区的竞争访问和线程安全性问题</li>
<li>并行程序的设计与程序所依赖的并行硬件平台有着紧密关系，特别是需要设计高性能并行程序时，一定要针对硬件平台进行优化。</li>
<li>尚且没有统一标准，常用的拓展库有MPI、Pthread、OpenMP、OpenACC</li>
</ul>
<h2 id="并行硬件"><a href="#并行硬件" class="headerlink" title="并行硬件"></a>并行硬件</h2><p>通过系统可处理的指令数量和数据流数量区分各类并行硬件。</p>
<ul>
<li><p>单指令单数据流(SISD)系统</p>
<p>如传统的冯.诺依曼系统，拥有单个的指令流和单个的数据流</p>
</li>
<li><p>单指令多数据流(SIMD)系统</p>
<p>系统在任何时间执行一条指令，但是该指令可以对多个数据项进行操作。这种并行系统通常使用数据并行程序，即将数据划分给各个处理器，各个数据由相同的指令序列来处理。向量处理器和GPU一般划分为SIMD系统。</p>
</li>
<li><p>多指令多数据流(MIMD)系统</p>
<p>系统同时执行多个指令流，每个指令流有自己的数据流。大多数大型MIMD系统其实是混合系统，是由多个相对小的共享内存系统通过网络连接来实现的。系统内的共享内存系统一般称为节点。有些MIMD系统是异构系统，处理器拥有不同的性能。如果一个系统中所有的处理器都是相同结构的，则是同构的。</p>
</li>
</ul>
<h2 id="并行程序的性能"><a href="#并行程序的性能" class="headerlink" title="并行程序的性能"></a>并行程序的性能</h2><ul>
<li><p>加速比</p>
<ul>
<li>用**T<del>串</del><strong>表示串行程序执行时间，</strong>T<del>并</del><strong>表示并行程序的执行时间，并行程序的加速比</strong>S=T<del>串</del> / T<del>并</del>**，即使用并行程序后执行速度提升了多少倍</li>
<li><strong>阿姆达尔定律：</strong>如果原有串行程序中无法并行化部分在整个程序中所占的比例是r，那么无论使用线程/进程，得到的加速比无法超越1/r。</li>
</ul>
</li>
<li><p>效率</p>
<p>*<em>E=T<del>串</del>/(p</em>T<del>并</del>)**，P是核数，或者进程/线程数，理想值是1</p>
</li>
</ul>
<h1 id="2、MPI概述"><a href="#2、MPI概述" class="headerlink" title="2、MPI概述"></a>2、MPI概述</h1><ul>
<li>MPI提供了了解集群之间通信机制的一种重要模型</li>
<li>MPI是消息传递接口的英文简称。描述的是一种消息传递编程模型</li>
<li>MPI本身不是一个具体实现，是一种标准描述</li>
</ul>
<h1 id="3、MPI的架构和特点"><a href="#3、MPI的架构和特点" class="headerlink" title="3、MPI的架构和特点"></a>3、MPI的架构和特点</h1><ul>
<li><p>MPI的核心工作就是实现大量服务器资源的整合输出</p>
</li>
<li><p>主要思想是通过消息传递来对位于多个计算机上通过网络分布式内存系统进行编程</p>
</li>
<li><p>提供最大的灵活性和自由度，但是编程复杂</p>
</li>
<li><p>MPI的主要特点有：</p>
<ul>
<li><p>程序编写灵活，功能强大</p>
<p>MPI提供了功能强大的消息通信函数，如阻塞通信、非阻塞通信、组通信、规约、自定义函数类型等。为程序设计人员灵活地实现算法的并行化工作提供了手段。</p>
</li>
<li><p>支持多种语言</p>
</li>
<li><p>对计算的支持强大，对文件的支持较弱。</p>
</li>
<li><p>MPI需要自己实现求解问题的并行化</p>
</li>
<li><p>没有提供计算失效的处理机制，节点失效，需要重启计算</p>
</li>
<li><p>网络是MPI的瓶颈</p>
</li>
</ul>
</li>
</ul>
<h1 id="4、MPI分布式程序设计"><a href="#4、MPI分布式程序设计" class="headerlink" title="4、MPI分布式程序设计"></a>4、MPI分布式程序设计</h1><h2 id="C-MPI程序示例"><a href="#C-MPI程序示例" class="headerlink" title="C+MPI程序示例"></a>C+MPI程序示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;mpi.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(argc,argv)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> argc</span>;</span><br><span class="line"><span class="keyword">char</span> *argv[];</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//myid某一个并行执行的标识</span></span><br><span class="line">    <span class="comment">//numprocs参与计算的进程个数</span></span><br><span class="line">    <span class="comment">//processor_name实际得到的机器名字</span></span><br><span class="line">    <span class="keyword">int</span> myid,numprocs;</span><br><span class="line">    <span class="keyword">int</span> namelen;</span><br><span class="line">    <span class="keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</span><br><span class="line">    </span><br><span class="line">    MPI_Init(&amp;argc,&amp;argv);</span><br><span class="line">    <span class="comment">//MPI_Comm_rank得到当前正在运行的进程的标识号，放在myid中。</span></span><br><span class="line">    MPI_Comn_rank(MPI_COMN_WORLD,&amp;myid);</span><br><span class="line">    <span class="comment">//MPI_Comm_size得到所有参加运算的进程的个数，放在numprocs中。</span></span><br><span class="line">    MPI_Comn_size(MPI_COMN_WORLD,&amp;numprocs);</span><br><span class="line">    <span class="comment">//MPI_Get_processor_name得到本进程运行的机器的名称 ，结果放在processor_name中，它是一个字符串而该字符串的长度放在namelen中。</span></span><br><span class="line">    MPI_Get_processor_name(processor_name,&amp;namelen);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Hello World!Process %d of %d on %s\n&quot;</span>,myid,numprocs,processor_name);</span><br><span class="line">    </span><br><span class="line">    MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MPI参数"><a href="#MPI参数" class="headerlink" title="MPI参数"></a>MPI参数</h2><ul>
<li>IN 输入：调用部分传递给MPI的参数，不允许修改</li>
<li>OUT 输出：MPI返回给调用部分的结果参数</li>
<li>INOUT 输入输出：调用部分首先将该参数传递给MPI，引用修改后将结果返回给外部调用。该参数的初始值和返回值都有意义。</li>
</ul>
<h2 id="MPI接口调用"><a href="#MPI接口调用" class="headerlink" title="MPI接口调用"></a>MPI接口调用</h2><p>说明格式：</p>
<ul>
<li>独立于具体语言的说明</li>
<li>C形式的原型声明</li>
<li>FORTRAN形式的原型声明</li>
</ul>
<h2 id="MPI初始化"><a href="#MPI初始化" class="headerlink" title="MPI初始化"></a>MPI初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MPI_INIT()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Init</span><span class="params">(*argc,**argv)</span></span></span><br><span class="line"><span class="function"><span class="title">MPI_INIT</span><span class="params">(IERROR)</span></span></span><br><span class="line"><span class="function">INTEGER IERROR</span></span><br></pre></td></tr></table></figure>

<p>MPI_INIT是MPI程序的第一个调用，他完成程序的初始化工作，所有MPI程序的第一条可执行语句</p>
<h2 id="MPI结束"><a href="#MPI结束" class="headerlink" title="MPI结束"></a>MPI结束</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MPI_FINALIZE()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Finalize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">MPI_FINALIZE</span><span class="params">(ERROR)</span></span></span><br><span class="line"><span class="function">INTEGER IERROR</span></span><br></pre></td></tr></table></figure>

<p>MPI_FINALIZE是MPI程序的最后一个调用，结束MPI的运行，是MPI的最后一条可执行语句。</p>
<h2 id="当前进程标识"><a href="#当前进程标识" class="headerlink" title="当前进程标识"></a>当前进程标识</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">MPI_COMM_RANK(comm,rank)</span><br><span class="line">IN comm 该进程所在的通信域(句柄)、</span><br><span class="line">OUT rank  该进程在comm的标识号</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_rank</span><span class="params">(MPI_Comm comm,<span class="keyword">int</span> *rank)</span></span></span><br><span class="line"><span class="function"><span class="title">MPI_COMM_RANK</span><span class="params">(COMM,RANK,IERROR)</span></span></span><br><span class="line">INTEGER COMM,RANK,IERROR</span><br></pre></td></tr></table></figure>

<p>这一调用返回调用进程在给定域中的进程标识号，不同的进程就可以将自身和其他进程区分开来，实现各自进程的并行和协作</p>
<h2 id="通信域包含额进程数"><a href="#通信域包含额进程数" class="headerlink" title="通信域包含额进程数"></a>通信域包含额进程数</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">MPI_COMN_SIZE(comm,size)</span><br><span class="line">IN comn</span><br><span class="line">OUT size 通信域包含的进程数</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_size</span><span class="params">(MPI_Comm comm,<span class="keyword">int</span> *size)</span></span></span><br><span class="line"><span class="function"> <span class="title">MPI_COMM_SIZE</span><span class="params">(COMM,SIZE,IERROR)</span></span></span><br><span class="line">    INTEGER COMM,SIZE,IERROR</span><br></pre></td></tr></table></figure>

<p>这一调用返回给定的通信域中所包含的进程的个数，不同的进程通过这一调用得知在给定的通信域中一共有多少个进程在并行执行。</p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MPI_SEND(buf,count,datatype,dest,comm)</span><br><span class="line">In buf &#x2F;&#x2F;发送缓冲区的起始地址</span><br><span class="line">IN count&#x2F;&#x2F;将发送的数据的个数</span><br><span class="line">IN datatype &#x2F;&#x2F;数据类型(句柄)</span><br><span class="line">IN dest &#x2F;&#x2F;目标的进程标识号</span><br><span class="line">IN tag &#x2F;&#x2F;消息标志</span><br><span class="line">IN comm &#x2F;&#x2F;通信域(句柄)</span><br><span class="line"></span><br><span class="line">int MPI_Send(void *buf,int count,MPI_Datatype,int dest,int tag,MPI_Comm comm)</span><br><span class="line"></span><br><span class="line">MPI_SEND(BUF,COUNT,DATATYPE,DEST,TAG,COMM,IERROR)</span><br><span class="line">	&lt;type&gt; BUF(*)</span><br><span class="line">	INTEGER COUNT,DATATYPE,DEST,TAG,COMM,IERROR</span><br></pre></td></tr></table></figure>

<h2 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MPI_RECV(buf,count,datatype,sourvr,tag,comm,status)</span><br></pre></td></tr></table></figure>

<h2 id="返回状态status"><a href="#返回状态status" class="headerlink" title="返回状态status"></a>返回状态status</h2><p>status是MPI定义的一个数据类型，使用之前需要分配空间</p>
<p>在C实现中，状态变量至少由至少三个域组成，分别是：MPI_SOURCE,MPI_TAG,MPI_ERROR。</p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>MPI</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2020/04/10/MongoDB/</url>
    <content><![CDATA[<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin目录下mongod --dbpath=..\data\db</span><br><span class="line">配置文件启动mongod -f ..\conf\mongod.conf</span><br><span class="line">连接：启动服务，输入mongo</span><br></pre></td></tr></table></figure>

<p>show dbs：显示所有数据库</p>
<p>use test：创建test数据库(内存中)</p>
<p>db：当前数据库</p>
<p>db.dropDatabase()：删除数据库</p>
<p><strong>三个保留库：</strong></p>
<p><strong>admin</strong>：root数据库，讲用户添加到这个数据库，自动继承所有数据库的权限。一些特定的服务器命令只能从这个数据库运行，比如列出所有数据库或者关闭服务器</p>
<p><strong>local</strong>：不会被复制，用来存储限于本地服务器的任意集合</p>
<p><strong>config</strong>：当Mongo用于分片设置时，config数据库在内部使用，保存分片的相关信息。</p>
<h2 id="集合的创建和删除"><a href="#集合的创建和删除" class="headerlink" title="集合的创建和删除"></a>集合的创建和删除</h2><p>显示创建：db.createCollection(“my”)</p>
<p>show collections：显示当前的collection</p>
<p>db.my.drop( )：删除集合</p>
<h2 id="文档的增删改查"><a href="#文档的增删改查" class="headerlink" title="文档的增删改查"></a>文档的增删改查</h2><ul>
<li><p>单个文档插入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.collection.insert(</span><br><span class="line">&lt;document or array of documents&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern:&lt;document&gt;,</span><br><span class="line">        ordered:&lt;<span class="keyword">boolean</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">    <span class="comment">//集合没有则会隐式创建</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.comment.insert(&#123;<span class="string">&quot;articleID&quot;</span>:<span class="string">&quot;sff&quot;</span>,<span class="string">&quot;sdf&quot;</span>:<span class="string">&quot;sdf&quot;</span>,&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.comment.insert([&#123;&#125;,&#123;&#125;,&#123;&#125;])</span><br></pre></td></tr></table></figure>

<p>db.comment.find()：查询所有数据库数据</p>
<p>db.comment.find({articleID:”1001”})：查询特定集合</p>
<p>db.comment.findOne({article:”1001”})：查询一条数据</p>
<p><strong>投影查询</strong>：</p>
<p>db.comment.find({articleID:”1001”},{articleID:1})：显示那个写哪个</p>
<p>加try catch:</p>
<p>try{</p>
<p>insert:one or many</p>
<p>}catch(e){</p>
<p>print(e);</p>
<p>}</p>
<p><strong>文档更新：</strong></p>
<p>覆盖修改：db.comment.update({_id:”1”},{likenum:NumberInt(1001)})</p>
<p>局部修改：db.comment.update({_id:”1”},{${likenum:NumberInt(1001)}})</p>
<p>批量修改：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2021/03/29/Netty/</url>
    <content><![CDATA[<p>一个异步事件驱动的网络应用框架，用于快速开发高性能、可拓展协议的服务器和客户端。</p>
<h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><p>Reactor模式基于事件驱动，适合处理海量IO事件。</p>
<blockquote>
<p>反应器设计模式：为处理服务请求并发提交到一个或多个服务处理程序的事件设计模式。请求到达后，服务器处理程序使用多路分配策略，然后同步的派发这些请求到相关的请求处理程序。</p>
</blockquote>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>所有的IO操作，都在同一个NIO(同步非阻塞IO模型)完成，NIO线程的职责如下：</p>
<ul>
<li>作为NIO服务端，接收客户端的TCP连接</li>
<li>作为NIO客户端，像服务端发起TCP连接。</li>
<li>读取通信对端的请求或应答信息。</li>
<li>想通信对端发送消息请求或应答消息。</li>
</ul>
<p>采用异步非阻塞IO，IO操作不会导致阻塞。通过Acceptor接受客户端的tcp请求，通过Dispatch将对应的byte分发到指定的handler进行消息解码。</p>
<p>但是对于高负载、高并发的场景不合适。</p>
<p><img src="https://hadyang.github.io/interview/docs/fromwork/netty/images/dc7ff89d78fc63558bd02d4515e42f38.png"></p>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>与单线程最大的区别就是有一组NIO来处理线程的IO操作。</p>
<ul>
<li>一个专门的NIO线程监听Acceptor线程用于监听服务端，接受客户端的TCP连接请求。</li>
<li>网络IO操作-读-写，由一个NIOP线程池负责，线程池可以采用标准的JDK线程池实现，他包含一个任务队列和N个可用的线程，有这些NIO线程负责消息的读取，编码解码和发送。</li>
<li>一个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止并发操作问题。</li>
</ul>
<p><img src="https://hadyang.github.io/interview/docs/fromwork/netty/images/2882a43ae27016cc885444b46a735801.png"></p>
<h2 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h2><p>特点是服务端用于接收客户端连接的不是一个单独的NIO，而是一个独立的NIO线程池，<code>Acceptor</code> 接收到客户端 <code>TCP</code> 连接请求处理完成后（可能包含接入认证等），将新创建的 <code>SocketChannel</code> 注册到 IO 线程池（<code>sub reactor</code> 线程池）的某个 IO 线程上，由它负责 <code>SocketChannel</code> 的读写和编解码工作。 <code>Acceptor</code> 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 <code>subReactor</code> 线程池的 <code>IO</code> 线程上，由 <code>IO</code> 线程负责后续的 <code>IO</code> 操作。</p>
<p>工作流程总结如下：</p>
<ul>
<li>从主线程池中随机选择一个 <code>Reactor</code> 线程作为 <code>Acceptor</code> 线程，用于绑定监听端口，接收客户端连接；</li>
<li>Acceptor 线程接收客户端连接请求之后创建新的 <code>SocketChannel</code> ，将其注册到主线程池的其它 Reactor 线程上，由其负责接入认证、IP 黑白名单过滤、握手等操作；</li>
<li>步骤 2 完成之后，业务层的链路正式建立，将 <code>SocketChannel</code> 从主线程池的 <code>Reactor</code> 线程的多路复用器上摘除，重新注册到 <code>Sub</code> 线程池的线程上，用于处理 I/O 的读写操作。</li>
</ul>
<p><img src="https://hadyang.github.io/interview/docs/fromwork/netty/images/8674352e3cb3638da5807ef88b8f225d.png"></p>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul>
<li>多路复用，在NIO的基础上进行更高层次的抽象，</li>
<li>事件机制</li>
<li>功能强大，预置了多种解码功能，支持主流协议。</li>
<li>定制功能强，可以通过channelhandler对通信框架进行灵活的拓展。</li>
</ul>
<p><strong>为什么性能好？</strong></p>
<ul>
<li>纯异步，Reactor线程模型</li>
<li>IO多路复用</li>
<li>GC优化</li>
<li>内存泄露检测</li>
<li>zero copy</li>
</ul>
<p><strong>Zero copy</strong></p>
<ul>
<li>将多个 <code>ByteBuf</code> 合并为一个逻辑上的 <code>ByteBuf</code> , 避免了各个 <code>ByteBuf</code> 之间的拷贝.</li>
<li>通过 <code>wrap</code> 操作, 我们可以将 <code>byte[]</code> <code>数组、ByteBuf</code> 、 <code>ByteBuffer</code> 等包装成一个 <code>Netty ByteBuf</code> 对象, 进而避免了拷贝操作.</li>
<li><code>ByteBuf</code> 支持 <code>slice</code> 操作, 因此可以将 <code>ByteBuf</code> 分解为多个共享同一个存储区域的 <code>ByteBuf</code>, 避免了内存的拷贝.</li>
<li>通过 <code>FileRegion</code> 包装的 <code>FileChannel.tranferTo</code> 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 <code>Channel</code> , 避免了传统通过循环 <code>write</code> 方式导致的内存拷贝问题.</li>
</ul>
<p><strong>垃圾回收</strong></p>
<p>框架里HeapByteBuffer底下的byte[]能够依赖JVM自然回收；而DirectByteBuffer底下是java堆外内存，最好主动回收。所以Netyy要有自己的计数器和回收过程。</p>
<p>原生的JVM GC很难回收掉DirectByteBuffer占用的Native Memory</p>
<p>Netty 中采用引用计数对 DirectByteBuffer 进行对象可达性检测，当 DirectByteBuffer 上的引用计数为 0 时将对象释放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean release() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int refCnt &#x3D; this.refCnt;</span><br><span class="line">        if (refCnt &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalReferenceCountException(0, -1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (refCntUpdater.compareAndSet(this, refCnt, refCnt - 1)) &#123;</span><br><span class="line">            if (refCnt &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                deallocate();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 内存泄漏，主要是针对池化的 ByteBuf 。 ByteBuf 对象被 JVM GC 掉之前，没有调用 <code>release()</code> 把底下的 <code>DirectByteBuffer</code> 或<code>byte[]</code> 归还，会导致池越来越大。而非池化的 ByteBuf ，即使像 <code>DirectByteBuf</code> 那样可能会用到 <code>System.gc()</code> ，但终归会被 release 掉的，不会出大事。因此 Netty 默认会从分配的 ByteBuf 里抽样出大约 1% 的来进行跟踪。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><h4 id="DirectBuffer-vs-HeapBuffer"><a href="#DirectBuffer-vs-HeapBuffer" class="headerlink" title="DirectBuffer vs HeapBuffer"></a>DirectBuffer vs HeapBuffer</h4><p>在执行网络IO或者文件IO时，如果是使用 <code>DirectBuffer</code> 就会少一次内存拷贝。<strong>如果是非 <code>DirectBuffer</code> ，JDK 会先创建一个 <code>DirectBuffer</code> ，再去执行真正的写操作</strong>。这是因为，当我们把一个地址通过 <code>JNI</code> 传递给底层的C库的时候，有一个基本的要求，就是这个地址上的内容不能失效。然而，在 <code>GC</code> 管理下的对象是会在 <code>Java</code> 堆中移动的。也就是说，有可能我把一个地址传给底层的 <code>write</code> ，但是这段内存却因为 <code>GC</code> 整理内存而失效了。所以我必须要把待发送的数据放到一个 <code>GC</code> 管不着的地方。这就是调用 <code>native</code> 方法之前，数据一定要在堆外内存的原因。</p>
<h2 id="启动以及链接建立过程"><a href="#启动以及链接建立过程" class="headerlink" title="启动以及链接建立过程"></a>启动以及链接建立过程</h2><p><img src="https://hadyang.github.io/interview/docs/fromwork/netty/images/922e67970b6ac7bf78cd43ac61f7aec0.png" alt="image"></p>
<h1 id="Epoll触发"><a href="#Epoll触发" class="headerlink" title="Epoll触发"></a>Epoll触发</h1><p>水平触发（LT）和边缘触发（ET）</p>
<p>在LT模式下，只要某个fd还有数据没读完，那么下次轮询还会被选出。而在ET模式下，只有fd状态发生改变后，该fd才会被再次选出。ET模式的特殊性，使在ET模式下的一次轮询必须处理完本次轮询出的fd的所有数据，否则该fd将不会在下次轮询中被选出。</p>
<ul>
<li>NIOChannel：水平触发</li>
<li>EpollChannel：边缘触发</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><a href="https://snailclimb.gitee.io/javaguide-interview/#/./docs/e-4netty">java Guide</a></p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0</title>
    <url>/2021/04/08/OAuth2-0%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h1 id="一、oauth2-0"><a href="#一、oauth2-0" class="headerlink" title="一、oauth2.0"></a>一、oauth2.0</h1><p>OAuth是一个关于授权的开放网路协议，目前版本是2.0。</p>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><ul>
<li>Third-party application：第三方应用程序，又称为客户端。</li>
<li>Http service：HTTP服务提供商，简称“服务提供商”。</li>
<li>Resource Owner：资源所有者，也称为用户。</li>
<li>User Agent：用户代理，浏览器。</li>
<li>Authorization server：认证服务器，服务提供商专门用来处理认证的服务器。</li>
<li>Resource server：资源服务器，服务提供商存放用户生成的资源的服务器。</li>
</ul>
<p>所以，OAuth2.0的作用就是让客户端安全可控的获取用户的授权，与服务提供商进行互动。</p>
<h2 id="OAuth2-0思路"><a href="#OAuth2-0思路" class="headerlink" title="OAuth2.0思路"></a>OAuth2.0思路</h2><p>在客户端与服务提供商之间，设置了一个授权层。客户端不能直接登录服务提供商，只能登陆授权层，将用户和客户端分开。客户端登陆授权曾锁用的令牌(token)，和用户使用的密码不同。用户可以在登陆的时候，指定授权层的权限范围和有效期。</p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><ol>
<li>A用户打开客户端之后，客户端要求用户给予授权。</li>
<li>用户同意给客户端授权。</li>
<li>客户端使用上一步获得的授权，想认证服务器申请令牌。</li>
<li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</li>
<li>客户端使用令牌，想资源服务器请求资源。</li>
<li>资源服务器确认令牌无误，同意向客户端开放资源。</li>
</ol>
<p>第二步骤是关键，即用户怎么才能给客户端授权。有了这个授权，客户端就可以获取令牌，从而获得资源。</p>
<h2 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h2><ul>
<li><p><strong>授权码模式</strong></p>
<p>功能最完整，通过客户端的后台服务器，与服务提供商的认证服务器进行互动。</p>
<ol>
<li>用户访问客户端，客户端将用户导向认证服务器。</li>
<li>用户选择是否给客户端授权。</li>
<li>用户同意授权，认证服务器将用户导向事先指定的“重定向URI”，同时附上一个授权码。</li>
<li>客户端收到授权码，附上早先的重定向URL“，向认证服务器申请令牌。</li>
<li>认证服务器核对授权码和冲形象URL，确认无误后，向客户端发送令牌和更新令牌。</li>
</ol>
<p><strong>1步骤需要以下参数：</strong></p>
<ul>
<li>response_type：授权类型，固定值为“code”</li>
<li>client_id：表示客户端ID，必填。</li>
<li>redirect_url：重定向URL</li>
<li>scope：申请的权限范围</li>
<li>state：当前客户端状态，认证服务器会原封不动的返回这个值</li>
</ul>
<p>下面是一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;s6BhdRkqt3&amp;state&#x3D;xyz</span><br><span class="line">        &amp;redirect_uri&#x3D;https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure>

<p><strong>3步骤中，服务器回应客户端的URL，包含以下参数：</strong></p>
<ul>
<li>code：授权码，一般是十分钟。该授权码和客户端ID与重定向URL是一一对应关系。</li>
<li>state：如果请求包含这个参数，认证服务器会原封不动的返回这个参数。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Found</span><br><span class="line">Location: https:&#x2F;&#x2F;client.example.com&#x2F;cb?code&#x3D;SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state&#x3D;xyz</span><br></pre></td></tr></table></figure>

<p><strong>4步骤中，包含以下参数：</strong></p>
<ul>
<li>grant_type：授权模式，固定值为“authorization_code”。</li>
<li>code：上一步获取的授权码</li>
<li>redirect_uri：重定向URI</li>
<li>client_id：客户端ID，必选。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;token HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type&#x3D;authorization_code&amp;code&#x3D;SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri&#x3D;https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure>

<p><strong>5步骤中，认证服务器返回HTTP回复，包含以下参数：</strong></p>
<ul>
<li>access_token：访问令牌</li>
<li>token_type：表示令牌类型，大小写不敏感。可以是Bearer或者mac</li>
<li>expires_in：过期时间，S单位。</li>
<li>refresh_token：更新令牌，用来获取下一次的访问令牌。</li>
<li>scope：权限范围。</li>
</ul>
<p>下面是一个列子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  HTTP&#x2F;1.1 200 OK</span><br><span class="line">     Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">     Cache-Control: no-store</span><br><span class="line">     Pragma: no-cache</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line">       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">       &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">       &quot;expires_in&quot;:3600,</span><br><span class="line">       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">       &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">     &#125;</span><br><span class="line">从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application&#x2F;json）。此外，HTTP头信息中明确指定不得缓存。</span><br></pre></td></tr></table></figure></li>
<li><p><strong>简化模式</strong></p>
<p>不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了授权码步骤。所有步骤在浏览器完成， 令牌对访问者可见，且客户端不需要认证。</p>
</li>
<li><p><strong>密码模式</strong></p>
<p>在密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向服务提供商获取token。</p>
</li>
<li><p><strong>客户端模式</strong></p>
<p>客户端以自己的名义而不是以用户的名义想服务提供商进行认证。严格的说，客户端模式不属于pauth框架要解决的问题。在这种模式下，用户直接向客户端注册，客户端以自己的名义要求服务提供商提供服务，不存在授权问题。步骤如下：</p>
<ul>
<li>客户端向认证服务器进行身份认证，并要求一个token</li>
<li>认证服务器确认无误，向客户端提供token</li>
</ul>
</li>
</ul>
<h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>用户访问的时候，如果客户端的令牌已经失效，需要使用更新令牌申请一个新的访问令牌。</p>
<p>客户端发送更新令牌的请求，包含以下参数：</p>
<ul>
<li>granttype：授权模式，固定为“refreshtoken”</li>
<li>refresh_token：早前收到的更新令牌。</li>
<li>scope：权限范围</li>
</ul>
<h1 id="二、水杉平台对接腾讯会议"><a href="#二、水杉平台对接腾讯会议" class="headerlink" title="二、水杉平台对接腾讯会议"></a>二、水杉平台对接腾讯会议</h1><p>腾讯会议提供的oauth2.0对接的步骤如下：</p>
<ul>
<li>用户同意授权，获取auth_code</li>
<li>通过auth_code换取token</li>
<li>刷新token</li>
<li>拉取用户信息(检查token是否有效)</li>
</ul>
<p>很明显，对接腾讯会议使用的授权模式是授权码模式。</p>
<h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><p>对于水杉的用户来说，是没有企业身份的，所以不能通过企业授权的方式直接读取学生的信息。现在的需求是，老师使用水杉平台新建一个会议，然后在会后导出学生参会的具体信息。所以在老师新建一个会议后，不能直接把参加会议的URL给到老师或者学生，我们给出的链接，只能是oauth2.0授权的连接，学生拿到链接同意授权，然后从腾讯会议获取到学生的用户名，和我们数据库的真实姓名做绑定，这样在做导出的时候，就可以根据学生的腾讯会议的用户名导出真实的姓名。</p>
<p>关于上下文，在oauth2.0的连接中，会传两个参数，一个是state，另一个是auth_code，auth_code用于换取token，state用于参数校验，我们这里可以利用state做上下文，在state中放学生学号，然后在回调的时候，通过state作为主键查询，从而做到数据绑定。</p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>对象存储及使用痛点</title>
    <url>/2020/08/03/OSS%E7%A2%B0%E5%88%B0%E7%9A%84%E7%97%9B%E7%82%B9/</url>
    <content><![CDATA[<p>这是在开发过程中的关于对象存储的一些思考和技术分享，其实关于OSS，阿里的文档提供了一些很好的解决方案，但是由于看文档时候的不细心，走了不少弯路。故事慢慢听。</p>
<h2 id="1、从对象存储说起"><a href="#1、从对象存储说起" class="headerlink" title="1、从对象存储说起"></a>1、从对象存储说起</h2><ul>
<li><p><strong>什么是对象存储？</strong></p>
<blockquote>
<p> 对象存储服务是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多种存储类型供选择，全面优化存储成本。</p>
</blockquote>
<p>这段解释来自阿里云官方文档，说的自然比较官方。</p>
<p>直白一点，对象存储都有个<code>bucket</code>的概念，这就很好理解了，桶里可以放什么？对撩，可以放海鲜，放慕斯，龙井熏鹅肝。</p>
<p>那对象存储就是什么都可以往里面放啊，万物皆可对象嘛。</p>
</li>
<li><p><strong>主流的对象存储</strong></p>
<ul>
<li>阿里云OSS</li>
<li>腾讯云COS</li>
<li>华为云OBS</li>
</ul>
</li>
</ul>
<h2 id="2、大文件是不是应该做成异步？"><a href="#2、大文件是不是应该做成异步？" class="headerlink" title="2、大文件是不是应该做成异步？"></a>2、大文件是不是应该做成异步？</h2><p>我的第一个思考是，如果一个文件超级大，同步的情况下，客户端是阻塞状态的。能不能做成异步提升用户体验，于是乎，详细的分析了一下同步和异步的执行流程，画了两张PPT，且看：</p>
<ul>
<li><p><strong>同步上传</strong></p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200803150316.png" alt="image-20200803150309594" style="zoom: 67%;" /></li>
<li><p><strong>异步上传</strong></p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200803150352.png" alt="image-20200803150352736" style="zoom: 67%;" /></li>
<li><p><strong>异步执行过程</strong></p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200803150433.png" alt="image-20200803150433038" style="zoom: 67%;" /></li>
</ul>
<p>在这种解决方案下，开始写代码实现，然后开始测试，先选择了一个1G的文件，上传，success。然后直接来个10G，我丢，内存爆掉了。这时候的问题不是来自于OSS，而是<code>multipartfile</code>这个spring封装的类型，这玩意是读进内存的。问题出现了，这时候是没法实现真正的大文件的，因为这一切都是相对于内存来说的。显然，后端上传的方式，受限于内存，想实现真正的大文件也可以，自己写一个文件传输，或者分片读取什么的，难顶。</p>
<p>然后放弃这种方式，去文档寻求解决方案，还真有，就是通过web直接传输到OSS，服务器就是一个校验的作用，原理图如下：</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200803151330.png" alt="image-20200803151330153" style="zoom:50%;" />

<p>用这种方式文件就不需要走服务器了，减轻了服务器负载，至于实现的话，阿里云提供了demo，改写一下然后移植到自己的系统就好。这种方式也是支持分片上传的，阿里把权限校验做的很好，甚至可以给每一片文件分配一个权限和到期时间，安全性和大文件问题迎刃而解。</p>
<p>大概就是这个样子，改写是肯定的，后端绕过了文件这一步，绕不过mysql这一步。</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200803153334.png" alt="image-20200803153333919"></p>
<h2 id="3、万一合作谈崩了"><a href="#3、万一合作谈崩了" class="headerlink" title="3、万一合作谈崩了"></a>3、万一合作谈崩了</h2><p>现在阿里提供了赞助，包括云主机和OSS的服务，我想到的第二个问题是，万一哪天，OSS用不起了，需要把数据迁移出来，如何保证我的系统不受影响？因为现在上传之后是通过OSS返回的URL来访问文件，那迁出OSS后，这个文件自然也就失去了意义。</p>
<p>拿课程资源为例，在上传文件的时候，我没有把文件直接放到一个乱七八糟的bucket中，同时也维护了一个目录</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200803152735.png" alt="image-20200803152735912"></p>
<p>课程名称和周进度，这时候想访问资源，就变成了对一个文件系统的操作，因为课程名称和周进度是可以从数据库查到的，然后拿去访问丝毫不会有问题。</p>
<h2 id="4、加速访问"><a href="#4、加速访问" class="headerlink" title="4、加速访问"></a>4、加速访问</h2><p>至于如何使用CDN加速访问这些，额，看张图就好了</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200803153139.png" alt="image-20200803153139725" style="zoom:67%;" />

<hr>
<hr>
<p>最后，所有这些思考其实都挺无力的，因为最后还是用了阿里的解决方案。</p>
<p>但是事不能这么想啊，你在思考异步的时候知道如何写一个异步程序。你在思考大文件的时候，开始去考虑文件的分片和权限校验。那些错误的东西不是我要的，但是这个东西是我需要的。</p>
<p>所以啊，当你在学什么go语言，想用redis的时候，先看看文档，那些B站上动辄几百小时的课，只会劝退你，然后你会发现：</p>
<ul>
<li>rabbitmq要看好几天</li>
<li>kafka要看好几天</li>
<li>mapreduce要看好几天</li>
<li>连个小小的redis都要看好几天</li>
<li>我去它瞄的。​ T-T</li>
</ul>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Player</title>
    <url>/2020/03/23/Player/</url>
    <content><![CDATA[

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <title>朱会会的云播放器</title>
  <link rel="shortcut icon" href="https://i.loli.net/2020/03/23/9PodXJcDkQu5MZt.png">
  <!-- 样式 -->
<!--  <link rel="stylesheet" href="./css/index.css">-->
  <style type="text/css">
    body,
    ul,
    dl,
    dd {
      margin: 0px;
      padding: 0px;
    }


    .wrap {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: url("https://nextlab.oss-cn-shanghai.aliyuncs.com/img/gz9abCBAcphv6jF.jpg") no-repeat;
      background-size: 100% 100%;
    }
    
    .play_wrap {
      width: 800px;
      height: 544px;
      position: fixed;
      left: 50%;
      top: 50%;
      margin-left: -400px;
      margin-top: -272px;
      /* background-color: #f9f9f9; */
    }
    
    .search_bar {
      height: 60px;
      background-color: #1eacda;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      z-index: 11;
    }
    
    .search_bar img {
      margin-left: 23px;
    }
    
    .search_bar input {
      margin-right: 23px;
      width: 296px;
      height: 34px;
      border-radius: 17px;
      border: 0px;
      background: url("https://nextlab.oss-cn-shanghai.aliyuncs.com/img/9FeKnVlohsY3krO.png") 265px center no-repeat
      rgba(255, 255, 255, 0.45);
      text-indent: 15px;
      outline: none;
    }
    
    .center_con {
      height: 435px;
      background-color: rgba(255, 255, 255, 0.5);
      display: flex;
      position: relative;
    }
    
    .song_wrapper {
      width: 200px;
      height: 435px;
      box-sizing: border-box;
      padding: 10px;
      list-style: none;
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 1;
    }
    
    .song_stretch {
      width: 600px;
    }
    
    .song_list {
      width: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      height: 100%;
    }
    .song_list::-webkit-scrollbar {
      display: none;
    }
    
    .song_list li {
      font-size: 12px;
      color: #333;
      height: 40px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      width: 580px;
      padding-left: 10px;
    }
    
    .song_list li:nth-child(odd) {
      background-color: rgba(240, 240, 240, 0.3);
    }
    
    .song_list li a {
      display: block;
      width: 17px;
      height: 17px;
      background-image: url("https://nextlab.oss-cn-shanghai.aliyuncs.com/img/chJ89uNpofneFrS.png");
      background-size: 100%;
      margin-right: 5px;
      box-sizing: border-box;
    }
    
    .song_list li b {
      font-weight: normal;
      width: 122px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .song_stretch .song_list li b {
      width: 200px;
    }
    
    .song_stretch .song_list li em {
      width: 150px;
    }
    
    .song_list li span {
      width: 23px;
      height: 17px;
      margin-right: 50px;
    }
    .song_list li span i {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
      background: url("https://nextlab.oss-cn-shanghai.aliyuncs.com/img/HFyBnJ5loLhI7qK.png") left -48px no-repeat;
    }
    
    .song_list li em,
    .song_list li i {
      font-style: normal;
      width: 100px;
    }
    
    .player_con {
      width: 400px;
      height: 435px;
      position: absolute;
      left: 200px;
      top: 0px;
    }
    
    .player_con2 {
      width: 400px;
      height: 435px;
      position: absolute;
      left: 200px;
      top: 0px;
    }
    
    .player_con2 video {
      position: absolute;
      left: 20px;
      top: 30px;
      width: 355px;
      height: 265px;
    }
    
    .disc {
      position: absolute;
      left: 73px;
      top: 60px;
      z-index: 9;
    }
    .cover {
      position: absolute;
      left: 125px;
      top: 112px;
      width: 150px;
      height: 150px;
      border-radius: 75px;
      z-index: 8;
    }
    .comment_wrapper {
      width: 180px;
      height: 435px;
      list-style: none;
      position: absolute;
      left: 600px;
      top: 0px;
      padding: 25px 10px;
    }
    .comment_wrapper .title {
      position: absolute;
      top: 0;
      margin-top: 10px;
    }
    .comment_wrapper .comment_list {
      overflow: auto;
      height: 410px;
    }
    .comment_wrapper .comment_list::-webkit-scrollbar {
      display: none;
    }
    .comment_wrapper dl {
      padding-top: 10px;
      padding-left: 55px;
      position: relative;
      margin-bottom: 20px;
    }
    
    .comment_wrapper dt {
      position: absolute;
      left: 4px;
      top: 10px;
    }
    
    .comment_wrapper dt img {
      width: 40px;
      height: 40px;
      border-radius: 20px;
    }
    
    .comment_wrapper dd {
      font-size: 12px;
    }
    
    .comment_wrapper .name {
      font-weight: bold;
      color: #333;
      padding-top: 5px;
    }
    
    .comment_wrapper .detail {
      color: #666;
      margin-top: 5px;
      line-height: 18px;
    }
    .audio_con {
      height: 50px;
      background-color: #f1f3f4;
      border-bottom-left-radius: 4px;
      border-bottom-right-radius: 4px;
    }
    .myaudio {
      width: 800px;
      height: 40px;
      margin-top: 5px;
      outline: none;
      background-color: #f1f3f4;
    }
    /* 旋转的动画 */
    @keyframes Rotate {
      from {
        transform: rotateZ(0);
      }
      to {
        transform: rotateZ(360deg);
      }
    }
    /* 旋转的类名 */
    .autoRotate {
      animation-name: Rotate;
      animation-iteration-count: infinite;
      animation-play-state: paused;
      animation-timing-function: linear;
      animation-duration: 5s;
    }
    /* 是否正在播放 */
    .player_con.playing .disc,
    .player_con.playing .cover {
      animation-play-state: running;
    }
    
    .play_bar {
      position: absolute;
      left: 200px;
      top: -10px;
      z-index: 10;
      transform: rotate(-25deg);
      transform-origin: 12px 12px;
      transition: 1s;
    }
    /* 播放杆 转回去 */
    .player_con.playing .play_bar {
      transform: rotate(0);
    }
    /* 搜索历史列表 */
    .search_history {
      position: absolute;
      width: 296px;
      overflow: hidden;
      background-color: rgba(255, 255, 255, 0.3);
      list-style: none;
      right: 23px;
      top: 50px;
      box-sizing: border-box;
      padding: 10px 20px;
      border-radius: 17px;
    }
    .search_history li {
      line-height: 24px;
      font-size: 12px;
      cursor: pointer;
    }
    .switch_btn {
      position: absolute;
      right: 0;
      top: 0;
      cursor: pointer;
    }
    .right_line {
      position: absolute;
      left: 0;
      top: 0;
    }
    .video_con video {
      position: fixed;
      width: 800px;
      height: 546px;
      left: 50%;
      top: 50%;
      margin-top: -273px;
      transform: translateX(-50%);
      z-index: 990;
    }
    .video_con .mask {
      position: fixed;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
      z-index: 980;
      background-color: rgba(0, 0, 0, 0.8);
    }
    .video_con .shutoff {
      position: fixed;
      width: 40px;
      height: 40px;
      background: url("https://nextlab.oss-cn-shanghai.aliyuncs.com/img/ZWSChyBwjA5uRfL.png") no-repeat;
      left: 50%;
      margin-left: 400px;
      margin-top: -273px;
      top: 50%;
      z-index: 995;
    }
  </style>
</head>

<body>

  <div class="wrap">
    <div class="play_wrap" id="player">
      <div class="search_bar">
        <img src="https://i.loli.net/2020/03/23/LsjN2BRPl6DfCJa.png" width="100" height="80" alt="会会" />
        <!-- 搜索歌曲 -->
        <input type="text" placeholder="您得先搜索啊啊啊！！" autocomplete="off" v-model='query' @keyup.enter="searchMusic();" />
      </div>
      <div class="center_con">
        <!-- 搜索歌曲列表 -->
        <div class='song_wrapper' ref='song_wrapper'>
          <ul class="song_list">
            <li v-for="item in musicList">
              <!-- 点击放歌 -->
              <a href="javascript:;" @click='playMusic(item.id)'></a>
              <b>{{item.name}}</b>
              <span>
                <i @click="playMv(item.mvid)" v-if="item.mvid!=0"></i>
              </span>
            </li>




          </ul>
          <img src="![](https://nextlab.oss-cn-shanghai.aliyuncs.com/img/dor23bhZtIvK17X.htm)" class="switch_btn" alt="">
        </div>
        <!-- 歌曲信息容器 -->
        <div class="player_con" :class="{playing:isPlay}">
          <img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/gZHko2WlpJNcGPv.png" class="play_bar" />
          <!-- 黑胶碟片 -->
          <img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/hQPuH4gNRx7XayI.png" class="disc autoRotate" />
          <img :src="coverUrl==''?'https://nextlab.oss-cn-shanghai.aliyuncs.com/img/QEL4rdy5KCsn3cz.png':coverUrl" class="cover autoRotate" />
        </div>
        <!-- 评论容器 -->
        <div class="comment_wrapper" ref='comment_wrapper'>
          <h5 class='title'>热门留言</h5>
          <div class='comment_list'>
    
            <dl v-for="item in hotComments">
              <dt>
                <img :src="item.user.avatarUrl" alt="" />
              </dt>
              <dd class="name">{{item.user.nickname}}</dd>
              <dd class="detail">
                {{item.content}}
              </dd>
            </dl>
          </div>
          <img src="https://i.loli.net/2020/03/23/dor23bhZtIvK17X.png" class="right_line">
        </div>
      </div>
      <div class="audio_con">
        <audio ref='audio' @play="play" @pause="pause" :src="musicUrl" controls autoplay loop class="myaudio"></audio>
      </div>
      <div class="video_con" v-show="showVideo">
        <video ref='video' :src="mvUrl" controls="controls"></video>
        <div class="mask" @click="closeMv"></div>
      </div>
    </div>
  </div>
  <!-- 开发环境版本，包含了有帮助的命令行警告 -->
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <!-- 官网提供的 axios 在线地址 -->
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script type="text/javascript">
    // 设置axios的基地址
    axios.defaults.baseURL = 'https://autumnfish.cn';
    // axios.defaults.baseURL = 'http://localhost:3000';

    // 实例化vue
    var app = new Vue({
      el: "#player",
      data: {
        // 搜索关键字
        query: '',
        // 歌曲列表
        musicList: [],
        // 歌曲url
        musicUrl: '',
        // 是否正在播放
        isPlay: false,
        // 歌曲热门评论
        hotComments: [],
        // 歌曲封面地址
        coverUrl: '',
        // 显示视频播放
        showVideo: false,
        // mv地址
        mvUrl: ''
      },
      // 方法
      methods: {
        // 搜索歌曲
        searchMusic() {
          if (this.query == 0) {
            return
          }
          axios.get('/search?keywords=' + this.query).then(response => {
            // 保存内容
            this.musicList = response.data.result.songs;
    
          })
    
          // 清空搜索
          this.query = ''
        },
        // 播放歌曲
        playMusic(musicId) {
          // 获取歌曲url
          axios.get('/song/url?id=' + musicId).then(response => {
            // 保存歌曲url地址
            this.musicUrl = response.data.data[0].url
          })
          // 获取歌曲热门评论
          axios.get('/comment/hot?type=0&id=' + musicId).then(response => {
            // console.log(response)
            // 保存热门评论
            this.hotComments = response.data.hotComments
    
          })
          // 获取歌曲封面
          axios.get('/song/detail?ids=' + musicId).then(response => {
            // console.log(response)
            // 设置封面
            this.coverUrl = response.data.songs[0].al.picUrl
          })
    
        },
        // audio的play事件
        play() {
          this.isPlay = true
          // 清空mv的信息
          this.mvUrl = ''
        },
        // audio的pause事件
        pause() {
          this.isPlay = false
        },
        // 播放mv
        playMv(vid) {
          if (vid) {
            this.showVideo = true;
            // 获取mv信息
            axios.get('/mv/url?id=' + vid).then(response => {
              // console.log(response)
              // 暂停歌曲播放
              this.$refs.audio.pause()
              // 获取mv地址
              this.mvUrl = response.data.data.url
            })
          }
        },
        // 关闭mv界面
        closeMv() {
          this.showVideo = false
          this.$refs.video.pause()
        },
        // 搜索历史记录中的歌曲
        historySearch(history) {
          this.query = history
          this.searchMusic()
          this.showHistory = false;
        }
      },
    
    })

  </script>
</body>

</html>

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm搭建PyTorch环境</title>
    <url>/2020/03/11/PyTorch%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Pytorch是一个开源的python机器学习库，底层由C++实现，Pytorch有两大特征：</p>
<ul>
<li>类似于Numpy的张量计算，可使用GPU加速</li>
<li>基于带自动微分系统的深度学习神经网络</li>
</ul>
<p>相较于其他框架比较容易上手，所以选择搭建一个pytorch的深度学习环境（使用win10+navida mx150，当然了，直接使用docker search-&gt;docker pull是最简单的方法，python的IDE选择pycharm或者jupyter）</p>
<h1 id="1、安装anaconda"><a href="#1、安装anaconda" class="headerlink" title="1、安装anaconda"></a>1、安装anaconda</h1><p>安装软件不用多说，直接去conda官网到download页面，因为conda 37使用过程中经常出现一些问题，这里可以去anaconda的<a href="https://repo.continuum.io/archive/">历史版本库</a>里选择conda 36版本，我这里下载的这个版本号<img src="https://i.loli.net/2020/03/11/bijxQdulm14DXFk.png" alt="微信截图_20200311132631.png"></p>
<p>安装路径脑子里备份一份，后面pycharm集成pytorch环境的时候要用到。这里说明一下，计算机的GPU起到加速作用，检查一下GPU的驱动，检查方法如下：任务管理器-&gt;性能选项卡-&gt;正确显示GPU型号，表示驱动已经正常安装。</p>
<p>anaconda安装完成之后，开始选项里可以看到刚刚安装的anaconda</p>
<p><img src="https://i.loli.net/2020/03/11/ts9zdEfiL52qvWo.png" alt="微信截图_20200311133243.png"></p>
<p>我们有关conda的命令一般是在Prompt里面执行而不是cmd里面。然后我们点击Prompt，进入命令行界面，最前面显示（base），表示anaconda已经安装成功（安装conda就不用单独安装python了，conda本身也集成了很多工具包）。</p>
<h1 id="2、创建pytorch工作区"><a href="#2、创建pytorch工作区" class="headerlink" title="2、创建pytorch工作区"></a>2、创建pytorch工作区</h1><p>在Prompt命令行执行conda create -n pytorch python=3.6(n表示name)，我们就创建了一个pytorch的工作区，当然了，这是一个空的工作区，我们只是命名为pytorch，想使用的话，还得具体安装pytorch需要的一些包。根据提示，执行conda activate pytorch可由当前的base工作区跳转到刚刚创建的pytorch工作区，这时Prompt的前面已经由base变为pytroch.然后需要在当前工作区安装torch，进入<a href="https://pytorch.org/">pytorch官网</a>，然后根据具体配置会给出相应的指令，复制指令到prompt命令行执行，安装相关包。GPU不支持CUDA的话，CUDA选项选择None。至于支不支持，可以去英伟达官网查看，一般的英伟达显卡是支持的，不支持的话，可能是驱动版本过低，更新GPU驱动。<img src="https://i.loli.net/2020/03/11/IisGTXjmoZRQcbM.png" alt="微信截图_20200311134317.png"></p>
<p>命令行执行完成后，在prompt输入python跳转到python的执行界面,然后执行一下import torch发现没有报错，ok，torch已经安装完成，然后输入torch.cuda.is_available()，返回true，表示GPU可以被torch使用。</p>
<p><strong>Q &amp; A：</strong></p>
<ul>
<li><p><strong>anaconda装环境遇到无法定位程序输入点OPENSSL_sk_new_reserve……问题?</strong></p>
<p>查看DLLs里面的dll文件和bin里面的ddl文件日期是否一致，不一致的话，DLLS替换到bin，替换千万备份。这玩意被覆盖了要是出问题，再想找回来，也可以，重装conda就可了。呜呜呜</p>
</li>
<li><p><strong>出现出现CondaHTTPError问题，怎么办？</strong></p>
<p>配置清华镜像，在prompt执行如下操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(D:\Anaconda) C:\Users\Victor\Documents&gt;conda config --add channels https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span></span><br><span class="line"></span><br><span class="line">(D:\Anaconda) C:\Users\Victor\Documents&gt;conda config --add channels https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span></span><br><span class="line"></span><br><span class="line">(D:\Anaconda) C:\Users\Victor\Documents&gt;conda config --add channels https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line"></span><br><span class="line">(D:\Anaconda) C:\Users\Victor\Documents&gt;conda config --set show_channel_urls yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还是不行的话，就找到C盘的.condarc文件，把https改成http，至于文件怎么找，C-&gt;用户-&gt;Victor(你自己的用户名)-&gt;下滑就能找到这个文件。我的文件里是这个样子，仅供参考。<img src="https://i.loli.net/2020/03/11/tVosf9Sxbp5Jq38.png" alt="微信截图_20200311140222.png"></p>
</li>
<li><p><strong>上面都用了还是不行？</strong></p>
<p>重装conda吧熊迪，省时省心</p>
</li>
</ul>
<h1 id="3、pycharm集成pytroch"><a href="#3、pycharm集成pytroch" class="headerlink" title="3、pycharm集成pytroch"></a>3、pycharm集成pytroch</h1><p>上面的步骤都很顺利的话，恭喜你，pytorch环境已经安装成功了，然后去<a href="https://www.jetbrains.com/pycharm/">pycharm</a>官网下载pycharm，一般社区版本就够用，学生可以使用企业邮箱获取一年的认证，亲测有效。</p>
<p>选择新建一个项目，执行如下操作<img src="https://i.loli.net/2020/03/11/p1OWXdMGRe2AxPl.png" alt="微信截图_20200311140957.png"></p>
<p>第一次里面肯定没有pytorch选项，后面的三个点点进去，如下（看清楚路径）：<img src="https://i.loli.net/2020/03/11/QGDgXYSBhCiaqsF.png" alt="微信截图_20200311141134.png"></p>
<p>点击OK，至此已经在pycharm里面集成了pytorch，打开python console试一下，import torch，没错。接下来，搞点数据跑跑叭。当然这也可以使用jupyter，在安装conda的时候已经默认安装了，prompt切换到pytorch工作区，然后conda install nb_conda，安装相关的包，安装完成之后，键入jupyter notebook进入jupyter工作页面，有我们配置的pytorch环境，shift+enter跳转到下一行并执行上一行，接着探索叭！<img src="https://i.loli.net/2020/03/11/ABH6REqUFNLfbsp.png" alt="微信截图_20200311145309.png"></p>
<p>启动tensorboard: tensorboard –logdir=logs(先使用pip命令安装tensorboard和opencv)<img src="https://i.loli.net/2020/03/11/DOEWFiXhgaBeSs7.png" alt="微信截图_20200311175938.png"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合redis</title>
    <url>/2020/03/15/SpringBoot%E6%95%B4%E5%90%88redis/</url>
    <content><![CDATA[<p>关于redis的笔记全部归纳到这篇来了。</p>
<p><a href="https://victor-huihui.gitee.io/2021/03/24/Redis/">Redis汇总</a></p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+PicGo实现图片自动上传</title>
    <url>/2020/03/25/Typora-PicGo%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>我实在太喜欢Typora了。不仅仅因为它腿白貌。。，啊呸，页面清爽美观。而且还支持各种代码格式，写起笔记来视觉很好。但是令人痛心的是，当你想在Typora中插入图片时，OK，你可以插入，但是它本质上是一种弱引用，引用的只是图片的本地路径。所以如果你想分享你的md文件，还需要连带分享一个图片资源文件夹，十分臃肿。在使用PicGo之前，想用hexo渲染md文件，都是先打开图床工具—&gt;上传图片—&gt;复制图片URL—&gt;粘贴进Typora，属实麻烦。自从Typora支持通过PicGo自动上传之后，Typora真的完美了，用起来不要太爽。</p>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>一款开源的<a href="https://molunerfinn.com/PicGo/">图床工具</a>，在github上还发现了作者的一款hexo主题，膜拜大神。(搞开源的哪个不是神仙呢！！！)。界面也是非常清爽。在图床设置中可以配置自己心仪的图床。我用的是阿里云OSS(40G闲着也是闲着)，而且阿里云的速度也是很快的，具体的配置参考超链接文档。<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200325004219.png" alt="image-20200325004218272"></p>
<h2 id="Typora-PicGo"><a href="#Typora-PicGo" class="headerlink" title="Typora+PicGo"></a>Typora+PicGo</h2><p>Typora—&gt;文件—&gt;偏好设置—&gt;图像。</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200325004431.png" alt="image-20200325004429250"></p>
<p>在配置的时候难免会遇到各种各样的问题。</p>
<ul>
<li><p><strong>failed to fetch：</strong></p>
<p>这是我碰到的第一个问题，换了github，又拍云都没法正确上传，找了半天，无果。</p>
</li>
<li><p><strong>{“success”:false}</strong></p>
<p>到这里开始尝试阿里云OSS，报了这个错误，去bucket看了一下，图片是在的，然后复制图片的URL，靠，没权限。去PicGo相册里看了看了一下，也是没法显示。于是肯定是OSS权限问题，修改OSS权限，再上传，完美解决。<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200325005445.png" alt="image-20200325005444453"></p>
</li>
</ul>
<p>于是赶紧体验一下快感写了这篇文章，搞了也有三四个小时吧。成功上传后一种扑面而来的幸福感。但是我转身想到项目前后端还没完全构建出来，甲方那边天天在催，又总是被这些无关紧要的小东西吸引注意力，昨天耍耍docker，今天看甲方用mongodb想学一下，明天学了点vue想学react，一堆论文还没看，现在0:58，今天别睡了QAQ。</p>
<h2 id="上传对比"><a href="#上传对比" class="headerlink" title="上传对比"></a>上传对比</h2><ul>
<li><p><strong>GitHub</strong>、</p>
<p>github的访问速度过慢，不建议使用。</p>
</li>
<li><p><strong>Gitee</strong></p>
<p>PicGo本体是不支持Gitee上传的，好在它提供了插件功能，搜索Gitee，出现两个插件都是可以的。Gitee的速度很快，但是单个仓库的容量有限制，有些图片还是比较大的，很快就会存满，可以新建一个仓库然后重新配置一下PicGo，但是这种提心吊胆怕存满的心情属实不好受。<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200325124224.png" alt="image-20200325124222803"></p>
</li>
<li><p><strong>阿里云OSS</strong></p>
<p>阿里云OSS的速度也很快，我最开始担心的是OSS有期限，要是过期了怎么办，后来觉得这些担心很多余，因为OSS的价格很便宜，40G一年也就8块钱。对各位老板来说，额，还不如一根头发值钱。。。。</p>
</li>
<li><p><strong>腾讯云对象存储</strong></p>
<p>这玩意和阿里云OSS是一样的，注册实名认证送了50G半年，选择腾讯还是阿里看各位心情。(阿里云OSS是购买ECS送了40G一年，不用白不用咯)</p>
</li>
<li><p>七牛云，又拍云，smms等等，这些我没试，可以试试。</p>
</li>
</ul>
<p>总结起来，就是github和gitee无期限限制，但是容量有限。第三方对象存储资源包有期限限制，但是容量大不免费。各有利弊，对于如何选择的问题，我卖两根头发选择了阿里云OSS！！！！</p>
]]></content>
      <categories>
        <category>Bug合集</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器的备份与迁移</title>
    <url>/2020/03/05/docker%E5%AE%B9%E5%99%A8%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="备份容器"><a href="#备份容器" class="headerlink" title="备份容器"></a>备份容器</h2><p>首先，为了备份Docker中的容器，我们会想看看我们想要备份的容器列表。要达成该目的，我们需要在我们运行着Docker引擎，并已创建了容器的Linux机器中运行 docker ps 命令。</p>
<p>在此之后，我们要选择我们想要备份的容器，然后去创建该容器的快照。我们可以使用 docker commit 命令来创建快照。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker commit -p <span class="number">37</span>br3874 container-backup</span><br></pre></td></tr></table></figure>

<p>该命令会生成一个作为Docker镜像的容器快照,上面做的快照已经作为Docker镜像保存了。现在，为了备份该快照，我们有两个选择，一个是我们可以登录进Docker注册中心，并推送该镜像；另一个是我们可以将Docker镜像打包成tar包备份，以供今后使用。想要将此镜像保存在本地机器中，以供日后使用，那么我们可以将其作为tar包备份。要完成该操作，我们需要运行以下 <code>docker save</code> 命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker save -o ~/container-backup.tar container-backup</span><br></pre></td></tr></table></figure>

<h2 id="恢复容器"><a href="#恢复容器" class="headerlink" title="恢复容器"></a>恢复容器</h2><p>接下来，在我们成功备份了我们的Docker容器后，我们现在来恢复这些制作了Docker镜像快照的容器。如果我们已经在注册中心推送了这些Docker镜像，那么我们仅仅需要把那个Docker镜像拖回并直接运行即可</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker load -i ~/container-backup.tar</span><br></pre></td></tr></table></figure>

<h2 id="迁移docker容器"><a href="#迁移docker容器" class="headerlink" title="迁移docker容器"></a>迁移docker容器</h2><p>迁移容器同时涉及到了上面两个操作，备份和恢复。我们可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，首先我们将把容器备份为Docker镜像快照。然后，该Docker镜像或者是被推送到了Docker注册中心，或者被作为tar包文件保存到了本地。如果我们将镜像推送到了Docker注册中心，我们简单地从任何我们想要的机器上使用 docker run 命令来恢复并运行该容器。但是，如果我们将镜像打包成tar包备份到了本地，我们只需要拷贝或移动该镜像到我们想要的机器上，加载该镜像并运行需要的容器即可。</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>github actions托管gitee pages</title>
    <url>/2021/04/09/github-actions%E6%89%98%E7%AE%A1gitee-pages%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>自从全球最大的同性交友网站–github被墙了之后，加之国内访问速度慢，把hexo静态网站托管到gitee就成了不二之选。问题是，gitee pages不支持自动更新，需要开通pro版本才行，花这钱就跟花钱开百度网盘会员一样不情愿，怎么办呢？—-<strong>github actions。</strong></p>
<h1 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h1><p>使用github actions可以参考这个<a href="https://gitee.com/yanglbme/gitee-pages-action">开源项目</a></p>
<p>现在问题换到hexo身上，在我们对post文件进行修改之后，一般需要执行<code>hexo c</code>清理缓存(不是必须)，<code>hexo g</code>和<code>hexo d</code>。在使用github actions的时候，需要在根目录添加文件<code>.github/workflows/test.yml</code>来定制actions的流程，但是在执行<code>hexo d</code>的时候，会将这个文件删掉，导致actions失效。我们的问题就是怎么保证.github文件夹一定存在于根目录。而根目录是hexo 托管的，我的解决办法是这样的：</p>
<ul>
<li><p>把.github文件夹复制到hexo根目录的.deploy_git</p>
<p>如果不添加进来，你会发现，即使你把.github文件夹放到public下，执行deploy命令，hexo也不会托管他。添加进来就可以保证，只要public存在这个文件夹，就可以deploy到远程的master上。</p>
</li>
<li><p>写脚本一键更新</p>
<p>hexo的流程是这样的，执行hexo clean，会把整个public文件夹删除。然后执行hexo g，会渲染source文件夹里面的md文件成html页面，也就是我们在blog看到的页面。执行hexo d，更新到github。</p>
<p>所以我们的脚本顺序是这样的：</p>
<ul>
<li><p>进入到hexo根目录</p>
</li>
<li><p>执行<code>hexo clean</code>命令</p>
</li>
<li><p>执行<code>hexo g</code>命令</p>
</li>
<li><p>复制根目录的<code>.github</code>文件夹到<code>public</code>内。</p>
<p>这里需要我们提前把<code>.github</code>文件夹复制到根目录，放到这里是不会消失的。</p>
</li>
<li><p>执行<code>hexo deploy</code>命令</p>
</li>
<li><p>完事</p>
</li>
</ul>
</li>
</ul>
<p>所以最后我们更新博客的流程是这样的，双击bat文件，完事。</p>
<p>这里是我的bat文件，仅供参考:</p>
<p>CMD.bat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;k &quot;cd &#x2F;d D:\development\myblog&amp;&amp;hexo clean &amp;&amp;hexo g &amp;&amp; xcopy D:\development\myblog\.github D:\development\myblog\public\.github\ &#x2F;e &amp;&amp; hexo d&quot;</span><br></pre></td></tr></table></figure>

<p>最后你会发现：</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210326153932457.png" alt="image-20210326153932457"></p>
<p>爽呆！！！！</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo如何跳过渲染</title>
    <url>/2020/03/05/hexo%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>hexo是把markdown文件渲染成静态页面，然后展示出来。但是有些页面我们不需要hexo的渲染，比如在个人介绍中，我们想把自己的照片调整宽度，做成圆角的形式。这种改怎么做呢？</p>
<p>我的第一个想法是，先md写好文档，执行hexo g-&gt;hexo d去生成远程仓库的html页面。然后去远程仓库修改html代码。事实上这样确实是可行的，但是问题又来了。我们在远程仓库修改渲染过的html文件，但是当下一次我们要提交新的修改时，页面又会被重新渲染，造成麻烦。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>正确的做法是，在不需要渲染的页面的头部，加上layout: false属性，这时候hexo不会为我们渲染该页面。问题还有，，，hexo不帮我们渲染页面，我们就需要自己写html页面，这样还是比较浪费时间。我的做法是，可以先让hexo帮我们渲染页面，然后去远程仓库把渲染好的html代码复制粘贴过来。ok，完美解决。不知道还有没有更好的方法了。<strong>注意要把html代码写在和之间让markdown可以正确识别。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-03-04 22:12:44</span><br><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;</span><br><span class="line">****</span><br><span class="line">****</span><br><span class="line">html代码</span><br><span class="line">****</span><br><span class="line">****</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210325214020150.png" alt="image-20210325214020150"></p>
]]></content>
      <categories>
        <category>Bug合集</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>OSS文件管理</title>
    <url>/2020/03/18/java%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%AD%98%E5%8F%96/</url>
    <content><![CDATA[<blockquote>
<p>上一回说到贫穷的程序员同学话60多块买了一年的阿里云低配云主机，然后偶然发现是赠送了一年的OSS的，看了一下有40G，对于日常的开发来说，还是很够用的，你会不会觉得，存储的地方多了，百度网盘上千个G，为啥选择OSS？就网盘那速度先不吐槽，阿里云提供的开发接口相信你会爱上的。</p>
</blockquote>
<p>OSS是阿里云提供的对象存储，说白了对象存储就是你啥都可以往里面放，安全指数达到99.99999%(别数了，7个9)，可以说相当安全了。具体的<a href="https://help.aliyun.com/product/31815.html?spm=a2c4g.750001.list.22.64277b13kElgYU">帮助文档</a>看这里。OSS提供了java开发的SDK，使用起来不用不要太爽啊。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="1-添加pom依赖"><a href="#1-添加pom依赖" class="headerlink" title="1.添加pom依赖"></a>1.添加pom依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-创建存储空间"><a href="#2-创建存储空间" class="headerlink" title="2.创建存储空间"></a>2.创建存储空间</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">String endpoint = <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">String accessKeyId = <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>;</span><br><span class="line">String accessKeySecret = <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>;</span><br><span class="line">String bucketName = <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。允许多个可以并发使用</span></span><br><span class="line">OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建存储空间。</span></span><br><span class="line">ossClient.createBucket(bucketName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭OSSClient。</span></span><br><span class="line">ossClient.shutdown();</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<h3 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3.文件上传"></a>3.文件上传</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">String endpoint = <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">String accessKeyId = <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>;</span><br><span class="line">String accessKeySecret = <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>;</span><br><span class="line">String bucketName = <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;yourObjectName&gt;上传文件到OSS时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。</span></span><br><span class="line">String objectName = <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传内容到指定的存储空间（bucketName）并保存为指定的文件名称（objectName）。</span></span><br><span class="line">String content = <span class="string">&quot;Hello OSS&quot;</span>;</span><br><span class="line">ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> ByteArrayInputStream(content.getBytes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭OSSClient。</span></span><br><span class="line">ossClient.shutdown();</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<h3 id="4-文件下载"><a href="#4-文件下载" class="headerlink" title="4.文件下载"></a>4.文件下载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">String endpoint = <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">String accessKeyId = <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>;</span><br><span class="line">String accessKeySecret = <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>;</span><br><span class="line">String bucketName = <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;yourObjectName&gt;从OSS下载文件时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。</span></span><br><span class="line">String objectName = <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用ossClient.getObject返回一个OSSObject实例，该实例包含文件内容及文件元信息。</span></span><br><span class="line">OSSObject ossObject = ossClient.getObject(bucketName, objectName);</span><br><span class="line"><span class="comment">// 调用ossObject.getObjectContent获取文件输入流，可读取此输入流获取其内容。</span></span><br><span class="line">InputStream content = ossObject.getObjectContent();</span><br><span class="line"><span class="keyword">if</span> (content != <span class="keyword">null</span>) &#123;</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(content));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String line = reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (line == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据读取完成后，获取的流必须关闭，否则会造成连接泄漏，导致请求无连接可用，程序无法正常工作。</span></span><br><span class="line">    content.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭OSSClient。</span></span><br><span class="line">ossClient.shutdown();</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<h3 id="5-列举文件"><a href="#5-列举文件" class="headerlink" title="5.列举文件"></a>5.列举文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">String endpoint = <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">String accessKeyId = <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>;</span><br><span class="line">String accessKeySecret = <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>;</span><br><span class="line">String bucketName = <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ossClient.listObjects返回ObjectListing实例，包含此次listObject请求的返回结果。</span></span><br><span class="line">ObjectListing objectListing = ossClient.listObjects(bucketName);</span><br><span class="line"><span class="comment">// objectListing.getObjectSummaries获取所有文件的描述信息。</span></span><br><span class="line"><span class="keyword">for</span> (OSSObjectSummary objectSummary : objectListing.getObjectSummaries()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot; - &quot;</span> + objectSummary.getKey() + <span class="string">&quot;  &quot;</span> +</span><br><span class="line">            <span class="string">&quot;(size = &quot;</span> + objectSummary.getSize() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭OSSClient。</span></span><br><span class="line">ossClient.shutdown();</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<h3 id="6-文件删除"><a href="#6-文件删除" class="headerlink" title="6.文件删除"></a>6.文件删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">String endpoint = <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">String accessKeyId = <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>;</span><br><span class="line">String accessKeySecret = <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>;</span><br><span class="line">String bucketName = <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;yourObjectName&gt;表示删除OSS文件时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。</span></span><br><span class="line">String objectName = <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件。</span></span><br><span class="line">ossClient.deleteObject(bucketName, objectName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭OSSClient。</span></span><br><span class="line">ossClient.shutdown();</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<h3 id="7-更多API参见文档"><a href="#7-更多API参见文档" class="headerlink" title="7.更多API参见文档"></a>7.更多API参见文档</h3><p>反正基本媒体相关的操作，阿里云的OSS是很够用的。快点跑去试试叭！！！！</p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>tidb contributor</title>
    <url>/2021/04/09/tidb-contributor%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>近年来国产数据库进行的如火如荼，目前做的比较好的一个是PingCAP的TIDB，一个是阿里的OceanBase。</p>
<p>我对数据库的理解谈不上深刻，但是我认为，数据库一定要是个产品，有企业愿意用，这样才能实现他的价值和有动力迭代。不同的是，OB走的是闭源路线，在支撑内部电商业务的同时，商业化也做的不错。而TIDB走的是开源路线。</p>
<p>为什么开源，引用PingCAP的一句话：</p>
<blockquote>
<p>对一个技术型公司来说，最宝贵的资产其实是人，对一个开源项目来说，最核心的资产是一个活跃的开源社区以及他人对这个项目的认可。</p>
</blockquote>
<p>这正是开源的意义，我也做过一部分开源工作，而TIDB正是这一切的开始。</p>
<p>本科时代，由于项目的规模有限，基本没机会参与到<code>协同开发</code>这一步骤，每个人单打独斗，你写的是图书管理系统，我写的是教务管理系统，这种系统的代码量靠一个人是可以搞定的，所以对于划水选手而言，也就懒得去探索github，了解git。但是当面临团队开发的时候，git便是你逃避不了的话题。可以说，在社区做贡献的同时，也让我学习到这些知识，后来我发表了一篇小论文，就是基于github提供的用户历史数据做推荐，当然这个工作更偏向于数据分析的工作，但是也是tidb的那次经历给的启发。</p>
<p>接下来来谈谈这个contribute–<strong>表达式向量化</strong></p>
<p>TIDB为了鼓励参与，在很简单的向量化这里留下了很多口子，对于小白来说非常友好。</p>
<h2 id="如何访问和修改向量"><a href="#如何访问和修改向量" class="headerlink" title="如何访问和修改向量"></a>如何访问和修改向量</h2><p>在TIDB中有变长类型和定长类型，有如下读写方式：</p>
<ul>
<li>定长类型(int64为例)<ul>
<li><code>ResizeInt64s(size, isNull)</code>：预分配 size 个元素的空间，并把所有位置的 <code>null</code> 标记都设置为 <code>isNull</code>；</li>
<li><code>Int64s()</code>：返回一个 <code>[]int64</code> 的 Slice，用于直接读写数据；</li>
<li><code>SetNull(rowID, isNull)</code>：标记第 <code>rowID</code> 行为 <code>isNull</code>。</li>
</ul>
</li>
<li>变长类型(String为例)<ul>
<li><code>ReserveString(size)</code>：预估 size 个元素的空间，并预先分配内存；</li>
<li><code>AppendNull()</code>：追加一个 <code>null</code> 到向量末尾；</li>
<li><code>GetString(rowID)</code>：读取下标为 <code>rowID</code> 的 string 数据。</li>
</ul>
</li>
</ul>
<h2 id="向量表达式计算框架"><a href="#向量表达式计算框架" class="headerlink" title="向量表达式计算框架"></a>向量表达式计算框架</h2><p>向量化的计算接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vectorized() bool</span><br><span class="line">vecEvalXType(input *Chunk, result *Column) error</span><br></pre></td></tr></table></figure>

<ul>
<li>xType：类型</li>
<li>input：输入数据，类型为<code>\*Chunk</code></li>
<li><code>result</code>存放结果数据。</li>
</ul>
<p>对于任意表达式，只有在其中所有的函数都支持向量化后，才认为表达式支持向量化。</p>
<h2 id="为函数实现向量化接口"><a href="#为函数实现向量化接口" class="headerlink" title="为函数实现向量化接口"></a>为函数实现向量化接口</h2><p>向量化需要实现<code>vecEvalXType()</code>和<code>vectorized</code>接口</p>
<ul>
<li>在 <code>vectorized()</code> 接口中返回 <code>true</code> ，表示该函数已经实现向量化计算；</li>
<li>在 <code>vecEvalXType()</code> 实现此函数的计算逻辑。</li>
</ul>
<p>向量化的代码存放在_vec.go中，文件头加上licence说明。</p>
<p>以下是代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *builtinMicroSecondSig)</span> <span class="title">vectorized</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *builtinMicroSecondSig)</span> <span class="title">vecEvalInt</span><span class="params">(input *chunk.Chunk, result *chunk.Column)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;not implemented&quot;</span>)</span><br><span class="line">	n := input.NumRows()</span><br><span class="line">	buf, err := b.bufAllocator.get(types.ETDuration, n)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> b.bufAllocator.put(buf)</span><br><span class="line">	<span class="keyword">if</span> err = b.args[<span class="number">0</span>].VecEvalDuration(b.ctx, input, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result.ResizeInt64(n, <span class="literal">false</span>)</span><br><span class="line">	result.MergeNulls(buf)</span><br><span class="line">	i64s := result.Int64s()</span><br><span class="line">	ds := buf.GoDurations()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> result.IsNull(i) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		i64s[i] = <span class="keyword">int64</span>((ds[i] % time.Second) / time.Microsecond)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/pingcap/tidb/pull/13482">PR链接</a></p>
<p>就是这么简单，最后还送了一个马克杯，和一个勋章。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210407171511208.png" alt="image-20210407171511208"></p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>一年69.86的ECS来了！！</title>
    <url>/2020/03/17/%E4%B8%80%E5%B9%B469-86%E7%9A%84ECS%E6%9D%A5%E4%BA%86%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="贫穷一定是故事的开端"><a href="#贫穷一定是故事的开端" class="headerlink" title="贫穷一定是故事的开端"></a>贫穷一定是故事的开端</h2><p><a href="https://www.aliyun.com/activity/daily/cloud">购买连接</a></p>
<p>一直想鼓捣个自己的ECS耍耍，但是学生专享除去优惠券一年还要90块。阿里云也退出推出暑期在家计划，每天八点学生用户可以抢半年的免费ECS，很遗憾，资深夜猫子每天的闹钟都听不到，又舍不得那点钱，于是一拖再拖(希望有富婆可以看到程序员同学的贫穷QAQ!!)，今天登陆阿里云的主页，看到如下信息：<img src="https://s1.ax1x.com/2020/03/17/8diSu4.png" alt="8diSu4.png"></p>
<p>一年69.86，这虽然比一年90块的学生机便宜不了几块钱，但是冲着不用优惠券和贫穷的态度，果断入手(虽然配置不咋地，要啥自行车啊，买来瞎鼓捣呗)。这里选择的是centos系统，也可以选择windows server。</p>
<h2 id="上手体验"><a href="#上手体验" class="headerlink" title="上手体验"></a>上手体验</h2><p>打开阿里云官网进入控制台，点击云服务器ECS，就可以看到我们刚刚购买的主机了：<img src="https://s1.ax1x.com/2020/03/17/8dF7Yq.png" alt="8dF7Yq.png"></p>
<p>点击下方的实例ID，就进入实例实例详情页：<img src="https://i.loli.net/2020/03/21/yaMXPNxf7ipuVGO.png" alt="image-20200317225614113.png"></p>
<p>这里可以看到关于本实例的一些配置信息，也可以在本页面远程连接到这台ECS。因为一开始是没有密码的，点击更多重置实例密码，然后就可以点击远程连接了，连接之后便进入到这台服务器。当然也可以使用xshell，PuTTY这些工具进行连接，方法都是一样的，这里的公网IP地址，就是我们会经常使用到的地址，也可以购买一个域名进行映射，普通的域名很便宜，我买了一个hhzhu.top一年9块钱，但是国内的需要备案等等操作，很麻烦。购买域名也很简单：</p>
<p><a href="https://imgchr.com/i/8dAyxf"><img src="https://s1.ax1x.com/2020/03/17/8dAyxf.png" alt="8dAyxf.png"></a></p>
<h2 id="安装宝塔linux面板"><a href="#安装宝塔linux面板" class="headerlink" title="安装宝塔linux面板"></a>安装宝塔linux面板</h2><p>接下来安装宝塔LINUX面板简化运维操作，连接服务器后，输入如下命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure>

<p>根据提示操作即可安装宝塔linux面板，安装完成后，会给你一个访问地址、账户和密码(后续可以修改)，打开网址输入账号密码就进入linux面板，这里需要放行一些端口，具体的<a href="https://www.bt.cn/bbs/thread-2897-1-1.html">放行方法</a>：<a href="https://imgchr.com/i/8dE7tA"><img src="https://s1.ax1x.com/2020/03/17/8dE7tA.png" alt="8dE7tA.png"></a></p>
<p>你可以在这里傻瓜式的安装和部署你的网站。我做的第一件事就是赶紧安装一个mysql，替换掉原来部署到学校服务器每次用都需要连接vpn的数据库，我和我的小伙伴们都爽呆了。<a href="https://imgchr.com/i/8deykQ"><img src="https://s1.ax1x.com/2020/03/17/8deykQ.png" alt="8deykQ.png"></a></p>
<p>接下来就可以直接在宝塔面板上运行一些运维操作，发布自己的网站什么的，需要什么工具再自行下载就OK。</p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
  </entry>
  <entry>
    <title>中医基础理论-绪论</title>
    <url>/2020/04/12/%E4%B8%AD%E5%8C%BB%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>什么是中医学？中医学的学科属性？</p>
<ul>
<li><strong>中医基础理论的组成部分</strong></li>
<li><strong>中医理论体系的发展简史</strong></li>
<li><strong>中医理论体系的主要特点</strong></li>
</ul>
<h2 id="1、中医基础理论的组成部分"><a href="#1、中医基础理论的组成部分" class="headerlink" title="1、中医基础理论的组成部分"></a>1、中医基础理论的组成部分</h2><p><strong>中医学：</strong>是发祥于中国古代，<em>建立在中国传统文化基础上</em>，以<em>整体观念</em>为知道思想，以脏腑经络的生理病理为基础，以辩证论治为诊疗特点，研究人体生命、健康、疾病的学科。(易学难精，因为文化二字)。</p>
<p>西医看微观，中医看整体。西医治病，中医也治病，中西更强调因人而异，量体裁衣。</p>
<p><strong>中医基础理论：</strong></p>
<ul>
<li>中医学的哲学基础</li>
<li><strong>中医对正常人体的认识</strong></li>
<li><strong>中医对疾病的认识</strong></li>
<li>中医养生和诊疗疾病的原则</li>
</ul>
<p>《中医学大辞典》</p>
<p><strong>中医学的学科属性：</strong></p>
<ul>
<li>自然科学与社会科学的交叉性</li>
<li>基础学科与应用学科的双重性</li>
<li>东方传统文化的综合性</li>
<li>科学、仁(天地良心)术和技艺的融合性</li>
</ul>
<p>道理：</p>
<ul>
<li>道：道可道非常道，两层含义。一是本质，二是规律。</li>
<li>理：具体的东西。</li>
</ul>
<p>医道：医学，医技(术)。西医就是医技，因为他们并不追求道。</p>
<h2 id="2、中医理论体系的形成与发展"><a href="#2、中医理论体系的形成与发展" class="headerlink" title="2、中医理论体系的形成与发展"></a>2、中医理论体系的形成与发展</h2><h3 id="中医理论体系的形成："><a href="#中医理论体系的形成：" class="headerlink" title="中医理论体系的形成："></a>中医理论体系的形成：</h3><ul>
<li>医药知识的积累</li>
<li>对人体生命现象和自然现象的观察<ul>
<li>直接观察法(解剖)</li>
<li>整体观察法(没等到显微镜的发明)</li>
</ul>
</li>
<li>有利的社会文化背景</li>
<li>古代哲学思想对医学的渗透</li>
</ul>
<h3 id="中医理论体系的确立"><a href="#中医理论体系的确立" class="headerlink" title="中医理论体系的确立"></a>中医理论体系的确立</h3><p>**黄帝内经:**分《灵枢》《素问》两部分，为古代医学家托轩辕黄帝名之作，为医学家、医学理论家联合创作，一般认为形成于战国、秦汉时期。现存最早中医学专著，标志着中医理论体系的建立。</p>
<p><strong>扁鹊：</strong>战国时期著名医学家，相传中医典籍《难经》(《难经》不难，《易经》不易)为其所著。补内径不足。中医像大哥二哥，西医像扁鹊。</p>
<p><strong>张仲景：</strong>东汉末著名医学家，“医圣”，撰《伤寒杂病论》。后世整理成《伤寒论》《金匮要略》。这是中国第一部从理论到时间、确立辩证论治法则的医学专著。(别说是最高水平)</p>
<p><strong>华佗：</strong>吃亏，没书啊</p>
<p><strong>神农本草经：</strong>又名《神农本草》，撰人不详，“神农”为托名，为中医药理理论依稀的形成奠定了基础</p>
<blockquote>
<p><strong>病、证、症</strong></p>
</blockquote>
<h3 id="中医学理论体系的发展"><a href="#中医学理论体系的发展" class="headerlink" title="中医学理论体系的发展"></a>中医学理论体系的发展</h3><p><strong>脉经：</strong>魏晋之际的著名医学家、医术编纂家王叔和。撰写了第一部脉学专著<strong>《脉经》</strong></p>
<p><strong>针灸甲乙经：</strong>晋代皇普谧编撰，是中国现存最早的一步针灸学专著。10卷，南北朝时期改为12卷。</p>
<p><strong>诸病源候论：</strong>隋朝巢元方所撰，第一部病因病机症候学专著</p>
<p><strong>魏晋隋唐：</strong>丰富实践时期。</p>
<p><strong>宋金元：</strong>争鸣突破时期。三因极–病症方论：宋代陈无择撰，中医综合性专著。金元四大家：</p>
<ul>
<li><p>刘完素：金代医学家，属于“寒凉派”(王老吉)</p>
</li>
<li><p>李东垣：“易水派”，牵扯五行学说</p>
</li>
<li><p>张从正：“攻邪派”。中医的邪一般指病因</p>
</li>
<li><p>朱震亨：“养阴派”。阴阳学说(六味地黄丸，只适合肾阴虚，肾阳虚的话越吃越糟糕奥)</p>
<p><strong>门户这件事，还是不好的</strong>。</p>
</li>
</ul>
<p><strong>明清时期：</strong>综合汇通，深化发展时期。</p>
<ul>
<li>明：王肯堂《证治准绳》</li>
<li>清：吴谦《医宗金鉴》、陈梦雷《古今图书集成-医部全录》</li>
<li><strong>温病论的创立：</strong><ul>
<li>明：吴又可《瘟疫论》—“戾气说”</li>
<li>清：叶天士《温热论》–“卫气营血辩证”。吴鞠通《温病条辨》—“三焦辨证”。薛生白《温热条辨》</li>
</ul>
</li>
<li>《医林改错》：清代王清任撰，中医脏象著作(解剖)。活血化瘀</li>
</ul>
<p><strong>现代和近代：</strong>一言难尽</p>
<blockquote>
<p><strong>望</strong>而知之谓之神</p>
<p><strong>闻</strong>而止之为之圣</p>
<p><strong>问</strong>而知之谓之工</p>
<p><strong>切</strong>而知之谓之巧</p>
</blockquote>
<h3 id="下节是阴阳学说。"><a href="#下节是阴阳学说。" class="headerlink" title="下节是阴阳学说。"></a>下节是阴阳学说。</h3>]]></content>
      <categories>
        <category>中医理论基础</category>
      </categories>
      <tags>
        <tag>中医</tag>
      </tags>
  </entry>
  <entry>
    <title>中医学哲学基础-五行学说</title>
    <url>/2020/04/15/%E4%B8%AD%E5%8C%BB%E5%AD%A6%E5%93%B2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E4%BA%94%E8%A1%8C%E5%AD%A6%E8%AF%B4/</url>
    <content><![CDATA[<blockquote>
<p><strong>五行学说：</strong>以木、火、土、金、水为分类标志的五大体系及其相互之间的关系的一门学说。</p>
</blockquote>
<p><strong>五行各自的特征：</strong></p>
<ul>
<li><u>木曰曲直</u>：生长、生发、条达、舒畅(木形人—高瘦、面色青、劳心者、头发少)</li>
<li><u>火曰炎上</u>：温热、上升、光明</li>
<li><u>土曰稼穑</u>：生化、承载、收纳</li>
<li><u>金曰从革</u>：沉降、肃杀、收敛</li>
<li><u>水曰润下</u>：滋润、寒凉、下行、(闭藏)</li>
</ul>
<p><strong>事物五行属性的归类：</strong></p>
<ul>
<li>取象比类法</li>
</ul>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200416230843.png" alt="image-20200416230834027"></p>
<ul>
<li><p>推演络绎法</p>
<p><strong>五行和五脏</strong></p>
<ul>
<li>木—&gt;肝(无形解释无形，炙热解释炙热)</li>
<li>火—&gt;心</li>
<li>土—&gt;脾</li>
<li>金—&gt;肺</li>
<li>水—&gt;肾(没有什么争议)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>中医理论基础</category>
      </categories>
      <tags>
        <tag>中医</tag>
      </tags>
  </entry>
  <entry>
    <title>中医学哲学基础-阴阳学说</title>
    <url>/2020/04/12/%E4%B8%AD%E5%8C%BB%E5%AD%A6%E5%93%B2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E9%98%B4%E9%98%B3%E5%AD%A6%E8%AF%B4/</url>
    <content><![CDATA[<blockquote>
<p>哲学是讨论自然社会最一般规律的学问</p>
</blockquote>
<p>中国古代没有哲学的概念，实际就是<strong>道</strong>(参考《道德经》)。</p>
<p>中医学的哲学基础：精气学说(抽象)，阴阳学说(争议小)，五行学说(争议大)</p>
<h1 id="阴阳学说"><a href="#阴阳学说" class="headerlink" title="阴阳学说"></a>阴阳学说</h1><p><strong>朴素的辩证唯物想和学</strong></p>
<p>事物的阴阳属性：</p>
<blockquote>
<p>阳：上外左南天昼春夏温热干轻清明</p>
<p>阴：下内右北地夜秋冬寒凉湿重浊暗</p>
</blockquote>
<p>阴：下内右北地夜秋冬寒凉湿重浊暗</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200412213220.png" alt="无标题"></p>
<p>南方炎热，日照时间长，阳的特征很明显。北方日照时间短，寒冷的特征属阴。南北有了，如何定左右？中国推崇坐北朝南，左手是东边，右手是西边。东边是太阳升起的地方，阳主升。西边太阳降落，阴主降。</p>
<blockquote>
<p>阳：化气    上升    运动    兴奋    亢进</p>
<p>阴：成形    下降    静止    抑制    衰退</p>
</blockquote>
<p>阳的褒义词多，阴的贬义词对。古代崇阳抑阴，《易经》比较明显–&gt;天行健，君子以自强不息。人是成形的，属阴浊，生老病死。怎样减少疾病？变成无形的不可行，化无用为有用，体内代谢好了，容易化无用为有用。代谢不好，无用的化不了，emmm，一块一块的东西就长出来了。有些不属阳不属阴的呢？太极的鱼眼，阳中有阴，阴中有阳。</p>
<p><strong>阴阳：</strong>是对自然界中相互关联的事物和现象对立双方属性的概括。(这里比较像马哲的矛盾观，但是矛盾不强调好坏，只强调对立，所以阴阳学说和主流哲学有很多相似之处、、、个人理解)，阴阳属性有绝对性。太极按照坐标划分(1,0)傍晚,(0,1)中午,(-1,0)早上,(-1,-1)夜晚(这是根据阴阳来划分的，参照太极)，那从早上到中午属于阳中之阳，中午到晚上属于阳中之阴，傍晚到夜晚属阴中之阴，晚上到早上属阴中之阳。阴阳有参照性。阴阳真正上升到理论，最早使用符号：</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200412225922.png" alt="image-20200412225920995"></p>
<p>三个阴阳组合就是<strong>八卦</strong>，六个就是<strong>六十四卦。</strong></p>
<h2 id="《周易》"><a href="#《周易》" class="headerlink" title="《周易》"></a>《周易》</h2><p>《易经》一般是《周易》和《易传》。</p>
<p>说是封建迷信，就是算卦的。字数没多少，难在符号系统。《易传》为孔子所撰，来解释《周易》的。孔子有句话：子不语怪、力、乱、神。所以孔子在解释《周易》的时候更多解释里面的哲学观念。首先《周易》探讨的是阴阳，天地之道，所以被道家奉为经典。孔子又参与，儒家也奉为经典。所以《周易》是<strong>群经之首。</strong>为啥从来没学过，emmm。</p>
<p><strong>太极生两仪 两仪生四象 四象生八卦</strong></p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200412231347.png" alt="image-20200412231345899"></p>
<h2 id="阴阳学说的基本内容"><a href="#阴阳学说的基本内容" class="headerlink" title="阴阳学说的基本内容"></a>阴阳学说的基本内容</h2><p><strong>阴阳的对立制约：</strong></p>
<p>属性相反的阴阳双方在一个统一整体中互相斗争、互相制约和互相排斥。</p>
<p>阴阳是平衡的，但是是一种动态平衡。就像太极两仪图的此消彼长。</p>
<p><strong>阴阳的互根互用：</strong></p>
<ul>
<li><p>互根：阴阳相互依存，互为根本</p>
</li>
<li><p>互用：某些范畴的阴阳具有相互滋生、促进与助长的关系。‘</p>
<blockquote>
<p>阴在内，阳之守也，阳在外，阴之使也</p>
<p>​                                                        —【素问 阴阳应象大论】</p>
</blockquote>
</li>
</ul>
<p><strong>阴阳消长：</strong></p>
<ul>
<li><p>阴阳互为消长：此长彼消，此消彼长</p>
</li>
<li><p>阴阳皆消皆长：此长彼长，此消彼消</p>
</li>
<li><p>真正的太极图</p>
</li>
</ul>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200412234238.png" alt="image-20200412234237469"></p>
<p><strong>阴阳转化(质变)：</strong></p>
<p>事物的阴阳属性，在一定条件下，可以向相反的方向转化。(物极必反)</p>
<p><strong>阴阳的自和与平衡：</strong></p>
<p>舒服不养生，养生不舒服。因为人是自然的人。开空调是会舒服，但是适应环境的能力就会下降。阳主动，阴主静。人是动物，所以得动起来啊乖乖。</p>
<ul>
<li>自和：阴阳双方自动维持和回复其协调平衡状态的能力与趋势</li>
<li>平衡：阴阳双方在相互作用中大体维持消长动态平衡。</li>
</ul>
<p><strong>阴阳交感：</strong></p>
<p>阴阳二气在运动中相互感应而交合的过程。来源于周易，左为泰，右为否，泰为通畅，否为不通。阴阳交感是万物化生的根本条件。</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200413000321.png" alt="image-20200413000320407"></p>
<p><strong>阴阳互藏：</strong></p>
<blockquote>
<p>地气上为云，天气下为雨</p>
</blockquote>
<ul>
<li>交感的动力与根源</li>
<li>互根互用的基础</li>
<li>阴阳消长与转化的根据</li>
</ul>
<h2 id="阴阳学说在中医学中的应用"><a href="#阴阳学说在中医学中的应用" class="headerlink" title="阴阳学说在中医学中的应用"></a>阴阳学说在中医学中的应用</h2><h3 id="1、阐析人体的病理变化："><a href="#1、阐析人体的病理变化：" class="headerlink" title="1、阐析人体的病理变化："></a>1、阐析人体的病理变化：</h3><p><strong>说明人体的组织结构</strong></p>
<blockquote>
<p>阳：上    体表    背    腑    四肢外侧    三阳经    督脉    气    皮肉</p>
<p>阴：下    体内    腹    脏    四肢内侧    三阴经    任脉    血    筋骨</p>
</blockquote>
<p><strong>概括人体的生理功能：</strong></p>
<ul>
<li>病因(邪气)<ul>
<li>阴</li>
<li>阳</li>
</ul>
</li>
<li>人体(正气)<ul>
<li>阴</li>
<li>阳</li>
</ul>
</li>
</ul>
<p>疾病就是病因和人体的互动。</p>
<p><strong>阴阳失调：</strong></p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200413005022.png" alt="image-20200413004939747"></p>
<ul>
<li><strong>阴阳偏盛</strong></li>
</ul>
<p>阳多则热，<strong>实热症：</strong>口感、小便黄、大便干、舌红、苔红</p>
<p>阴胜则寒，<strong>实寒证</strong>：恶寒/畏寒、面色白、舌淡、苔白、脉迟。分泌物，排泄物，清稀。</p>
<ul>
<li><strong>阴阳偏衰：</strong></li>
</ul>
<p>阴虚则热：<strong>虚热证：</strong>低热、五心烦热、潮热、颧红、面色潮红、舌红、少苔(少津)、脉细数、口干、小便短、大便干。</p>
<p>阳虚则寒：<strong>虚寒证：</strong>畏寒、局部寒冷、面色白、舌淡、苔白、脉迟、精神乏力、少气懒言</p>
<h3 id="2、用于疾病诊断"><a href="#2、用于疾病诊断" class="headerlink" title="2、用于疾病诊断"></a>2、用于疾病诊断</h3><ul>
<li><p><strong>指导养生</strong>：春夏养阳，秋冬养阴</p>
</li>
<li><p><strong>确定治疗原则</strong>：调整阴阳，补其不足，损其有余，回复阴阳的协调平衡，促使阴平阳秘。</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200415012713.png" alt="image-20200415012705264"></p>
</li>
<li><p><strong>分析和归纳药物性能</strong></p>
<table>
<thead>
<tr>
<th></th>
<th align="center">药性</th>
<th align="center">五味</th>
<th align="center">升降浮沉</th>
</tr>
</thead>
<tbody><tr>
<td>阳</td>
<td align="center">温热</td>
<td align="center">辛甘淡</td>
<td align="center">升浮</td>
</tr>
<tr>
<td>阴</td>
<td align="center">寒凉</td>
<td align="center">酸苦咸</td>
<td align="center">沉降</td>
</tr>
</tbody></table>
<p>升浮——病位在上，病势向下</p>
<p>沉降——病位在下，病势向上</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>万物负阴而抱阳</p>
</blockquote>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200415014820.png" alt="image-20200415014818265"></p>
<p><strong>下节是五行学说、、、、</strong></p>
]]></content>
      <categories>
        <category>中医理论基础</category>
      </categories>
      <tags>
        <tag>中医</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/04/22/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>使用代理对象代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的操作，拓展目标对象的功能。代理模式的主要作用是拓展目标对象的功能，比如在目标对象的某个方法执行前后可以增加一些自定义的操作。</p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>从JVM角度说，静态代理在编译时就将接口，实现类，代理类这些都变成了一个个实际的class文件。</p>
<p>静态代理实现步骤：</p>
<ul>
<li>定义一个接口和其实现类</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ul>
<p><strong>代码演示：</strong></p>
<ul>
<li><p>定义发送短信的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义实现发送短信的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;send message:&quot;</span>+message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建代理类并同样实现发送短信的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">smsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，先添加自己的操作</span></span><br><span class="line">        sout(<span class="string">&quot;before method&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后</span></span><br><span class="line">        sout(<span class="string">&quot;after method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实际使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mian</span></span>&#123;</span><br><span class="line">    psvm&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>不需要针对每一个目标类都单独创建一个代理类，并且也不需要必须实现接口，可以直接代理实现类。从JVM角度来说，动态代理是在运行时动态生成字节码文件，并加载到JVM中的。</p>
<p>java实现动态代理的方式有很多种吗，比如JDK动态代理，CGLIB动态代理等等。</p>
<h2 id="JDK动态代理机制"><a href="#JDK动态代理机制" class="headerlink" title="JDK动态代理机制"></a>JDK动态代理机制</h2><p><code>InvocationHandler</code>和<code>Proxy</code>类是核心。</p>
<p><code>Proxy</code>类中使用最频繁的方法是<code>newProxyInstance()</code>，用于生成一个代理对象。</p>
<p>一共三个参数：</p>
<ul>
<li>loder：类加载器，用于加载代理对象</li>
<li>interfaces：被代理类实现的一些接口</li>
<li>h：实现了<code>InvocationHandler</code>接口的对象。</li>
</ul>
<p>要实现动态代理，还需要实现<code>InvocationHandler</code>来自定义处理逻辑。当动态代理对象调用一个方法时候，方法的调用会被转发到<code>InvocationHandler</code>接口类的<code>invoke</code>方法来调用。</p>
<p><strong>JDK动态代理使用步骤：</strong></p>
<ul>
<li>定义一个借口及其实现类</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> * 定义发送短信的接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> * 实现发送短信的接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span>+message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> * 定义一个JDK动态代理类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method&quot;</span>+method.getName());</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method&quot;</span>+method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> * 获取代理对象的工厂类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = (SmsService)JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">        smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CGLIB动态代理机制"><a href="#CGLIB动态代理机制" class="headerlink" title="CGLIB动态代理机制"></a>CGLIB动态代理机制</h2><p>JDK只能代理实现了接口的类。</p>
<p><strong>使用步骤：</strong></p>
<ul>
<li>定义一个类</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ul>
<p>使用的话，需要添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><h2 id="JDK动态代理和CGLIB动态代理"><a href="#JDK动态代理和CGLIB动态代理" class="headerlink" title="JDK动态代理和CGLIB动态代理"></a>JDK动态代理和CGLIB动态代理</h2><ol>
<li><strong>JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h2 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h2><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gitee部署Hexo遇到的神坑</title>
    <url>/2020/03/05/%E4%BD%BF%E7%94%A8gitee%E9%83%A8%E7%BD%B2hexo%E9%81%87%E5%88%B0%E7%9A%84%E7%A5%9E%E5%9D%91/</url>
    <content><![CDATA[<h2 id="1、问题来源"><a href="#1、问题来源" class="headerlink" title="1、问题来源"></a>1、问题来源</h2><p>​    最开始用Hexo+github搭建了一个个人主页，当我满心欢喜的发给朋友们炫耀的时候，大家都在抱怨访问的速度实在太慢。就想着把代码从github迁移到码云上。看网上的教程很简单，于是跟着做起来。最开始直接从github拷贝到码云，打开网址呈现的画面是这样的。</p>
<p><img src="https://i.loli.net/2020/03/05/5eLH7sSvrc4hJgz.jpg" alt="TIM图片20200305185945.jpg"></p>
<p>​    所有的样式都无法加载，所有的链接无法访问，我就纳闷了，明明是原封不动的克隆过来的，这怎么回事？于是继续找万能的度娘，度娘上和官方都是这么说的，由于种种原因，你要修改hexo中的配置文件，巴拉巴拉，，，OK，我改，然后当我改了url之后，页面直接报了404，真是*了**。再然后我就接着百度和谷歌，很遗憾，没看到我的答案，逐渐陷入了沉思，，，，</p>
<h2 id="2、问题解决"><a href="#2、问题解决" class="headerlink" title="2、问题解决"></a>2、问题解决</h2><p>​    <strong>机缘巧合</strong>（这个答案真的不是在网上看到的，，，），上帝又来暗示我了，话不多说</p>
<p><img src="https://i.loli.net/2020/03/05/1fmo4asuDz53KHk.png" alt="微信截图_20200305191050.png"></p>
<p>在github上，每次当你每次改动想要提交，在本地执行hexo clean-&gt;hexo g-&gt;hexo d之后，去页面刷新就好了，但是在码云，git操作完成之后，还要去pages页面执行更新，代码才会被合并，OK，完美解决！</p>
<p><img src="https://i.loli.net/2020/03/05/RV5mJspyGPhYoUA.png" alt="微信截图_20200305191646.png"></p>
]]></content>
      <categories>
        <category>Bug合集</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于焦虑</title>
    <url>/2020/03/20/%E5%85%B3%E4%BA%8E%E7%84%A6%E8%99%91/</url>
    <content><![CDATA[<blockquote>
<p>你以为这是一篇教你如何应对焦虑的文章？</p>
</blockquote>
<p>本来想认真写一点东西的，但是半天没找到纸和笔宣告放弃。我对笔和纸是有一点点执念的，比如我真的看不来电子书，很大一部分原因是我大学之前是没碰过手机的，我敲键盘的速度也很慢，这倒不是对纸的执念，完全是因为emmm敲的少。</p>
<h2 id="那个平凡的实验室下午"><a href="#那个平凡的实验室下午" class="headerlink" title="那个平凡的实验室下午"></a>那个平凡的实验室下午</h2><p>真正焦虑的开始要从一个平淡无奇的实验室下午说起，当导师把一个完整的项目交给我的时候我慌了。我说，我真的很菜，完全没有学过，我甚至不知道我为什么会考上研究生。导师很温暖，他笑了笑并没有直接回复我，第二天，他把我叫去他旁边，看到我前端用的vscode，他说，可以呀，用的vscode，现在这个IDE还挺火的，我没理解这有啥值得夸的，他看着我一脸尴尬。再然后他开始教我怎么使用navicat，说实话这样简单的工具还是会使用的。最后他又夸了我几句，我不太理解，但是转身他告诉我要加油，现在不会，给你时间，研二还能不会咋地，再不会就可以回家种地了。这时候的焦虑是空焦虑，焦虑啥也不会，焦虑深度学习作业没跑出来，焦虑自己的pr没被merge，甚至焦虑别的导师都分了超算节点，为什么蒲总不发。。。。</p>
<h2 id="那些难熬的日日夜夜"><a href="#那些难熬的日日夜夜" class="headerlink" title="那些难熬的日日夜夜"></a>那些难熬的日日夜夜</h2><p>寒假之前，蒲总带着我们兄弟仨和甲方的伙伴吃了顿饭，然后放假回家，蒲总说回家我们一起来学GNN怎么样。怎么样，那太好了啊，还能说不好是咋地，很遗憾，GNN我现在还没开始学。然后疫情爆发，蒲总说来吧，结合疫情找个点，文章还是要发的。再然后项目真正开始了，第一天电话会议，我分了个模块，但是完全是懵的状态，之前的框架被甲方否了，要用微服务，ok呗，当天晚上再B站找了个微服务的视频看到四点多，但是看完觉得这是基于springboot的，于是springboot是不是也要学，springboot前面还有springmvc，前面还有spring，mybatis，还要redis，，，，去他妈的，不学了，这玩意啥时候是个头，于是开始了另一种思路，用啥学啥。</p>
<p>OK模仿别人的代码，知道CRUD的操作，知道原来还有dao,controller,service这些层，再然后mybatis有啥学的，会sql不就好了。看完了spring，害，spring有啥学的，不面试谁会问你控制反转，依赖注入。至此，我觉得思路是对的，硬着头皮写好了，前面的一系列，用到啥去学啥就好了。</p>
<p>CRUD虽说基础又简单，但是一个项目中大部分写的还是CRUD，最后用mybatis-plus，xml文档也不用写了。上手这个过程，是好几个夜晚和焦虑，这时候的焦虑是真的焦虑了，担心ddl，担心蒲总问话，担心发量，连夜买了一瓶生姜洗发液。。。。。</p>
<h2 id="其实都是青春的救赎"><a href="#其实都是青春的救赎" class="headerlink" title="其实都是青春的救赎"></a>其实都是青春的救赎</h2><p>我本来想把文章写得深沉灵气一点，但是发现越写越急促。不知道为什么现在写字都是这样一种风格了。</p>
<p>其实绝大多数时候，焦虑都是源于当事者能力不足，这是真真切切的话。至此我才明白，什么时候该做什么事情，做不好是要偿债的。有一天我和室友说：“我现在换了一种思路了，我觉得吧，不管怎么样，事情是一定会过去的，所以这些任务也一定是可行的，既然是可行的，那就没那么可怕了，只是会不会的问题了，会的少，不会的就去学好了”。说完这些话我心安理得的睡个了大觉，，，，，，</p>
<p>我有时候会很害怕焦虑的感觉，焦虑会让人变得没有精气神，会让人失去对一切的兴趣，甚至吃饭。最开始的那几天晚上，我每天熬夜到很晚，然后爸妈会说让我早点睡，叔叔婶婶会来安慰几句。哪怕他们再多说几句，我可能眼泪就要出来了。在读研之前听抖音上的学长学姐抱怨说太痛苦了，我并没有真正的感同身受。等我真正读了研，我觉得自己更爱独居了，会觉得在实验室待了一天，骑个小车去枣阳路吃碗拉面是一种幸福。会一个人走到很远但是很安静的苏州河边给爸妈打个电话，他们总是急促的挂断。会一个人去看个电影。但是越这样越会觉得，自己没了，我读高中的时候坐三轮回家，两个初中生也在互相交谈说没有自己了，我当时觉得他们可笑。。。。</p>
<p>我没有学会处理自己的焦虑，但是觉得我们有时候应该站在上帝视角审视自己。别把自己的小悲小痛看的过于重要，一件事，当你真正要着手去做的时候，整理好思路，其实这件事就差不多做完了。但是大多数情况是，还没到最后，一遍开始焦虑，一遍打开B站：学学爬虫吧，跑个深度学习模型吧，试试Julia语言好不好使。然后一面学一些有的没的，一面在焦虑自己的ddl，一遍嘴里还抱怨着：害，现在想学习点自己感兴趣的只是都是个奢侈了，，，，，，，</p>
<p>好了吧，焦虑的我突然不想写了，去赶ddl吧QAQ。</p>
]]></content>
      <categories>
        <category>听个故事吧</category>
      </categories>
      <tags>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN手写文字识别</title>
    <url>/2020/04/08/%E5%88%A9%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0%E8%B7%91%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%8B%E5%86%99%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="深度学习平台"><a href="#深度学习平台" class="headerlink" title="深度学习平台"></a>深度学习平台</h1><p><a href="ftp://hhzhu.top/">数据集下载</a>(账号：hhzhu  密码：123456)</p>
<p>平台是借助学校的超算环境搭建的，目前有两张GPU卡，CPU的资源比较充足。框架选择的是pytorch，我们也可以在本地搭建pytorch环境，电脑有英伟达的GPU的话，跑代码还是很快的。windows环境搭建pytorch环境参见之前的一篇文章<a href="https://victor-huihui.gitee.io/2020/03/11/PyTorch%E5%85%A5%E9%97%A8/">click here</a>。我们的深度学习平台只是帮我们弄好了环境，配置比较优秀，别的和本地是一样的。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Mon Feb  3 13:15:59 2020</span></span><br><span class="line"><span class="string">@author: hhzhu</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#​运用CNN进行MNIST的分类任务</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span>  nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span>  optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义CNN</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CNN,self).__init__()</span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">32</span>,kernel_size=<span class="number">5</span>), <span class="comment"># 32, 28*28, 24*24    </span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>)) <span class="comment"># 32, 24*24, 12*12</span></span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,kernel_size=<span class="number">5</span>), <span class="comment"># 64,12*12, 8*8</span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>))  <span class="comment"># 128, 8*8, 4*4</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">1024</span>,<span class="number">1000</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">1000</span>,<span class="number">10</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用内置函数下载mnist数据集</span></span><br><span class="line"><span class="comment">#train_set = mnist.MNIST(&#x27;./data&#x27;,train=True)</span></span><br><span class="line"><span class="comment">#test_set = mnist.MNIST(&#x27;./data&#x27;,train=False)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 预处理=&gt;将各种预处理组合在一起</span></span><br><span class="line"><span class="comment"># 定义一个新的data_tf,用于除以255归一化</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_tf</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = np.array(x, dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    x = x / <span class="number">255</span></span><br><span class="line">    x = transforms.ToTensor()(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="comment">#data_tf = transforms.Compose(</span></span><br><span class="line"><span class="comment">#                [transforms.ToTensor(),</span></span><br><span class="line"><span class="comment">#                 transforms.Normalize([0.5],[0.5])])</span></span><br><span class="line"> </span><br><span class="line">train_set = mnist.MNIST(<span class="string">&#x27;./data&#x27;</span>,train=<span class="literal">True</span>,transform=data_tf,download=<span class="literal">False</span>)</span><br><span class="line">test_set = mnist.MNIST(<span class="string">&#x27;./data&#x27;</span>,train=<span class="literal">False</span>,transform=data_tf,download=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line"><span class="comment">#%matplotlib inline</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">type</span>(train_set))</span><br><span class="line">print(<span class="built_in">len</span>(train_set.train_data))</span><br><span class="line"><span class="comment">#print(train_set.train_data[0])</span></span><br><span class="line">im = train_set.train_data[<span class="number">0</span>]</span><br><span class="line">im = im.reshape(-<span class="number">1</span>,<span class="number">28</span>)</span><br><span class="line">print(im)</span><br><span class="line">pylab.imshow(im)</span><br><span class="line">pylab.show()</span><br><span class="line"></span><br><span class="line">train_data = DataLoader(train_set,batch_size=<span class="number">64</span>,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_data = DataLoader(test_set,batch_size=<span class="number">128</span>,shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = CNN()</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment">#optimizer = optim.SGD(net.parameters(),1e-1)</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr = <span class="number">0.0001</span>)</span><br><span class="line">nums_epoch = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line">losses =[]</span><br><span class="line">acces = []</span><br><span class="line">eval_losses = []</span><br><span class="line">eval_acces = []</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(nums_epoch):</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        net = net.cuda() </span><br><span class="line">    train_loss = <span class="number">0</span></span><br><span class="line">    train_acc = <span class="number">0</span></span><br><span class="line">    net = net.train()</span><br><span class="line">    <span class="keyword">for</span> img , label <span class="keyword">in</span> train_data:</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            img = Variable(img.cuda())</span><br><span class="line">            label = Variable(label.cuda())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img = Variable(img)</span><br><span class="line">            label = Variable(label)</span><br><span class="line">        out = net(img)</span><br><span class="line">        loss = criterion(out,label)</span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step() </span><br><span class="line">        <span class="comment"># 记录误差</span></span><br><span class="line">        train_loss += loss.item()</span><br><span class="line">        <span class="comment"># 计算分类的准确率</span></span><br><span class="line">        _,pred = out.<span class="built_in">max</span>(<span class="number">1</span>)</span><br><span class="line">        num_correct = (pred == label).<span class="built_in">sum</span>().item()</span><br><span class="line">        acc = num_correct / img.shape[<span class="number">0</span>]</span><br><span class="line">        train_acc += acc</span><br><span class="line">    losses.append(train_loss / <span class="built_in">len</span>(train_data))</span><br><span class="line">    acces.append(train_acc / <span class="built_in">len</span>(train_data))</span><br><span class="line">    eval_loss = <span class="number">0</span></span><br><span class="line">    eval_acc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> img , label <span class="keyword">in</span> test_data:</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            img = Variable(img.cuda())</span><br><span class="line">            label = Variable(label.cuda())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img = Variable(img)</span><br><span class="line">            label = Variable(label)</span><br><span class="line">        out = net(img)</span><br><span class="line">        loss = criterion(out,label)</span><br><span class="line">        <span class="comment"># 记录误差</span></span><br><span class="line">        eval_loss += loss.item()</span><br><span class="line">        _ , pred = out.<span class="built_in">max</span>(<span class="number">1</span>)</span><br><span class="line">        num_correct = (pred==label).<span class="built_in">sum</span>().item()</span><br><span class="line">        acc = num_correct / img.shape[<span class="number">0</span>]</span><br><span class="line">        eval_acc += acc</span><br><span class="line">    eval_losses.append(eval_loss / <span class="built_in">len</span>(test_data))</span><br><span class="line">    eval_acces.append(eval_acc / <span class="built_in">len</span>(test_data))</span><br><span class="line">    print(<span class="string">&#x27;Epoch &#123;&#125; Train Loss &#123;&#125; Train  Accuracy &#123;&#125; Teat Loss &#123;&#125; Test Accuracy &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        epoch+<span class="number">1</span>, train_loss / <span class="built_in">len</span>(train_data),train_acc / <span class="built_in">len</span>(train_data), eval_loss / <span class="built_in">len</span>(test_data), eval_acc / <span class="built_in">len</span>(test_data)))</span><br></pre></td></tr></table></figure>

<h1 id="10个Epoch的结果"><a href="#10个Epoch的结果" class="headerlink" title="10个Epoch的结果"></a>10个Epoch的结果</h1><p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200408110330.png" alt="image-20200408110321833"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>别直接修改hexo生成的文件名</title>
    <url>/2020/03/06/%E5%88%AB%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9hexo%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D/</url>
    <content><![CDATA[<p>没啥说的，目录里有几个题目的开头英文没大写，看着很别扭，想修改成大写，于是寻思，hexo的文章title都是些文章名然后自动生成的，于是直接改了md文件的文件名，报了404，正确的做法是点进去md文档修改title。</p>
<h2 id="快速执行hexo-clean-hexo-g-hexo-d"><a href="#快速执行hexo-clean-hexo-g-hexo-d" class="headerlink" title="快速执行hexo clean,hexo g,hexo d"></a>快速执行hexo clean,hexo g,hexo d</h2><p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200326172526.png" alt="image-20200326172319885"></p>
<p>然后执行<kbd>npm start</kbd>就行了。</p>
<ul>
<li><input disabled="" type="checkbox"> 列表渲染测试</li>
<li><input disabled="" type="checkbox"> 测试</li>
<li><input disabled="" type="checkbox"> 测试</li>
</ul>
]]></content>
      <categories>
        <category>Bug合集</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>通用图纸识别调研</title>
    <url>/2020/04/26/%E5%9B%BE%E7%BA%B8%E8%AF%86%E5%88%AB%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<blockquote>
<p>最近在做图纸识别的项目调研，对于文字识别来说，各种云服务商已经提供了很详尽的API和各种开发语言的SDK，开箱即用非常方便。但是对于开发者来说具体的识别过程还是个黑匣子，而且，是收费的。这里调研了几个开源的文字识别项目，目前还在调研过程</p>
</blockquote>
<h2 id="云服务商API"><a href="#云服务商API" class="headerlink" title="云服务商API"></a>云服务商API</h2><p>百度云，腾讯云，阿里云，华为云都提供了印刷文字的识别。阿里云的在项目中有用到过，文档写的非常详尽。参照之前写的<a href="https://victor-huihui.gitee.io/2020/04/09/%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%BF%A1%E6%81%AF%E8%AF%86%E5%88%AB/">身份证信息识别</a></p>
<h2 id="Tesseract-OCR"><a href="#Tesseract-OCR" class="headerlink" title="Tesseract-OCR"></a>Tesseract-OCR</h2><p>谷歌公司产品。经过测试读取计算机的照片生成的文字，准确率不错。使用起来简单，实例化一个Tesseract实例，然后为已经训练好的LSTM模型设置数据路径，调用doOCR方法，接收一个文件参数返回字符串。开源。这里用sprigboot写了一个demo测试了一下识别效果。</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;?xml</span> <span class="string">version=&quot;1.0&quot;</span> <span class="string">encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;project</span> <span class="string">xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="string">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         <span class="string">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span> <span class="string">https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span><br><span class="line">    <span class="string">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span><br><span class="line">    <span class="string">&lt;parent&gt;</span></span><br><span class="line">        <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">        <span class="string">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span></span><br><span class="line">        <span class="string">&lt;relativePath/&gt;</span> <span class="string">&lt;!--</span> <span class="string">lookup</span> <span class="string">parent</span> <span class="string">from</span> <span class="string">repository</span> <span class="string">--&gt;</span></span><br><span class="line">    <span class="string">&lt;/parent&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;com.hhzhu&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;demo&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="string">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line">    <span class="string">&lt;name&gt;demo&lt;/name&gt;</span></span><br><span class="line">    <span class="string">&lt;description&gt;Demo</span> <span class="string">project</span> <span class="string">for</span> <span class="string">Spring</span> <span class="string">Boot&lt;/description&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&lt;properties&gt;</span></span><br><span class="line">        <span class="string">&lt;java.version&gt;1.8&lt;/java.version&gt;</span></span><br><span class="line">    <span class="string">&lt;/properties&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&lt;dependencies&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;!--</span> <span class="string">https://mvnrepository.com/artifact/net.sourceforge.tess4j/tess4j</span> <span class="string">--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;tess4j&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;version&gt;4.4.1&lt;/version&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;scope&gt;test&lt;/scope&gt;</span></span><br><span class="line">            <span class="string">&lt;exclusions&gt;</span></span><br><span class="line">                <span class="string">&lt;exclusion&gt;</span></span><br><span class="line">                    <span class="string">&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span></span><br><span class="line">                    <span class="string">&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span></span><br><span class="line">                <span class="string">&lt;/exclusion&gt;</span></span><br><span class="line">            <span class="string">&lt;/exclusions&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;/dependencies&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&lt;build&gt;</span></span><br><span class="line">        <span class="string">&lt;plugins&gt;</span></span><br><span class="line">            <span class="string">&lt;plugin&gt;</span></span><br><span class="line">                <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">                <span class="string">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;/plugin&gt;</span></span><br><span class="line">        <span class="string">&lt;/plugins&gt;</span></span><br><span class="line">    <span class="string">&lt;/build&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;/project&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sourceforge.tess4j.Tesseract;</span><br><span class="line"><span class="keyword">import</span> net.sourceforge.tess4j.TesseractException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.support.RedirectAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.RedirectView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 谷歌OCR识别测试控制层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HhZhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Created on 2020/4/25 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;upload&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RedirectView <span class="title">singleFileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             RedirectAttributes redirectAttributes, Model model)</span> <span class="keyword">throws</span> IOException, TesseractException </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            Path path = Paths.get(<span class="string">&quot;C://Users//Victor//Desktop//demo//src//main//resources//static//&quot;</span> + file.getOriginalFilename());</span><br><span class="line">            Files.write(path, bytes);</span><br><span class="line">            File convFile = convert(file);</span><br><span class="line">            Tesseract tesseract = <span class="keyword">new</span> Tesseract();</span><br><span class="line">            tesseract.setDatapath(<span class="string">&quot;C://Users//Victor//Desktop//demo//DataScience//testdata//&quot;</span>);</span><br><span class="line">            String text = tesseract.doOCR(convFile);</span><br><span class="line">            redirectAttributes.addFlashAttribute(<span class="string">&quot;file&quot;</span>, file);</span><br><span class="line">            redirectAttributes.addFlashAttribute(<span class="string">&quot;text&quot;</span>, text);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;/result&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">convert</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            File convFile = <span class="keyword">new</span> File(file.getOriginalFilename());</span><br><span class="line">            convFile.createNewFile();</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(convFile);</span><br><span class="line">            fos.write(file.getBytes());</span><br><span class="line">            fos.close();</span><br><span class="line">            <span class="keyword">return</span> convFile;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>static</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># upload页面</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a file for OCR<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># result页面</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>result<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Extracted Content:<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;text&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Form the image:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;&#x27;/&#x27; + $&#123;file.getOriginalFilename()&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的testdata可以到github下载，大概有1.6个G的样子(monkey找个脚本加速一下吧，不然要疯的)，然后用两张图片作为测试，下面是识别结果的对比：</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200426135925.png" alt="微信截图_20200426135853"></p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200426140114.png" alt="微信截图_20200426140021"></p>
<p><strong>可以看出适应性比较差。对于排版标准的图片，识别很精准，但是对于畸形图片的识别准确率较差</strong></p>
<h2 id="Chineseocr-lite"><a href="#Chineseocr-lite" class="headerlink" title="Chineseocr-lite"></a>Chineseocr-lite</h2><p>还有很多正在调研和测试，，，，，，，</p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>基于matlab实现PCA图像压缩</title>
    <url>/2020/06/24/%E5%9F%BA%E4%BA%8Ematlab%E5%AE%9E%E7%8E%B0PCA%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>数据在大数据时代成为一笔宝贵的财富，随之而来的是海量的数据的传输和存储问题。大量数据的重复和冗余让我们不得不对数据进行压缩处理。对于图像压缩的问题，目标是最小化压缩数据和最大化保留原样本数据，方法可以分为有损压缩和无损压缩。本文就是基于PCA实现的一种图像的有损压缩方法，项目基于matlab实现。</p>
<p>PCA相信大家都不陌生，就是用样本的协方差矩阵进行特征分解，求出协方差矩阵的特征值和特征向量，找出其中较大的几个特征值对应的特征向量作为主成分，并将样本向量向主成分上做投影，利用投影后的数据表示原数据，从而降维和去除冗余。这里不对PCA的具体原理说明。</p>
<h2 id="PCA算法的步骤"><a href="#PCA算法的步骤" class="headerlink" title="PCA算法的步骤"></a>PCA算法的步骤</h2><p>先举个例子说明PCA算法的主要步骤，这样就可以直接写算法了，很简单。</p>
<ul>
<li><p>数据去中心化 $ (X_i-E(X)) $</p>
<p>$$<br>X = \left( {\begin{array}{<em>{20}{c}}<br>   {100} &amp; {200} &amp; {300} &amp; {400} &amp; {500}  \<br>   {150} &amp; {450} &amp; {560} &amp; {750} &amp; {1100}  \<br>\end{array}} \right) - \left( {\begin{array}{</em>{20}{c}}<br>   {300}  \<br>   {602}  \<br>\end{array}} \right) = \left( {\begin{array}{*{20}{c}}<br>   { - 200} &amp; { - 100} &amp; 0 &amp; {100} &amp; {200}  \<br>   { - 452} &amp; { - 152} &amp; { - 42} &amp; {148} &amp; {498}  \<br>\end{array}} \right)<br>$$</p>
</li>
</ul>
<ul>
<li>计算协方差矩阵 $ C_x = XX’  $</li>
</ul>
<p>$$<br>{C_x} = X{X^T} = \left( {\begin{array}{*{20}{c}}<br>     {25000} &amp; {55000}  \<br>     {55000} &amp; {124770}  \<br>  \end{array}} \right)<br>$$</p>
<ul>
<li>对协方差矩阵进行奇异值分解$(SVD)$</li>
</ul>
<p>$$<br>{C_x} = \left( {\begin{array}{<em>{20}{c}}<br>     { - 0.9143} &amp; {0.4051}  \<br>     {0.4051} &amp; {0.9143}  \<br>  \end{array}} \right) \times \left( {\begin{array}{</em>{20}{c}}<br>     {149140} &amp; 0  \<br>     0 &amp; {630}  \<br>  \end{array}} \right) \times \left( {\begin{array}{*{20}{c}}<br>     { - 0.9143} &amp; {0.4051}  \<br>     {0.4051} &amp; {0.9143}  \<br>  \end{array}} \right)<br>$$</p>
<ul>
<li><p>取$K$个特征值和特征向量构成一个变幻矩阵(这里是1)</p>
<p>$$<br>{P_k} = \left( {\begin{array}{<em>{20}{c}}<br>   {0.4051}  \<br>   {0.9143}  \<br>\end{array}} \right) \times 149140 = \left( {\begin{array}{</em>{20}{c}}<br>   {60410}  \<br>   {136350}  \<br>\end{array}} \right)<br>$$</p>
</li>
<li><p>将原始投影映射到K维空间</p>
</li>
</ul>
<p>$$<br>Y = P_K^TX<br>$$</p>
<h2 id="设计实现PCA算法"><a href="#设计实现PCA算法" class="headerlink" title="设计实现PCA算法"></a>设计实现PCA算法</h2><p>其实不管是matlab还是python的sklearn包里面都包含了PCA算法，这里既然知道了算法的原理和具体步骤，完全可以自己设计实现。先贴出完整的matlab代码</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 利用PCA对图像压缩</span></span><br><span class="line">close all</span><br><span class="line">clear </span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% 输入参数</span></span><br><span class="line">num_val = <span class="number">4</span>;                                 <span class="comment">%取前num_val个特征值</span></span><br><span class="line">size_block = <span class="number">4</span>;                              <span class="comment">%取size_block*size_block块</span></span><br><span class="line"><span class="comment">%% 批量处理图片</span></span><br><span class="line">img_path = <span class="string">&#x27;D:\development\MATLAB\About_image\PCA\Origin_Data\NWPU VHR-10 dataset\negative image set\&#x27;;</span></span><br><span class="line"><span class="string">path_list = dir(strcat(img_path,&#x27;</span>*.jpg&#x27;));</span><br><span class="line">img_num = <span class="built_in">length</span>(path_list);</span><br><span class="line"><span class="keyword">if</span> img_num&gt;<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> pn = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">        img_name = path_list(pn).name;</span><br><span class="line">        origin_img = imread(strcat(img_path,img_name));</span><br><span class="line">        <span class="comment">%fprintf(&quot;%d %s\n&quot;,pn,strcat(img_path,img_name));</span></span><br><span class="line">        <span class="comment">%图像处理的具体方法</span></span><br><span class="line">        In = imresize(origin_img,[<span class="number">256</span>,<span class="number">256</span>]);</span><br><span class="line">        <span class="comment">% 测试的图像灰度化</span></span><br><span class="line">        <span class="comment">%In = rgb2gray(In);</span></span><br><span class="line">        <span class="comment">% 将原图像矩阵分割成n*n的块，再转化为列矩阵，构成最终矩阵reIn</span></span><br><span class="line">        In = im2double(In);</span><br><span class="line">        [row ,rol] = <span class="built_in">size</span>(In);</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        Data = <span class="built_in">zeros</span>(size_block*size_block,(row/size_block)*(rol/size_block)); </span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:size_block:row</span><br><span class="line">           <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:size_block:rol</span><br><span class="line">              m = m+<span class="number">1</span>;</span><br><span class="line">              block = In(<span class="built_in">i</span>:<span class="built_in">i</span>+size_block<span class="number">-1</span>,<span class="built_in">j</span>:<span class="built_in">j</span>+size_block<span class="number">-1</span>);</span><br><span class="line">              Data(:,m) = block(:);</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%PCA处理</span></span><br><span class="line">        Data1 = Data - <span class="built_in">ones</span>(<span class="built_in">size</span>(Data,<span class="number">1</span>),<span class="number">1</span>)*<span class="built_in">mean</span>(Data);             <span class="comment">% 标准化处理</span></span><br><span class="line">        c = cov(Data1&#x27;);                                     <span class="comment">% 求矩阵协方差矩阵</span></span><br><span class="line">        [vec,val] = eig(c);                                      <span class="comment">% 求特征值和特征向量</span></span><br><span class="line">        <span class="comment">% 按特征值降序排列</span></span><br><span class="line">        val = <span class="built_in">diag</span>(val);                                        <span class="comment">% 从对角线拿出特征值</span></span><br><span class="line">        [val ,t] = <span class="built_in">sort</span>(val,<span class="string">&#x27;descend&#x27;</span>);                             <span class="comment">% 特征值降序排列</span></span><br><span class="line">        vec = vec(:,t);</span><br><span class="line">        <span class="comment">%重构图像</span></span><br><span class="line">        vec_new = vec(:,<span class="number">1</span>:num_val);</span><br><span class="line">        rata = val./sum(val);</span><br><span class="line">        rata_sum = sum(rata(<span class="number">1</span>:num_val));</span><br><span class="line">        fprintf(<span class="string">&quot;当前图片处理的进度是%g----&quot;</span>,pn/img_num);</span><br><span class="line">        fprintf(<span class="string">&#x27;当前图片选取%g个特征值的贡献率为：%g\n&#x27;</span>,num_val,rata_sum);</span><br><span class="line">        y = vec_new&#x27;* Data;                                      <span class="comment">% 映射 由公式：y=w&#x27;*x</span></span><br><span class="line">        Data2 = vec_new * y;                                    <span class="comment">% 重构图像</span></span><br><span class="line">        Data2 = Data2 + <span class="built_in">ones</span>(<span class="built_in">size</span>(vec_new, <span class="number">1</span>), <span class="number">1</span>) * <span class="built_in">mean</span>(Data);     <span class="comment">% 加均值</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:size_block:row</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:size_block:rol</span><br><span class="line">                m = m + <span class="number">1</span>;</span><br><span class="line">                block1 = <span class="built_in">reshape</span>(Data2(:, m), size_block, size_block);        <span class="comment">% 列向量块转化为方块</span></span><br><span class="line">                Out(<span class="built_in">i</span>:<span class="built_in">i</span>+size_block<span class="number">-1</span>, <span class="built_in">j</span>:<span class="built_in">j</span>+size_block<span class="number">-1</span>) = block1; </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        Out1 = Out(:,<span class="number">1</span>:<span class="number">256</span>);</span><br><span class="line">        Out2 = Out(:,<span class="number">257</span>:<span class="number">2</span>*<span class="number">256</span>);</span><br><span class="line">        Out3 = Out(:,<span class="number">2</span>*<span class="number">256</span>+<span class="number">1</span>:<span class="number">768</span>);</span><br><span class="line">        RGB = <span class="built_in">cat</span>(<span class="number">3</span>,Out1,Out2,Out3);</span><br><span class="line">        imwrite(RGB,strcat(<span class="string">&#x27;D:\development\MATLAB\About_image\PCA\After_PCA_Data\negative image set\&#x27;,img_name));</span></span><br><span class="line"><span class="string">        %imwrite(RGB,strcat(img_name,&#x27;</span>.jpg&#x27;));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里说明一下，如果我们一开始输入时RGB图像，那么图像有三个通道，直接绘制的话，会是三个通道的图片。所以如果我们只需要灰度图片，在代码的一开始，先用<code>rgb2gray</code>函数把RGB图像转换为灰度图像。如果需要保存彩色图像，则需要在代码的最后，则需要用<code>cat</code>函数把三个通道组合在一起，输出为一张RGB图片。代码关键的地方都有注释。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>我们选的数据集一共只有150张图片，当我选择不同数量的主成分的时候，会得到不同的结果，主成分的选取越大，图像越接近原图像，压缩比例也就不好。</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200624164440.png" alt="image-20200624164431654" style="zoom: 50%;" />

<p>然后看一下具体的压缩效果：</p>
<p>对于原始的图片：<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200624164831.png" alt="image-20200624164831044" style="zoom: 50%;" /></p>
<p>对于压缩后图片：<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200624164924.png" alt="image-20200624164924880" style="zoom: 50%;" /></p>
<p>啊哈还行哈，单个图片的对比就不放上来了，emmm影响排版。</p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
  </entry>
  <entry>
    <title>基础记录</title>
    <url>/2020/03/01/%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>常用的SQL优化方式<br>redis的几种部署方式<br>sprigboot帮助我们做了什么事情(如果没有boot,新建一个web需要自己做哪些东西)<br>具体说一下oauth2</p>
<p>项目的具体架构。</p>
<p>java拦截器</p>
<p>多线程和多进程，如何选择多线程，在并发的情况是选择多线程还是多进程。</p>
<p>tomcat</p>
</blockquote>
<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>面向对象的好处：</p>
<ul>
<li>易维护：可读性强，由于继承的存在，及时改变需求，维护的也只是在局部模块。</li>
<li>质量高：重复现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。</li>
<li>效率高：在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。</li>
<li>易拓展：由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。</li>
</ul>
<p>java性能差的原因是，java是半编译语言，最终的执行代码不是可以直接被cpu执行的二进制机械码。</p>
<p><strong>JAVA和C++的区别：</strong></p>
<ul>
<li>面向对象，封装继承和多态</li>
<li>Java不提供指针直接访问内存，程序内存更加安全</li>
<li>java类单继承，C++支持多重继承；虽然java的类不可以多继承，但是接口可以多继承。</li>
<li>java自动内存管理，C++手动管理。</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节</th>
<th align="center">bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">64</td>
</tr>
</tbody></table>
<p><strong>装箱与拆箱</strong></p>
<p>装：将基本类型转化为包装器类型。</p>
<p>拆：自动将包装器类型转换为基本数据类型。</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><ul>
<li><p>封装：将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过类提供的方法来实现内部信息的操作和访问。</p>
<p>访问控制符：</p>
<ul>
<li>private：只允许当前类内部访问。</li>
<li>package：当前包下的其他类访问。</li>
<li>protected：当前包下的其他类访问，子类访问。</li>
<li>public：所有类访问。</li>
</ul>
</li>
<li><p>继承：extends，子类拓展了父类，获得父类的全部成员变量和方法。只能单继承，只有一个直接父类，但可以有无线个间接父类，没有显示指定，继承<code>java.lang.bject</code>。</p>
<ul>
<li><p>重写父类方法</p>
<p>static静态方法不能被重写。</p>
<p>遵循<strong>“两同两小一大”</strong>规则：方法名相同，形参列表相同；“两小”是指子类方法返回值类型和抛出异常类型比父类方法更小或者更小；一大是子类的方法的访问权限比父类更大或者相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);  <span class="comment">//重写父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>重载（overload）和重写（Override）的区别：</strong></p>
<ul>
<li><p>重载指同一类中多个同名方法根据不同的参数执行不同的逻辑。</p>
</li>
<li><p>重写只子类和父类的同名方法。但是内部逻辑是不一样的。</p>
</li>
</ul>
</li>
<li><p>super关键字：访问父类的构造函数，成员方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> x1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x1);</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();  <span class="comment">//调用被覆盖的父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        a.show();  <span class="comment">//x:2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>父类构造器：子类继承了父类，在初始化子类时，先初始化父类，调用super()，使用super必须放在子类构造器的第一行，而this调用同一个类中重载的构造器也要放在第一行，所以super和this不能同时出现。</p>
</li>
</ul>
</li>
<li><p>多态：相同类型的变量调用同一个方法时呈现出多种不同的特征。</p>
<p>Java 允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换。当把一个子类对象赋给父类引用变量时，会出现编译类型和运行类型不一致的情况，此时调用子类和父类的同名方法时（这里的同名指的是子类重写了父类方法），总是表现出子类方法的行为特征。例如：<code>B b = new A()</code> 编译类型看左边，运行类型看右边，因此编译类型为 B，运行类型为 A，当 b 调用 A 和 B 的同名的方法时，运行的总是 A 中的方法。</p>
</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>程序在运行的时候会产生很多对象，而对象信息也只是在程序运行的时候才在内存中保持其状态，一旦程序停止，内存释放，对象也就不存在了。怎么能让对象永久的保存下来呢？对象序列化。序列化的两个类ObjectOutputStream 和 ObjectInputStream。</p>
<ul>
<li>ProtoBuffer优点：<ul>
<li><strong>Protobuf 更小、更快、也更简单</strong>。</li>
<li><strong>“向后”兼容性好</strong></li>
<li><strong>Protobuf 语义更清晰</strong></li>
<li><strong>Protobuf 的编程模式比较友好</strong></li>
</ul>
</li>
<li>缺点：由于文本并不适合用来描述数据结构，所以 <code>Protobuf</code> 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 <code>Protobuf</code> 不行，它以二进制的方式存储，除非你有 <code>.proto</code> 定义，否则你没法直接读出 <code>Protobuf</code> 的任何内容。</li>
</ul>
<p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>反射的应用场景</strong></p>
<p>业务代码中使用反射比较少，但是有用，像spring/springboot，mybatis等框架都大量使用了反射机制。</p>
<p>这些框架中大量使用了动态代理，动态代理也是依赖反射。通过反射可以获取任意一个类的所有属性和方法，可以调用这些属性和方法。</p>
<p>注解中也是使用了反射。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li>优点：代码灵活，为各种框架提供开箱即用的功能提供了便利。</li>
<li>缺点：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。</li>
</ul>
<p><strong>反射实战</strong></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>右左结合：单目，条件，赋值</p>
<p>基本的优先级：</p>
<ul>
<li>指针最先，单目高于双目</li>
<li>先乘除后加减</li>
<li>先算数，再移位，再位运算。</li>
<li>逻辑最后</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Error和Exception，继承自Throwable</p>
<p><strong>两者不同：</strong></p>
<p>Exception:</p>
<ul>
<li>可以是checked或者unchecked</li>
<li>程序员导致的错误</li>
<li>程序级别处理</li>
</ul>
<p>Error:</p>
<ul>
<li>不可控制的unckecked</li>
<li>系统错误或底层资源错误</li>
<li>系统级别捕捉</li>
</ul>
<p>异常分类：</p>
<ul>
<li>checked exception</li>
<li>unckecked exception</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>访问修饰符：private,public,,,,,,,,</p>
<p>非访问修饰符：以下。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul>
<li>静态变量：独立于对象的静态变量，无论类实例化多少对象，静态变量只有一份拷贝，也成为类变量，局部变量不能声明为static</li>
<li>静态方法：独立于对象的静态方法，静态方法不能使用类的非静态变量，静态方法从参数列表得到数据，然后计算数据。</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>final变量：一旦赋值，不改变，必须显式指定初始值，一般和static一起来创建类常量。</p>
</li>
<li><p>final方法：可以被子类继承，但是不能重写。防止方法被篡改。</p>
</li>
<li><p>final类：不能被继承。</p>
</li>
</ul>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><ul>
<li>抽象类：不能实例化对象，唯一目的就是防止将来对该类进行扩充。不能同时被final和ststic修饰，如果包含抽象方法，必须声明成抽象类，否则出现编译错误。</li>
<li>抽象方法：抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</li>
</ul>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>ACID<ul>
<li>原子性：一个事务中的操作，要么全部成功，要么全部失败，如果失败，就回滚到事务开始前的状态。</li>
<li>一致性：从一个一致性状态变换到另一个一致性状态。AB转账，总金额不变。</li>
<li>隔离性：多个用户并发访问数据库，操作同一张表，每个用户开启事务，事务之间互不干扰，事务之间的仓发是隔离的。</li>
<li>持久性：事务一旦提交，数据库中的数据改变就是永久性的。</li>
</ul>
</li>
<li>四种隔离级别<ul>
<li>读未提交（Read uncommitted）：select不加锁，可能读到‘脏数据’，这是并发最高，一致性最差的隔离级别。</li>
<li>读已提交（Read committed）：避免‘脏数据’。</li>
<li>可重复读（Repeattable read）：默认隔离级别，避免脏读，不可重复读。</li>
<li>串行化（Serializable）：可避免脏读，不可重复读，幻读的发生。一致性最好，性能最差，一般不使用串行化和read uncommitted。</li>
</ul>
</li>
<li>#和$符号的区别<ul>
<li>#将传入的数据当成一个字符串，会自动加双引号。</li>
<li>#防止SQL注入</li>
<li>$会直接显示生成在SQL中</li>
</ul>
</li>
</ul>
<h1 id="面试问题记录"><a href="#面试问题记录" class="headerlink" title="面试问题记录"></a>面试问题记录</h1><h2 id="1-linux定位cpu占用率高问题"><a href="#1-linux定位cpu占用率高问题" class="headerlink" title="1.linux定位cpu占用率高问题"></a>1.linux定位cpu占用率高问题</h2><ul>
<li><p>top命令查到最占cpu的进程 <code>22686</code>。</p>
</li>
<li><p>pstack跟踪进程栈 <code>pstack 22686</code>。</p>
<p>该命令可以显示每个进程的栈追踪，如果发现一个服务一直处于work状态，在一段时间内，多次执行pstack，发现代码栈总是停在同一个位置，则需要重点关注。很有可能出了问题。</p>
</li>
<li><p>使用<code>top -H -p 22688</code>查看进程中最占用资源的线程，查到是22970。</p>
</li>
<li><p>使用线程的pid反查其对应的线程号。</p>
</li>
<li><p>pstack 22680|grep 22970—&gt;是thread10。</p>
</li>
<li><p>然后使用vim查看进程快照，定位到具体的线程，并查看其调用堆栈。</p>
</li>
</ul>
<h2 id="2-java1-8默认的垃圾收集器"><a href="#2-java1-8默认的垃圾收集器" class="headerlink" title="2.java1.8默认的垃圾收集器"></a>2.java1.8默认的垃圾收集器</h2><p>新生代的parallel scavenge（复制）+parallel old（标记整理）</p>
<h2 id="3-底层网络模型"><a href="#3-底层网络模型" class="headerlink" title="3.底层网络模型"></a>3.底层网络模型</h2><p><a href="https://victor-huihui.gitee.io/2020/04/19/%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/">参考链接</a></p>
<h2 id="4-java内存泄漏"><a href="#4-java内存泄漏" class="headerlink" title="4.java内存泄漏"></a>4.java内存泄漏</h2><p><strong>内存溢出：</strong>申请了10个字节的空间，但是在这个空间写入11或者以上的字节，出现溢出。</p>
<p><strong>内存泄漏：</strong>new申请内存，但是很久不用，但是因为一直被某些实例持有导致GC不能回收，就是应该释放的对象没有被释放。</p>
<h2 id="5-见过哪些弱引用和虚引用"><a href="#5-见过哪些弱引用和虚引用" class="headerlink" title="5.见过哪些弱引用和虚引用"></a>5.见过哪些弱引用和虚引用</h2><h2 id="6-设计一个文件格式，要考虑哪些问题"><a href="#6-设计一个文件格式，要考虑哪些问题" class="headerlink" title="6.设计一个文件格式，要考虑哪些问题"></a>6.设计一个文件格式，要考虑哪些问题</h2><p>操作系统中的文件系统。</p>
<h2 id="7-列存储"><a href="#7-列存储" class="headerlink" title="7.列存储"></a>7.列存储</h2><p><a href="https://victor-huihui.gitee.io/2021/03/24/Mysql/#%E8%A1%8C%E5%AD%98%E5%82%A8%E4%B8%8E%E5%88%97%E5%AD%98%E5%82%A8">在这篇笔记里</a></p>
<h2 id="8-Mysql复制问题"><a href="#8-Mysql复制问题" class="headerlink" title="8.Mysql复制问题"></a>8.Mysql复制问题</h2><p><a href="https://victor-huihui.gitee.io/2021/03/24/Mysql/#MYSQL%E5%A4%8D%E5%88%B6">在这里</a></p>
<h2 id="9-著名的topK问题"><a href="#9-著名的topK问题" class="headerlink" title="9.著名的topK问题"></a>9.著名的topK问题</h2><ul>
<li>排序</li>
<li>局部排序，比如用冒泡或者选择</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>审视</title>
    <url>/2020/03/30/%E5%AE%A1%E8%A7%86/</url>
    <content><![CDATA[<blockquote>
<p>人活着的时候审视自己是一种不痛不痒的审视。</p>
</blockquote>
<h1 id="大奶奶"><a href="#大奶奶" class="headerlink" title="大奶奶"></a>大奶奶</h1><p>大奶奶是奶奶的妯娌，得了小脑萎缩，疯言疯语成了常态。但是她认得我们。她最信任的人是我老叔，他倾诉最多的人，是我奶奶。她也认得我和小妹。可能在她那还清醒的脑区域，为这些她觉得无害的人，保留了少许位置。</p>
<p>大奶奶不是谁都信任。她整天疯言疯语的对象，是我的邻居，<strong>瞎奶奶</strong>。</p>
<p>我打记事起瞎奶奶眼睛就瞧不见。瞎奶奶家里卖醋，买来醋精兑上水，两毛钱装满一瓶。我小时候觉得醋是甜的，打醋回家的路上拧开盖子呷一口，甚是快活。瞎奶奶人也慈祥，身体有点不舒服去找瞎奶奶，她摸摸地再摸摸头，嘴里念着咒语，心里就觉得踏实。我向来胆子大，不肯信什么迷信，但是瞎奶奶的那一套，更像是一种心灵的安抚。</p>
<p>大奶奶骂瞎奶奶，小脑萎缩后这成了她业余生活的全部。</p>
<p>她一个人自言自语的时候没人知道，所以我理解她找奶奶倾诉是缓解自己的害怕。</p>
<p>我们每天吃晚饭大奶奶都要来看看，“你们还没吃吗？”这通常是大奶奶的第一套说辞。家里人招呼她坐下，她拿起凳子坐在我奶奶身边就开始了：“妹儿，你不知道，今天说要我把吃的给他，给她一箱，我为啥要给她啊，我这么大年纪了，我上哪给她弄去啊”。奶奶习惯了陪她演戏：“你别胡说了，人家都死了多少年了，，，，”。大奶奶只停了一下然后接着说，一边说着一边情绪激动，她把嘴里的那个人当成了这辈子最大的仇人。</p>
<p>我问奶奶：“他俩是有什么过节？”，奶奶说：“你听我跟你说，啥事也没有，年轻的时候，也不知谁管谁借了一瓢面，说是忘了还还是怎么的，就这样结下了梁子，谁知道她能记一辈子，你瞎奶奶可是个好人”。瞎奶奶生前，也是奶奶最好的朋友。</p>
<p>大奶奶逢人便说瞎奶奶，大家也都道她年纪大，认真的在敷衍她。她也跟我说，我问她：“你能看到她吗？”，大奶奶回到：“那哪能看到啊，看不见”。“那你怎么听见她说话？”。“那能听见，走到哪都能听见，去哪里她都跟着”。她说的及其认真，仿佛那个人就站在眼前，别人怎么劝都没用，那是她心头的结。</p>
<p>奶奶这辈人，经历过太多事情，听见过炮弹声，挣过工分换饭吃，甚至三年自然灾害也捡了条命。他们从不和平走向和平，从挨饿到衣食无忧。所以他们走的一遭真正该记住的东西是什么？大奶奶的答案却是这样的。</p>
<p>没人会真正的理解大奶奶的处境，人家都只说这个老妈子老了病了，可怜但是没办法。她自己就像活在一个梦魇里，在她看来噩梦似乎一直没醒。噩梦里没什么世界末日的灾难，只是两个年轻的姑娘在你一言我一语的斗嘴，一转眼都老了，一个人没挺过去先走了，另一个人埋在心里成了疙瘩，这结就再也解不开了。她什么也没记住，关于这一生的记忆就剩这么点了，但是她把好人坏人分的真明白。<strong>人心里的秤杆最错不了。</strong></p>
<p>我希望大奶奶的梦能醒来，她饶过自己。</p>
<p>而我回家路上又呷了一口甜美的醋。</p>
<p><strong>谁又能饶过自己。</strong></p>
<img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200331023927.jpg" width="300" alt="审视" style="border-radius:50%">

<hr>
<h1 id="喜棺"><a href="#喜棺" class="headerlink" title="喜棺"></a>喜棺</h1><blockquote>
<p>那些自认为活的通透的人，你能不能告诉我，我们到底该如何正视死亡？</p>
</blockquote>
<p>五百口人的小村庄被一条恶臭的小河隔开。</p>
<p>小河原本是不臭的，冬天结了很厚的冰，老实的农村爷们搬了张桌子在上面打麻将。村子也热闹，我跟着父亲去地里看庄稼，村里一位比我大结了婚的哥哥开玩笑把我的裤子脱了下来，我抹不开面，提上裤子骂他娘。从那以后，他每次看到我一个人的时候，都扬言要打我，我至今仍讨厌他，他也没敢真的打我。</p>
<p>小河的一侧是我家挨着瞎奶奶家，小河的另一侧，住着我儿时的玩伴–蹦蹦。</p>
<p>大一点的孩子没人愿意同蹦蹦玩的，我妈也不让我和蹦蹦玩，但是他总来找我。他吃了饭就来我家的院子里等我。家里的名字千奇百怪，阿猫阿狗都有叫的。蹦蹦的名字大概是因为他很会蹦，可能是因为他太会蹦了，他走路东倒西歪的走不好，他也不太聪明。我记得蹦蹦是读过两天书的，但是他的书不是丢了就是被撕没了。他现在在家吃着残疾人低保，见了我也并不打招呼。</p>
<p>主人公是蹦蹦的奶奶。</p>
<p>这期间工作多停了几天，直到今天早上得知主人公已经去世。</p>
<p>我出门听见河对过满院子的哭声，心里百感交集。我没想过要以文学的手法表现这世间的疾苦，这每一句话，都是我努力找到一个最准确的回忆，最真实的记录。如您所见，抛开别的不谈，这世间如此残忍。一遭一遭的总会变了样子，活着的人感叹、思考、也开心也难过，死的人呢，再疾苦也好，快乐也好，也都消失不见了。</p>
<p>河这边的我们准备吃烤鱼，我下午忙着开会，精神欠佳。</p>
<p>河那边的他们，用哭声送死者最后一程。</p>
<p>逝者安息。</p>
]]></content>
      <categories>
        <category>听个故事吧</category>
      </categories>
      <tags>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title>底层网络IO模型</title>
    <url>/2020/04/19/%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本文摘自<a href="https://developer.51cto.com/art/202010/628344.htm?pc">五种IO模型</a></p>
<ul>
<li>BIO：阻塞IO</li>
<li>NIO：非阻塞IO</li>
<li>MIO：IO多路复用</li>
<li>SIO：信号驱动IO</li>
<li>AIO：异步IO</li>
</ul>
<p>根据冯诺依曼结构，计算机分为5个部分，分别是：运算器、控制器、存储器、输入设备、输出设备。IO描述了计算机系统与外部设备之间的通信过程。</p>
<h1 id="Unix网络编程中的五种IO模型"><a href="#Unix网络编程中的五种IO模型" class="headerlink" title="Unix网络编程中的五种IO模型"></a>Unix网络编程中的五种IO模型</h1><h2 id="阻塞IO——Blocking-IO"><a href="#阻塞IO——Blocking-IO" class="headerlink" title="阻塞IO——Blocking IO"></a>阻塞IO——Blocking IO</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/5108c314bdae4d18ea91c8dd2969ef0f.jpg-wh_600x-s_1540292916.jpg" alt="img"></p>
<p>最传统的IO模型，在读写数据的过程中会发生阻塞现象。</p>
<p>用户线程发出IO请求，内核先去查看数据是否就绪，如果没有就绪就会等待数据就绪，此时用户线程处于阻塞状态，交出CPU。数据就绪之后，内核将数据拷贝到用户线程，返回结果给用户线程，线程结束阻塞状态。</p>
<h2 id="非阻塞IO——NoneBlocking-IO"><a href="#非阻塞IO——NoneBlocking-IO" class="headerlink" title="非阻塞IO——NoneBlocking IO"></a>非阻塞IO——NoneBlocking IO</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/92fd6efb11936b879561931f1e895f02.jpg-wh_600x-s_2030517755.jpg" alt="img"></p>
<p>用户发送一个IO操作后，不需要等待，马上得到一个结果。如果结果是一个error时，就知道数据还没有准备好，于是可以再次发送IO操作。一旦内核的数据准备好了，并且再次收到了用户线程的请求，马上将数据拷贝到用户线程，然后返回。</p>
<p>在非阻塞IO中，用户线程需要不断的询问内核数据是否就绪，说明NIO不会交出自己的CPU时间片，一直占用。对于非阻塞IO来说，一个严重的问题就是，在while循环中需要不断去询问数据是否就绪，这样会导致CPU占用率高，因为一般情况下很少使用while循环的方式来读取数据。</p>
<ul>
<li>非阻塞式主要体现在用户进程发起recvfrom系统调用的时候，这个时候系统内核还没有接收到数据报，直接返回错误给用户进程。</li>
<li>用户接收到消息，但是不知道什么时候数据报可达，于是开始不断轮询（polling）想系统内核发起recvfrom的系统调用。</li>
<li>用户进程轮询发起recvfrom系统调用直到数据报可达，这个时候等待系统内核复制数据报到用户进程的缓冲区，复制完成之后返回成功提示。</li>
</ul>
<h2 id="IO多路复用——IO-Multiplexing"><a href="#IO多路复用——IO-Multiplexing" class="headerlink" title="IO多路复用——IO Multiplexing"></a>IO多路复用——IO Multiplexing</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/3f9a924f4b90ce4e1be2f87ec25dbe53.jpg-wh_600x-s_915420489.jpg" alt="img"></p>
<p>IO多路复用中，线程首先发起select调用，询问内核数据是否准备就绪，等内核吧数据准备好了，用户线程发起read调用。read调用的过程（数据从内核空间–&gt;用户空间）还是阻塞的。</p>
<p>通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者是写就绪），能通知程序进行相应的读写操作，需要select，poll，epoll配合</p>
<p>在多路复用IO模型中，会有一个内核线程不断的轮询多个socket的状态，只有当真正读写事件发送时，才会调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，大大减少资源占用。</p>
<ul>
<li>IO复用模式是使用select或者poll函数向系统内核发起调用，阻塞在这两个系统函数调用，而不是真正阻塞于实际的IO操作(recvfrom调用才是实际阻塞IO操作的系统调用)</li>
<li>阻塞于select函数的调用,等待数据报套接字变为可读状态</li>
<li>当select套接字返回可读状态的时候,就可以发起recvfrom调用把数据报复制到用户空间的缓冲区</li>
</ul>
<h2 id="信号驱动——signal-driven-IO"><a href="#信号驱动——signal-driven-IO" class="headerlink" title="信号驱动——signal driven IO"></a>信号驱动——signal driven IO</h2><p>在信号驱动的IO模型中，用户线程发起一个IO请求操作，会给对用的socket注册一个信号函数，然后用户线程继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接到信号后，在信号函数中调用IO读写操作来进行实际的IO请求操作。一般用于UDP中，对TCP套接字基本没用，原因是信号产生的过于频繁，并且信号的出现没有告诉我们发生了什么请求。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/65d1e77c0b548cba43d6443fc8bcaf69.jpg-wh_600x-s_1923680265.jpg" alt="img"></p>
<p>用户进程可以使用信号方式，当系统内描述符就绪时就会发送SIGNO给到用户空间，这个时候再发起recvfrom的系统调用等待返回成功提示：</p>
<ul>
<li>开启套接字的信息IO启动功能，并通过一个内置安装信号处理函数signaction系统调用，发起调用之后直接返回。</li>
<li>其次，等待内核从网络中接收到数据报之后，向用户控件发送当前数据可达的信号给信号处理函数。</li>
<li>信号处理函数接收到信息就发起recvfrom系统调用等待内核数据复制到用户空间的缓存区。</li>
<li>接收到复制完成的返回成功提示后，应用进程就可以开始从网络中读取数据。</li>
</ul>
<h2 id="异步IO——asynchronous-IO"><a href="#异步IO——asynchronous-IO" class="headerlink" title="异步IO——asynchronous IO"></a>异步IO——asynchronous IO</h2><p>前面的四种属于同步IO，最后一种是异步IO，因为无论是多路复用还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程中都会让用户线程阻塞。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/71a71eda4f0d6715d07f0a75a129e09b.jpg" alt="71a71eda4f0d6715d07f0a75a129e09b"></p>
<ul>
<li>由POSIX规范定义，告知系统内核启动某个操作，并让内核在整个操作包含数据库等待以及数据复制古城完成之后告知用户进程数据已经准备完成。</li>
<li>与上述的信号IO模型区别在于异步是通知我们合适IO操作完成，而信号IO是通知我们何时可以启动一个IO操作。</li>
</ul>
<h2 id="同步IO与异步IO"><a href="#同步IO与异步IO" class="headerlink" title="同步IO与异步IO"></a>同步IO与异步IO</h2><ul>
<li>同步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程一直处于等待状态,这时候进程被阻塞,直到IO操作完成返回成功提示</li>
<li>异步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程将直接返回一个错误信息,“相当于告诉进程还没有处理好,好了会通知你”</li>
<li>阻塞IO: 主要是体现发起IO操作请求通知内核并且内核接收到信号之后如果让进程等待,那么就是阻塞</li>
<li>非阻塞IO: 发起IO操作请求的时候不论结果直接告诉进程“不用等待,晚点再来”,那就是非阻塞</li>
</ul>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习笔记</title>
    <url>/2021/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概念功能和目标"><a href="#概念功能和目标" class="headerlink" title="概念功能和目标"></a>概念功能和目标</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E6%A6%82%E8%A7%88.png" alt="概览"></p>
<h2 id="OS的特征"><a href="#OS的特征" class="headerlink" title="OS的特征"></a>OS的特征</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210418150912681.png" alt="image-20210418150912681"></p>
<h2 id="OS的发展和分类"><a href="#OS的发展和分类" class="headerlink" title="OS的发展和分类"></a>OS的发展和分类</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/OS%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB.png" alt="OS的发展与分类"></p>
<h2 id="OS的运行机制与体系结构"><a href="#OS的运行机制与体系结构" class="headerlink" title="OS的运行机制与体系结构"></a>OS的运行机制与体系结构</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/OS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="OS运行机制与体系结构"></p>
<blockquote>
<p>指令：CPU能识别，执行的最基本指令。</p>
</blockquote>
<p>内核计算机配置的底层软件，是OS最基本，最核心的部分。实现OS内核功能的那些程序就是内核程序。</p>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><ul>
<li>发生中断时，CPU立即进入和心态。</li>
<li>发生中断后，当前运行的程序暂停运行，并由OS内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同处理。</li>
</ul>
<blockquote>
<p>用户态到系统态的切换时通过中断实现的，并且中断是唯一途径。</p>
<p>核心态到用户态的切换时通过执行一个特权指令，将程序状态字（PSW）的标志位设置成“用户态”。</p>
</blockquote>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>文件漏洞渗透</title>
    <url>/2020/09/17/%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h2 id="靶机安装"><a href="#靶机安装" class="headerlink" title="靶机安装"></a>靶机安装</h2><p>使用docker快速启动</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull area39&#x2F;webug</span><br></pre></td></tr></table></figure>

 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -P area39&#x2F;webug</span><br></pre></td></tr></table></figure>

<p><a href="https://link.zhihu.com/?target=http://127.0.0.1:32768/">http://127.0.0.1:32768/</a></p>
  <img src="https://i.loli.net/2020/09/16/sWUDXABMPhinFYo.png" alt="image-20200916153639264" style="zoom: 67%;" />

<h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><p>文件上传是大部分web应用具备的功能，如果开发人员不进行严格的校验，导致PHP，ASP等执行文件绕过应用并顺利执行，则相当于直接拿到了webshell，一旦拿到webshell，就可以拿到web数据，删除web文件，本地提权，进一步拿下整个服务器甚至内网。</p>
<p>sql注入攻击的对象是数据库服务，文件上传漏洞攻击的是web服务，实际渗透中两种相结合，达到对目标的深度渗透。</p>
<h2 id="木马文件"><a href="#木马文件" class="headerlink" title="木马文件"></a>木马文件</h2><p>如果开发人员设置了mime类型校验，导致可执行文件无法上传，就需要使用第三方工具<strong>BRUPSUITE代理</strong>。默认的拦截功能是开启的。</p>
<p>默认的代理是在本机上，可以在option设置所有代理。然后你会神奇的发现，我们的一句话木马已经上传成功了。然后拿出中国菜刀。</p>
<img src="https://i.loli.net/2020/09/16/9INUifFnMO5VQcH.png" alt="image-20200916160850568" style="zoom:67%;" />

<p>更高级的限制是<strong>限制文件的拓展名</strong>。</p>
<ul>
<li><p><strong>Webshell</strong></p>
<ul>
<li><p>小马：一句话木马也称为小马，整个shell只有一行，一般是系统执行函数</p>
</li>
<li><p>大马：代码量和功能比小马多，一般会进行二次编码加密，防止被防火墙/入侵系统检测到</p>
<p><img src="https://i.loli.net/2020/09/16/WTKg1mJuOIztHvb.png" alt="image-20200916163940089"></p>
</li>
</ul>
</li>
<li><p><strong>中国菜刀</strong>：在被防火墙删了几次文件后，我决定用图片了。。</p>
<p>REQUEST是在网页输入变量访问，POST则是使用像中国菜刀之类的工具连接，是C/s架构</p>
<p><img src="https://i.loli.net/2020/09/16/U8CNLMAEngPkzbI.png" alt="image-20200916164124831"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>文件上传渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/04/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>小知识来源于<a href="https://www.liaoxuefeng.com/">廖雪峰老师</a>的博客</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>正则表达式可以用字符串来描述规则，并用来匹配字符串。</strong>一个正则表达式就是一个描述规则的字符串，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。是一套标准，java在java.util.regex，使用简单，java用\\表示\。</p>
<p>用正则表达式匹配字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;20\\d\\d&quot;</span>;</span><br><span class="line">        sout(<span class="string">&quot;2019.matches(regex)&quot;</span>);<span class="comment">//true</span></span><br><span class="line">        sout(<span class="string">&quot;2020.matches(regex)&quot;</span>);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><ul>
<li><p><strong>精准匹配</strong></p>
<p>从左到右按照规则匹配。\是转义字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    psvm(String[] args)&#123;</span><br><span class="line">        String re1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        sout(<span class="string">&quot;abc&quot;</span>.matches(re1));<span class="comment">//t</span></span><br><span class="line">        sout(<span class="string">&quot;Abc&quot;</span>.matches(re1));<span class="comment">//f</span></span><br><span class="line">        sout(<span class="string">&quot;abcd&quot;</span>.matches(re1));<span class="comment">//f</span></span><br><span class="line">        </span><br><span class="line">        String re2 = <span class="string">&quot;a\\&amp;c&quot;</span>;</span><br><span class="line">        sout(<span class="string">&quot;a&amp;c&quot;</span>.matches(re2));<span class="comment">//t</span></span><br><span class="line">        sout(<span class="string">&quot;a-c&quot;</span>.matches(re2));<span class="comment">//f</span></span><br><span class="line">        sout(<span class="string">&quot;a&amp;&amp;c&quot;</span>.matches(re2));<span class="comment">//f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>匹配任意字符(.)</strong></p>
<p>精准匹配用处不大，用String.equals()就可以实现，用  .  来实现模糊匹配，可以匹配任何字符。a.c可以匹配abc，a$c，a%c。但是不能匹配ac，a%%c。只能匹配一个字符。</p>
</li>
<li><p><strong>匹配数字(\d)</strong></p>
<p>\d可以匹配数字，例如00\d可以匹配008，009。不匹配00A，0077。</p>
</li>
<li><p><strong>匹配常用字符(\w)</strong></p>
<p>\w匹配一个字母，数字或者下划线</p>
</li>
<li><p><strong>匹配空格(\s)</strong></p>
<p>不但包括空格字符，还包括tab字符(\t)。</p>
</li>
<li><p><strong>匹配非数字(\D)</strong></p>
<p>用<code>\d</code>可以匹配一个数字，而<code>\D</code>则匹配一个非数字。例如，<code>00\D</code>可以匹配：</p>
<ul>
<li><code>&quot;00A&quot;</code>，因为<code>\D</code>可以匹配非数字字符<code>A</code>；</li>
<li><code>&quot;00#&quot;</code>，因为<code>\D</code>可以匹配非数字字符<code>#</code>。</li>
</ul>
<p>但是不能匹配007  008这些，类似的，<code>\W</code>可以匹配<code>\w</code>不能匹配的字符，<code>\S</code>可以匹配<code>\s</code>不能匹配的字符，这几个正好是反着来的。</p>
</li>
<li><p><em><em>重复匹配(</em> + ? {n})</em>*</p>
<ul>
<li><p>*：匹配任意个字符，包括0个。A\d*—A，A0，A380</p>
</li>
<li><p>+：至少一个字符</p>
</li>
<li><p>？：0个或者一个字符</p>
</li>
<li><p>{n}：匹配n个字符。A\d{3}—&gt;A349</p>
</li>
<li><p>{n,m}：匹配n-m个字符。A\d{3,5}—&gt;A123,A1234,A12345，没有上限用{n,}</p>
</li>
</ul>
</li>
<li><p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">规则</th>
<th align="left">可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>A</code></td>
<td align="left">指定字符</td>
<td align="left"><code>A</code></td>
</tr>
<tr>
<td align="left"><code>\u548c</code></td>
<td align="left">指定Unicode字符</td>
<td align="left"><code>和</code></td>
</tr>
<tr>
<td align="left"><code>.</code></td>
<td align="left">任意字符</td>
<td align="left"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td>
</tr>
<tr>
<td align="left"><code>\d</code></td>
<td align="left">数字0~9</td>
<td align="left"><code>0</code>~`9`</td>
</tr>
<tr>
<td align="left"><code>\w</code></td>
<td align="left">大小写字母，数字和下划线</td>
<td align="left"><code>a</code><del><code>z</code>，<code>A</code></del><code>Z</code>，<code>0</code>~`9<code>，</code>_`</td>
</tr>
<tr>
<td align="left"><code>\s</code></td>
<td align="left">空格、Tab键</td>
<td align="left">空格，Tab</td>
</tr>
<tr>
<td align="left"><code>\D</code></td>
<td align="left">非数字</td>
<td align="left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
<tr>
<td align="left"><code>\W</code></td>
<td align="left">非\w</td>
<td align="left"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td>
</tr>
<tr>
<td align="left"><code>\S</code></td>
<td align="left">非\s</td>
<td align="left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">规则</th>
<th align="left">可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>A*</code></td>
<td align="left">任意个数字符</td>
<td align="left">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td align="left"><code>A+</code></td>
<td align="left">至少1个字符</td>
<td align="left"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td align="left"><code>A?</code></td>
<td align="left">0个或1个字符</td>
<td align="left">空，<code>A</code></td>
</tr>
<tr>
<td align="left"><code>A&#123;3&#125;</code></td>
<td align="left">指定个数字符</td>
<td align="left"><code>AAA</code></td>
</tr>
<tr>
<td align="left"><code>A&#123;2,3&#125;</code></td>
<td align="left">指定范围个数字符</td>
<td align="left"><code>AA</code>，<code>AAA</code></td>
</tr>
<tr>
<td align="left"><code>A&#123;2,&#125;</code></td>
<td align="left">至少n个字符</td>
<td align="left"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td>
</tr>
<tr>
<td align="left"><code>A&#123;0,3&#125;</code></td>
<td align="left">最多n个字符</td>
<td align="left">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="复杂匹配规则"><a href="#复杂匹配规则" class="headerlink" title="复杂匹配规则"></a>复杂匹配规则</h2><ul>
<li><p><strong>匹配开头和匹配结尾</strong></p>
<p><button>^</button>表示开头，<button>表示结尾</button>，<button>^A\d{3}$</button>可以匹配<code>A001</code>，<code>A380</code></p>
</li>
<li><p><strong>匹配指定范围</strong></p>
<p>[…]可以匹配范围内的字符，例如[123456789]匹配1-9，电话号码的规则[123456789]\d{6,7}</p>
<p>或者[1-9]\d{6,7}</p>
<p>匹配大小写不限的16进制数，比如<button>1A2b3c</button>，[0-91-fA-F]，他可以匹配</p>
<ul>
<li>0-9</li>
<li>a-f</li>
<li>A-F</li>
</ul>
</li>
<li><p><strong>或匹配规则</strong></p>
</li>
<li><p><strong>使用括号</strong></p>
</li>
<li><p><strong>小结</strong></p>
</li>
</ul>
<h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2>]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>小知识集锦-1</tag>
      </tags>
  </entry>
  <entry>
    <title>用Vue实现Player</title>
    <url>/2020/03/23/%E7%94%A8Vue%E5%AE%9E%E7%8E%B0Player/</url>
    <content><![CDATA[<p>项目中用到Vue，虽然没写前端，但是有时候需要测试和部署项目，懂得vue的网络请求就很重要。之前学过一点h5,js,css这些。这里主要是想学习一下vue+axios网络请求，跟着B站的大佬做了一个<a href="https://victor-huihui.gitee.io/2020/03/23/Player/">音乐播放器</a>，图片资源上传sm.ms图床。这里贴一下完整的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>朱会会的云播放器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 样式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-tag">ul</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-tag">dl</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-tag">dd</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .wrap &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;https://i.loli.net/2020/03/23/gz9abCBAcphv6jF.jpg&quot;</span>) no-repeat;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .play_wrap &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">544px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>: -<span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: -<span class="number">272px</span>;</span></span><br><span class="line"><span class="css">      <span class="comment">/* background-color: #f9f9f9; */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .search_bar &#123;</span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#1eacda</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-top-left-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-top-right-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">11</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.search_bar</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>: <span class="number">23px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.search_bar</span> <span class="selector-tag">input</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-right</span>: <span class="number">23px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">296px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">34px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-radius</span>: <span class="number">17px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;https://i.loli.net/2020/03/23/9FeKnVlohsY3krO.png&quot;</span>) <span class="number">265px</span> center no-repeat</span></span><br><span class="line">      rgba(255, 255, 255, 0.45);</span><br><span class="line"><span class="css">      <span class="attribute">text-indent</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">outline</span>: none;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .center_con &#123;</span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">435px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .song_wrapper &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">435px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .song_stretch &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .song_list &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow-y</span>: auto;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow-x</span>: hidden;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .song_list::-webkit-scrollbar &#123;</span><br><span class="line"><span class="css">      <span class="attribute">display</span>: none;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">580px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(odd) &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>, <span class="number">0.3</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">17px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">17px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;https://i.loli.net/2020/03/23/chJ89uNpofneFrS.png&quot;</span>);</span></span><br><span class="line"><span class="css">      <span class="attribute">background-size</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">b</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-weight</span>: normal;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">122px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">      <span class="attribute">text-overflow</span>: ellipsis;</span></span><br><span class="line"><span class="css">      <span class="attribute">white-space</span>: nowrap;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_stretch</span> <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">b</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_stretch</span> <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">em</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">23px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">17px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-right</span>: <span class="number">50px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> <span class="selector-tag">i</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;https://i.loli.net/2020/03/23/HFyBnJ5loLhI7qK.png&quot;</span>) left -<span class="number">48px</span> no-repeat;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">em</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.song_list</span> <span class="selector-tag">li</span> <span class="selector-tag">i</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .player_con &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">435px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .player_con2 &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">435px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.player_con2</span> <span class="selector-tag">video</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">355px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">265px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .disc &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">73px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">9</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .cover &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">125px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">112px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-radius</span>: <span class="number">75px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">8</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .comment_wrapper &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">180px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">435px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">10px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .comment_wrapper .title &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .comment_wrapper .comment_list &#123;</span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">410px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .comment_wrapper .comment_list::-webkit-scrollbar &#123;</span><br><span class="line"><span class="css">      <span class="attribute">display</span>: none;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.comment_wrapper</span> <span class="selector-tag">dl</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding-left</span>: <span class="number">55px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.comment_wrapper</span> <span class="selector-tag">dt</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">10px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.comment_wrapper</span> <span class="selector-tag">dt</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.comment_wrapper</span> <span class="selector-tag">dd</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .comment_wrapper .name &#123;</span><br><span class="line"><span class="css">      <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding-top</span>: <span class="number">5px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .comment_wrapper .detail &#123;</span><br><span class="line"><span class="css">      <span class="attribute">color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">line-height</span>: <span class="number">18px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .audio_con &#123;</span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#f1f3f4</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-bottom-left-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-bottom-right-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .myaudio &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">outline</span>: none;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#f1f3f4</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 旋转的动画 */</span></span></span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> Rotate &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 旋转的类名 */</span></span></span><br><span class="line">    .autoRotate &#123;</span><br><span class="line"><span class="css">      <span class="attribute">animation-name</span>: Rotate;</span></span><br><span class="line"><span class="css">      <span class="attribute">animation-iteration-count</span>: infinite;</span></span><br><span class="line"><span class="css">      <span class="attribute">animation-play-state</span>: paused;</span></span><br><span class="line"><span class="css">      <span class="attribute">animation-timing-function</span>: linear;</span></span><br><span class="line"><span class="css">      <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 是否正在播放 */</span></span></span><br><span class="line">    .player_con.playing .disc,</span><br><span class="line">    .player_con.playing .cover &#123;</span><br><span class="line"><span class="css">      <span class="attribute">animation-play-state</span>: running;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .play_bar &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: -<span class="number">10px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">10</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">25deg</span>);</span></span><br><span class="line"><span class="css">      <span class="attribute">transform-origin</span>: <span class="number">12px</span> <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">transition</span>: <span class="number">1s</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 播放杆 转回去 */</span></span></span><br><span class="line">    .player_con.playing .play_bar &#123;</span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/* 搜索历史列表 */</span></span></span><br><span class="line">    .search_history &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">296px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.3</span>);</span></span><br><span class="line"><span class="css">      <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">      <span class="attribute">right</span>: <span class="number">23px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-radius</span>: <span class="number">17px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.search_history</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">line-height</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .switch_btn &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .right_line &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.video_con</span> <span class="selector-tag">video</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">546px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: -<span class="number">273px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">990</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .video_con .mask &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">980</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">    .video_con .shutoff &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;https://i.loli.net/2020/03/23/ZWSChyBwjA5uRfL.png&quot;</span>) no-repeat;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: -<span class="number">273px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">z-index</span>: <span class="number">995</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;play_wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;player&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search_bar&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://sm.ms/image/FO95hAIXyZqoHct&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 搜索歌曲 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入要搜索的Music&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;query&#x27;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;searchMusic();&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center_con&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 搜索歌曲列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;song_wrapper&#x27;</span> <span class="attr">ref</span>=<span class="string">&#x27;song_wrapper&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;song_list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in musicList&quot;</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 点击放歌 --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> @<span class="attr">click</span>=<span class="string">&#x27;playMusic(item.id)&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">i</span> @<span class="attr">click</span>=<span class="string">&quot;playMv(item.mvid)&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;item.mvid!=0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/03/23/dor23bhZtIvK17X.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;switch_btn&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 歌曲信息容器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;player_con&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;playing:isPlay&#125;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/03/23/gZHko2WlpJNcGPv.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;play_bar&quot;</span> /&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 黑胶碟片 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/03/23/hQPuH4gNRx7XayI.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;disc autoRotate&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;coverUrl==&#x27;&#x27;?&#x27;https://i.loli.net/2020/03/23/QEL4rdy5KCsn3cz.png&#x27;:coverUrl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cover autoRotate&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 评论容器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment_wrapper&quot;</span> <span class="attr">ref</span>=<span class="string">&#x27;comment_wrapper&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span>热门留言<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;comment_list&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dl</span> <span class="attr">v-for</span>=<span class="string">&quot;item in hotComments&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.user.avatarUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dd</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123;item.user.nickname&#125;&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dd</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123;item.content&#125;&#125;</span><br><span class="line">              <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/03/23/dor23bhZtIvK17X.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;right_line&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;audio_con&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">audio</span> <span class="attr">ref</span>=<span class="string">&#x27;audio&#x27;</span> @<span class="attr">play</span>=<span class="string">&quot;play&quot;</span> @<span class="attr">pause</span>=<span class="string">&quot;pause&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;musicUrl&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">class</span>=<span class="string">&quot;myaudio&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video_con&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;showVideo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">video</span> <span class="attr">ref</span>=<span class="string">&#x27;video&#x27;</span> <span class="attr">:src</span>=<span class="string">&quot;mvUrl&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mask&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;closeMv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 官网提供的 axios 在线地址 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置axios的基地址</span></span></span><br><span class="line"><span class="javascript">    axios.defaults.baseURL = <span class="string">&#x27;https://autumnfish.cn&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 实例化vue</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&quot;#player&quot;</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// 搜索关键字</span></span></span><br><span class="line"><span class="javascript">        query: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 歌曲列表</span></span></span><br><span class="line">        musicList: [],</span><br><span class="line"><span class="javascript">        <span class="comment">// 歌曲url</span></span></span><br><span class="line"><span class="javascript">        musicUrl: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 是否正在播放</span></span></span><br><span class="line"><span class="javascript">        isPlay: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 歌曲热门评论</span></span></span><br><span class="line">        hotComments: [],</span><br><span class="line"><span class="javascript">        <span class="comment">// 歌曲封面地址</span></span></span><br><span class="line"><span class="javascript">        coverUrl: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 显示视频播放</span></span></span><br><span class="line"><span class="javascript">        showVideo: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// mv地址</span></span></span><br><span class="line"><span class="javascript">        mvUrl: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">// 方法</span></span></span><br><span class="line">      methods: &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// 搜索歌曲</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">searchMusic</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (<span class="built_in">this</span>.query == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span></span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          axios.get(<span class="string">&#x27;/search?keywords=&#x27;</span> + <span class="built_in">this</span>.query).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 保存内容</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.musicList = response.data.result.songs;</span></span><br><span class="line"></span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="comment">// 清空搜索</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.query = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 播放歌曲</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">playMusic</span>(<span class="params">musicId</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 获取歌曲url</span></span></span><br><span class="line"><span class="javascript">          axios.get(<span class="string">&#x27;/song/url?id=&#x27;</span> + musicId).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 保存歌曲url地址</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.musicUrl = response.data.data[<span class="number">0</span>].url</span></span><br><span class="line">          &#125;)</span><br><span class="line"><span class="javascript">          <span class="comment">// 获取歌曲热门评论</span></span></span><br><span class="line"><span class="javascript">          axios.get(<span class="string">&#x27;/comment/hot?type=0&amp;id=&#x27;</span> + musicId).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(response)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 保存热门评论</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.hotComments = response.data.hotComments</span></span><br><span class="line"></span><br><span class="line">          &#125;)</span><br><span class="line"><span class="javascript">          <span class="comment">// 获取歌曲封面</span></span></span><br><span class="line"><span class="javascript">          axios.get(<span class="string">&#x27;/song/detail?ids=&#x27;</span> + musicId).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(response)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 设置封面</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.coverUrl = response.data.songs[<span class="number">0</span>].al.picUrl</span></span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// audio的play事件</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">play</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.isPlay = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 清空mv的信息</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.mvUrl = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// audio的pause事件</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">pause</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.isPlay = <span class="literal">false</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 播放mv</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">playMv</span>(<span class="params">vid</span>)</span> &#123;</span></span><br><span class="line">          if (vid) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.showVideo = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取mv信息</span></span></span><br><span class="line"><span class="javascript">            axios.get(<span class="string">&#x27;/mv/url?id=&#x27;</span> + vid).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// console.log(response)</span></span></span><br><span class="line"><span class="javascript">              <span class="comment">// 暂停歌曲播放</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">this</span>.$refs.audio.pause()</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 获取mv地址</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">this</span>.mvUrl = response.data.data.url</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 关闭mv界面</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">closeMv</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.showVideo = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$refs.video.pause()</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 搜索历史记录中的歌曲</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">historySearch</span>(<span class="params">history</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.query = history</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.searchMusic()</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.showHistory = <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>算法框架</title>
    <url>/2020/04/10/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2020/04/09/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>水杉在线是一个分布式系统，事实上我们实验室的技术栈一直在努力的向当前主流的技术看齐，所以我们会考虑分布式，考虑云原生等等。说到分布式系统，有些概念不得不说。</p>
<p>对于分布式系统来说，最大的难点就是各个节点如何同步。CAP是这方面的基本定理。</p>
<p>CAP指的是：一致性（consistency）、可用性（Availability）和分区容错性（Partitiontolerance）。对于一个系统来说，不可能同时满足以下三点：</p>
<ul>
<li>C：所有节点访问一份最新的数据副本</li>
<li>A：每次请求都能获取到非错的响应-但是不保证获取的数据是最新数据。</li>
<li>P：实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，Juin意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<h2 id="数据一致性模型"><a href="#数据一致性模型" class="headerlink" title="数据一致性模型"></a>数据一致性模型</h2><p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，将数据的不同副本存放在不同的机器，但是维护数据副本的代价高，因此很多系统采用弱一致性：</p>
<ul>
<li>强一致性：无论更新操作在哪一个副本执行，之后所有的读操作都要获取到最新的数据。</li>
<li>弱一致性：用户读到某一数据的更新需要一定时间，这段时间称为不一致性窗口。</li>
<li>最终一致性：弱一致性的一种特例，保证用户最终能够读到数据的更新。</li>
</ul>
<p><strong>一致性解决方案：</strong></p>
<ul>
<li>分布式事务：两段提交</li>
<li>分布式锁</li>
<li>MQ消息持久化 重试 幂等</li>
<li>Paxos算法</li>
</ul>
<h2 id="服务可用性"><a href="#服务可用性" class="headerlink" title="服务可用性"></a>服务可用性</h2><p>可用性是指只要收到用户请求，服务器就必须给出回应。</p>
<p><strong>高可用的解决方案：</strong></p>
<ul>
<li>负载均衡</li>
<li>降级：服务器压力剧增的时候，根据业务情况和流量对一些服务有策略的降级，释放资源保证核心任务的平稳运行。</li>
<li>熔断：对于目标服务的请求和调用大量失败，熔断该服务的所有调用，并且对于后续调用直接返回，从而快速释放资源，确保目标服务在不可用的这段时间内，所有对他的调用都是立即返回的，不会阻塞。</li>
<li>流量控制</li>
<li>异地多活</li>
</ul>
<h2 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h2><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p>分区容错无法避免，因此，P总是成立，那么C和A无法同时做到啊。</p>
<h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><ul>
<li><p>系统拆分</p>
<p>将一个系统拆分成多个子系统，然后每个系统连一个数据库。</p>
</li>
<li><p>缓存</p>
<p>大部分的高并发场景都是读多写少，数据库和缓存都存一份，然后大量走缓存。redis单机可以几万的并发。</p>
</li>
<li><p>MQ</p>
<p>对于高频率写的情况，redis就无能为力了，这时候可以把大量的写请求存入MQ，后边系统消费之后再慢慢的写，控制在MySQL承载范围之内。所以可以考虑用MQ来异步写，提高并发性。</p>
</li>
<li><p>分库分表</p>
<p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 SQL 跑的性能。</p>
</li>
<li><p>读写分离</p>
<p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p>
</li>
<li><p>ES</p>
<p>ES 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 ES 来承载，还有一些全文搜索类的操作，也可以考虑用 ES 来承载。</p>
</li>
</ul>
<h2 id="高并发下的流量控制"><a href="#高并发下的流量控制" class="headerlink" title="高并发下的流量控制"></a>高并发下的流量控制</h2><p>如果不进行流量控制，服务器会承受很大的压处理压力。请求量很高，服务器负载也很高，超过极限时系统崩溃，导致所有人不能访问。</p>
<p>为了实现服务高可用，可以对大流量请求进行限流，拦截掉大部分请求，只允许一部分请求可以真正进入服务器。</p>
<p><code>令牌桶</code>，<code>漏桶</code>，<code>计数器</code>是常用的三种限流算法。</p>
<h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><ul>
<li><p>计数器</p>
<p>qps是100，从第一个请求开始算，在接下来的1s，每次一个请求，计数器+1，到100之后就会拒绝所有的请求，然后在下一秒计数器恢复为0.</p>
<p>算法有一个弊端，就是在1s的前10ms，已经通过了100个请求，后面的都会拒绝，这种现象称为<strong>突刺现象</strong>。</p>
</li>
<li><p>漏桶</p>
<p>算法内部有个容器，请求进来时，不管流量有多大，都以匀速的方式请求，比如1ms10个。</p>
<p>不管服务调用方多么不稳定，通过漏桶算法进行限流，每 <code>10</code> 毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p>
<p><strong>算法实现</strong>：队列保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次获取多个并发执行。</p>
<p>这种算法，在使用过后也存在弊端：<strong>无法应对短时间的突发流量</strong>，同时它的优点也是可以平滑网络上的突发流量，请求可以被整形成稳定的流量。</p>
</li>
<li><p>令牌桶</p>
<p>桶算法可以限制请求调用的速率，令牌算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。</p>
<p>桶用来存放固定数量的令牌。以一定的速率往桶中放令牌。每次请求先获取令牌，拿到令牌才可以执行，否则等待可用的令牌，或者直接拒绝。</p>
<p>桶中令牌上限则丢弃。所以存在这种情况，桶中一直有大量可用的令牌，请求可以拿令牌直接执行。比如设置 <code>qps</code> 为 <code>100</code> ，那么限流器初始化完成一秒后，桶中就已经有 100 个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的 <code>100</code> 个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p>
<p><strong>算法实现：</strong></p>
<p>队列存放令牌，通过线程池定期生成令牌到队列中，每次来一个请求，就从队列中获取一个令牌，然后继续执行。</p>
</li>
</ul>
<h3 id="集群限流"><a href="#集群限流" class="headerlink" title="集群限流"></a>集群限流</h3><ul>
<li><p>Redis请求窗口</p>
<blockquote>
<p>采用redis的计时和计数方式，在规定的时间窗口，允许通过的最大请求量。</p>
</blockquote>
<p>每次有相关操作的时候，就向 <code>redis</code> 服务器发送一个 <code>incr</code> 命令，比如需要限制某个用户访问 <code>/index</code> 接口的次数，只需要拼接用户 id 和接口名生成 <code>redis</code> 的 <code>key</code> ，每次该用户访问此接口时，只需要对这个 <code>key</code> 执行 <code>incr</code> 命令，在这个 <code>key</code> 带上过期时间，就可以实现指定时间的访问频率。</p>
</li>
<li><p>Nginx限流</p>
<p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。</p>
<p>Nginx官方版本限制IP的连接和并发分别有两个模块：</p>
<ul>
<li><code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。</li>
<li><code>limit_req_conn</code> 用来限制同一时间连接数，即并发限制。</li>
</ul>
</li>
</ul>
<p><a href="https://hadyang.github.io/interview/docs/architecture/design/tinyURL/">短链系统</a></p>
<p><a href="https://hadyang.github.io/interview/docs/architecture/design/seckill/">秒杀系统</a></p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="分布式一致性与共识算法"><a href="#分布式一致性与共识算法" class="headerlink" title="分布式一致性与共识算法"></a>分布式一致性与共识算法</h2><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h1 id="关于认证授权"><a href="#关于认证授权" class="headerlink" title="关于认证授权"></a>关于认证授权</h1><p>认证：认证身份凭证，通过凭证知道是你。</p>
<p>授权：认证之后，授权主要掌管着我们访问系统的权限。</p>
<h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>简单来说，cookie存放在客户端，用来保存用户信息。</p>
<blockquote>
<ol>
<li>我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，Cookie 还能保存用户首选项，主题和其他设置信息。</li>
<li>使用Cookie 保存 session 或者 token ，向后端发送请求的时候带上 Cookie，这样后端就能取到session或者token了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。</li>
<li>Cookie 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为HTTP协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在Cookie</li>
</ol>
</blockquote>
<p>服务端使用cookie可以使用以下方法：</p>
<ul>
<li><p>设置cookie返回给客户顿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;change-username&quot;)</span><br><span class="line">public String setCookie(HttpServletResponse response) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个 cookie</span><br><span class="line">    Cookie cookie &#x3D; new Cookie(&quot;username&quot;, &quot;Jovan&quot;);</span><br><span class="line">    &#x2F;&#x2F;设置 cookie过期时间</span><br><span class="line">    cookie.setMaxAge(7 * 24 * 60 * 60); &#x2F;&#x2F; expires in 7 days</span><br><span class="line">    &#x2F;&#x2F;添加到 response 中</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">    return &quot;Username is changed!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用spring框架的@CookieValue获取特定cookie值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String readCookie(@CookieValue(value &#x3D; &quot;username&quot;, defaultValue &#x3D; &quot;Atta&quot;) String username) &#123;</span><br><span class="line">    return &quot;Hey! My username is &quot; + username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取所有cookie值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;all-cookies&quot;)</span><br><span class="line">public String readAllCookies(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">    Cookie[] cookies &#x3D; request.getCookies();</span><br><span class="line">    if (cookies !&#x3D; null) &#123;</span><br><span class="line">        return Arrays.stream(cookies)</span><br><span class="line">                .map(c -&gt; c.getName() + &quot;&#x3D;&quot; + c.getValue()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;No cookies&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>主要作用是通过服务端记录用户状态。</p>
<p>Cookie存放在客户端，session存放在服务端，所以安全性更高，敏感信息一般不直接写在cookie，最好将cookie信息加密然后使用的时候去服务端解密。</p>
<p><strong>session如何进行身份验证</strong></p>
<p>通过sessionId来实现特定用户，ID一般存放在redis中，用户登陆系统，然后返回给客户端具有sessionId的cookie，请求时带上，这样就知道用户了。</p>
<p>需要注意：</p>
<ul>
<li>依赖session的业务需要确保客户端开启了cookie</li>
<li>session的过期时间。</li>
</ul>
<p><strong>没有cookie的话，session还能用吗</strong></p>
<p>可以呀，可以重写请求串啊，在url里面带着sessionId。可行但是安全性和用户体验感降低。当然了，也可以加密后传到服务端进行解密。</p>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><h3 id="什么是token"><a href="#什么是token" class="headerlink" title="什么是token"></a>什么是token</h3><p>session有问题，比如他没法做分布式，需要保证session信息服务器的可用性、不适合移动端。</p>
<p>Token不需要再客户端存放，只需要校验。JWT就是这种实现方式。JWT本质上就是一种签名串，由于是有签名的，所以接收者可以验证他的真实性。</p>
<p>JWT三部分构成：</p>
<ul>
<li>Header：描述JWT的元数据，定义了生成签名的算法和token类型。</li>
<li>Payload(负载)：存放实际需要传递的数据。</li>
<li>Signature：服务器通过<code>Payload</code>、<code>Header</code>和一个密钥(<code>secret</code>)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。</li>
</ul>
<p>在基于 Token 进行身份验证的的应用程序中，服务器通过<code>Payload</code>、<code>Header</code>和一个密钥(<code>secret</code>)创建令牌（<code>Token</code>）并将 <code>Token</code> 发送给客户端，客户端将 <code>Token</code> 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：<code> Authorization: Bearer Token</code>。</p>
<h3 id="为什么token可以防止CSRF攻击"><a href="#为什么token可以防止CSRF攻击" class="headerlink" title="为什么token可以防止CSRF攻击"></a>为什么token可以防止CSRF攻击</h3><p>CSRF：跨域请求伪造。</p>
<p>Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p>
<p>但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p>
<p>需要注意的是不论是 Cookie 还是 token 都无法避免跨站脚本攻击（Cross Site Scripting）XSS。</p>
<h2 id="Oauth2-0"><a href="#Oauth2-0" class="headerlink" title="Oauth2.0"></a>Oauth2.0</h2><p>这个之前总结过</p>
<h2 id="sso"><a href="#sso" class="headerlink" title="sso"></a>sso</h2><p>SSO(Single Sign On)即单点登录说的是用户登陆多个子系统的其中一个就有权访问与其相关的其他系统。举个例子我们在登陆了京东金融之后，我们同时也成功登陆京东的京东超市、京东家电等子系统。</p>
<blockquote>
<p> <strong>sso和oauth2.0的区别。</strong></p>
<p>OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。SSO解决的是一个公司的多个相关的自系统的之间的登陆问题比如京东旗下相关子系统京东金融、京东超市、京东家电等等。</p>
</blockquote>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>系统科学概述</title>
    <url>/2021/04/06/%E7%B3%BB%E7%BB%9F%E7%A7%91%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><strong>系统科学：</strong></p>
<p>To Provide a Systematic(Unified,Universal) View for Varies Complex Systems By a Systematic Approach</p>
<ul>
<li>对象：各个领域的复杂系统</li>
<li>方法：系统学方法</li>
<li>目标：获得系统的、统一、普适的认识</li>
</ul>
<h1 id="自组织理论"><a href="#自组织理论" class="headerlink" title="自组织理论"></a>自组织理论</h1><p>科学发展的宇宙暴涨理论。</p>
<p>物质世界由：电子、电子中微子、up和down夸克构成。是系统科学的问题。</p>
<ul>
<li><p>主宰世界的基本规律：牛顿力学和量子力学(薛定谔方程)</p>
<p>$ \vec{F}=m \frac{d^{2} \cdot \vec{r}}{d t^{2}} $和$ i \hbar \frac{\partial \psi}{\partial t}=\hat{H} \psi $</p>
<p>这两个公式是<strong>时间反演不变</strong>的，表明这两个公式描写的运动规律不带时间箭头，完全可逆。</p>
<p>时间反演不变例如单摆，倒放仍然符合牛二定律，没有时间方向。</p>
</li>
<li><p><strong>热力学第二定律</strong>(带有时间箭头，懒婆娘定律)</p>
<p>孤立系统中的自发过程总是导致体系中熵的增加</p>
<ul>
<li>存在时间箭头</li>
<li>指向无序混乱</li>
</ul>
<p><em>生命是如何从无序的状态演变为有序呢？？</em></p>
</li>
<li><p>自组织现象</p>
<p>自组织系统的主要特征：</p>
<ul>
<li>开放系统、与环境有物质和能量交流。</li>
<li>组元众多，并且存在非线性相互作用。</li>
<li>远离平衡态。</li>
<li>涨落是有序结构形成的触发器。</li>
</ul>
<p>自组织论的概念：耗散结构、序参量、对称破缺、时空结构、熵、稳定性、鲁棒性</p>
</li>
<li><p>自组织研究方法</p>
<ul>
<li>Top–Down(宏观)：宏观层次的动力学方法<ul>
<li>根据系统的演化机制，建立描述系统状态变量满足的非线性微分方程组。通常称其为反应扩散方程。</li>
<li>微分方程的定性理论，如稳定性理论、分叉理论等，给出系统发生相变的条件，以及出现的稳定有序结构的具体形式。</li>
<li>利用在研究非线性问题时建立的突变论、混沌理论、分形理论等来研究自组织理论所讨论的问题。</li>
<li>数值计算，给出针对某些参数的系统演化曲线。</li>
</ul>
</li>
<li>Bottom–up(微观)：自底向上的多主体方法<ul>
<li>主体的行为规则</li>
<li>主体之间的相互作用规则</li>
<li>基于主体的模拟方法考察系统整体的自组织行为</li>
<li>基于统计物理学方法的理论分析</li>
</ul>
</li>
<li>Meso-Scopic Level：中观层次的随机方法<ul>
<li>对系统进行中观层次上的分析，通常选择随机变量进行讨论</li>
<li>根据系统演化机制建立随机变量满足的主方程、 Fokker Planck方程、或 Langevin方程，针对方程的不同形式，选择相应的数学方法进行求解。</li>
<li>无论宏观上用反映扩散方程讨论，还是中观上的随机方法都已经形成了相当完整的理论体系，提出了不少数学处理问题的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="动力学与混沌"><a href="#动力学与混沌" class="headerlink" title="动力学与混沌"></a>动力学与混沌</h1><p>如何用动力学的手段来研究系统的演化？</p>
<ul>
<li><p><strong>动力学描述的普遍性</strong></p>
<p>动力学：</p>
<ul>
<li>刻画系统随时间演化的一般方法</li>
<li>揭示系统状态变化的内在机制</li>
</ul>
<p>在大气运动、地理、人文、金融等各个方面，动力学都有广泛的应用。</p>
</li>
<li><p><strong>动力学建模(以群体动力学为例)：</strong></p>
<p>种群演化的最基本的模型(Malthus模型)：$\frac{d x}{d t}=\lambda x$。</p>
<p>这显然不合理，因为增长还会收到环境的约束，所以进一步细化</p>
<p><code>Logistic</code>模型：$\frac{d x}{d t}=\lambda x\left(1-\frac{X}{N}\right)$</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200623210227.png" alt="image-20200623210219787" style="zoom: 33%;" />

<p>如果狼和兔子生活在同一个环境中，是什么样的动力学模型？</p>
</li>
<li><p><strong>动力系统定性分析</strong>(彭加莱)：系统最终会走向何处？</p>
<ul>
<li><p><strong>微分动力系统(连续的)：</strong>$\frac{d \vec{X}}{d t}=f(\vec{X}, \lambda)$</p>
</li>
<li><p><strong>开普勒二体问题：</strong>如果两个物体之间的相互作用力为万有引力，那么当你 站在一个质点上观察另一个质 点的运动时，另一个质点的轨 道一定是直线、抛物线、概圆 或者双曲线的一支。</p>
</li>
<li><p><strong>拉普拉斯决定论：</strong>我们可以认为宇宙的现在 是由它的过去来决定的;现在也是决定未来的原因。如果有一位 智者在某一时刻获知了自然界一切物体的位置和相互作用力，并且他具有超常的数据分析能力 那么他就可以把宇宙这个最庞大的物体直至到原子这个最细微的颗粒全都囊括到一个公式中去。对于这位智者来说，没有什么东西是不确定的–宇宙的未来就会像他的过去一样完全呈现在他的眼前。</p>
</li>
<li><p><strong>三体问题：</strong>很复杂，最终不再希望得到解析解。而是进行定性的研究。</p>
</li>
<li><p><strong>动力系统定性理论：</strong>关系系统演化在$t \rightarrow \infty$时的定性行为</p>
<ul>
<li>趋于无穷</li>
<li>不动点</li>
<li>周期解</li>
<li>其他(混沌运动)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>动力系统的数值方法(欧拉方法)</strong><br>$$<br>\begin{array}{c}<br>\frac{\Delta X}{\Delta t}=f(X, \lambda) \<br>\Delta X=f(X, \lambda) \Delta t \<br>X(t+\Delta t)-X(t)=f(X(t), \lambda) \Delta t \<br>X(t+\Delta t)=X(t)+f(X(t), \lambda) \Delta t<br>\end{array}<br>$$</p>
</li>
</ul>
<p><a href="https://berkeley-madonna.myshopify.com/pages/download">Madonna软件下载地址</a></p>
<ul>
<li><p><strong>Logistic映射(离散的演化)：</strong>同样可以通过定性分析或者数值计算的方法来了解具体的演化<br>$$<br>\mathbf{x}<em>{\mathrm{n}+1}=\lambda \mathbf{x}</em>{\mathrm{n}}\left(1-\mathbf{x}_{\mathrm{n}}\right)<br>$$</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200623225945.png" alt="image-20200623225945381" style="margin: 0px auto; zoom: 33%;" /></li>
<li><p><strong>混沌系统：</strong></p>
<ul>
<li>对初始条件敏感、依赖</li>
<li>有界性(系统运动的有界空间之内)</li>
</ul>
</li>
<li><p><strong>Lorenz系统(大气动力学)：</strong><br>$$<br>\left{\begin{array}{c}\dot{x}=a(y-x) \ \dot{y}=c x-x z-y \ \dot{z}=x y-b z\end{array}\right.<br>$$<br>看似简单，但是没办法得到解析解。<strong>初值敏感依赖现象。</strong></p>
<p>存在混沌吸引子，<code>a=10,b=8/3,c=28</code>，<strong>不发散、不收敛、非周期</strong>，是混沌行为的典型案例。</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200627000512.png" alt="image-20200627000504983" style="zoom: 50%;" /></li>
</ul>
<h1 id="元胞自动机"><a href="#元胞自动机" class="headerlink" title="元胞自动机"></a>元胞自动机</h1><ul>
<li><p><strong>是个啥？</strong></p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200627002355.png" alt="1" style="zoom:50%;" />

<p>呐这就是一个简单的元胞自动机，每个格子都是一个元胞，i有两种可能的取值<code>0</code>和<code>1</code>，元胞在下一时刻的状态是由他自己和他左右的邻居决定的，演化公式如下：</p>
<ul>
<li>$ x_{i}^{t} $是格子<code>i</code>在<code>t</code>时刻的状态：<br>$$<br>x_{i}^{t}=\left{\begin{array}{l}0 \ 1\end{array}, i=1,2, \ldots \ldots, L\right.<br>$$</li>
</ul>
</li>
<li><p>状态演化方程：<br>$$<br>x_{i}^{t+1}=f\left(x_{i-1}^{t}, x_{i}^{t}, x_{i+1}^{t}\right), \quad i=1,2, \ldots . ., L<br>$$</p>
<p>所以决定<code>i</code>下一个时刻状态的前提条件就是<code>8</code>种(<code>left</code>1/0，<code>self</code>1/0，<code>right</code>1/0)，在这8种初始的条件下，<code>i</code>可以取<code>0</code>或者<code>1</code>两种状态，组合起来就是$2^8=256$种，所以，初等的元胞自动机就是由这256种策略来决定的元胞的演化。为了更加直观的刻画元胞自动机的状态演化，引入<code>时空图</code>的描述方法，且看(1的时候涂成黑色)：</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200627103335.png" alt="20200627004819" style="zoom: 25%;" />                        </li>
<li><p><strong>NetLogo</strong></p>
<p><a href="http://ccl.northwestern.edu/netlogo/6.1.1/">下载地址</a></p>
<ul>
<li>用netLogo观察一维元胞自动机，以下是用<code>netLogo</code>观察到规则169下的时空图情况。</li>
</ul>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200627012130.png" alt="image-20200627012130714" style="zoom:50%;" />

<ul>
<li><p><code>Wolfram</code>对初等元胞自动机的分类：</p>
<ul>
<li>平稳性：自任何初始状态开始，经过一定时间运行后，元胞空间趋于一个空间平稳的构形，这里空间平稳即指每一个元胞处于固定状态。不随时间变化而变化。</li>
<li>周期型：经过一定时间运行后，元胞空间趋于一系列简单的固定结构（ Stable Paterns）或周期结构（ Perlodical Patterns）。</li>
<li>复杂型：出现复杂的局部结构，与非线性映射中的混沌行为有对应关系，其中有些会不断地传播。</li>
</ul>
</li>
<li><p>系统演化描述方法小结：</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200627013521.png" alt="image-20200627013521235"  /></li>
</ul>
</li>
<li><p><strong>元胞自动机-交通流的NS模型</strong></p>
<ul>
<li><p>是在184条元胞自动机规则之上提出的，NS模型是一个随机CA交流模型，每辆车的状态由他的速度和位置标示，状态按照以下演化规则并行更新：</p>
<ol>
<li>加速过程：$v_{n} \rightarrow \min \left(v_{n}+1, v_{\max }\right)$</li>
<li>安全刹车过程：$v_n \rightarrow \min \left (v_n,d_n-1 \right)$</li>
<li>随机慢化过程(以随机慢化概率p)：$v_n \rightarrow \max \left(v_n-1,0 \right)$</li>
<li>位置更新：$x_n \rightarrow x_n+v_n$</li>
</ol>
</li>
<li><p><code>NetLogo</code>建模(假设$v_{max}=2$，$p=1/3$)</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200627172428.png" alt="image-20200627172337841" style="zoom:33%;" /></li>
</ul>
</li>
<li><p><strong>DLA模型</strong></p>
</li>
</ul>
<h1 id="多主体建模方法"><a href="#多主体建模方法" class="headerlink" title="多主体建模方法"></a>多主体建模方法</h1><h1 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h1><h1 id="复杂网络"><a href="#复杂网络" class="headerlink" title="复杂网络"></a>复杂网络</h1>]]></content>
      <categories>
        <category>复杂网络</category>
      </categories>
      <tags>
        <tag>复杂系统</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次zuul排错</title>
    <url>/2020/03/29/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1zuul%E6%8E%92%E9%94%99/</url>
    <content><![CDATA[<h2 id="某个突然出现的Bug"><a href="#某个突然出现的Bug" class="headerlink" title="某个突然出现的Bug"></a>某个突然出现的Bug</h2><p>在做微服务的时候，后端启动了几个端口，之前还想着在前端配置不同的端口方便测试，其实是可以在Zuul中设置一个共同的入口的。Zuul的配置如下(暂且不做拦截)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">interest-zuul</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">    <span class="attr">connect-timeout-millis:</span> <span class="number">10000</span></span><br><span class="line">    <span class="attr">socket-timeout-millis:</span> <span class="number">10000</span></span><br><span class="line">  <span class="attr">add-proxy-headers:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sensitive-headers:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">interest-user:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/user/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-user</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">interest-approval:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/approval/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-approval</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">interest-Meeting:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/Meeting/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-Meeting</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">interest-file:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/file/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-file</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">interest-risk:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/risk/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-risk</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">interest-template:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/template/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-template</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">10000</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="comment"># 你需要存储日志的目录</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">D:/interest/file/log/interest.log</span></span><br><span class="line">  <span class="comment">#测试环境</span></span><br><span class="line">  <span class="comment">#file: /www/wwwroot/hhzhutest.com/log/interest.log</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.cloud:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">com.interest.zuul:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>这样就可以通过8081端口访问其他服务。后台启动eureka(8761)，zuul(8081)，user(8099)。访问user模块的接口，首先通过8099访问user模块的swagger测试：</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200330011242.png" alt="image-20200330011233220"></p>
<p>ok，没问题。现在通过zuul的8081端口访问swagger，不行，后台报错如下：</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200330011532.png" alt="image-20200330011530071"></p>
<p>超时了？(对，没错，就是超时了)。</p>
<p>打开eureka查看没错是注册过来了啊</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200330025334.png" alt="image-20200330025332776"></p>
<p>然后打开前端，通过8081端口访问user，woc，虽然报红，但是验证码是发过来了，后台的user模块也是在打印日志，明显是已经通过zuul的端口访问到user来了。这就很奇怪了，网上搜了一天，没有一个靠谱的答案。百思不得其解，既然接口已经访问到了，说明这个zuul的配置也咩问题啊，难道，是swagger的配置出了问题？？打开swagger配置，没发现什么幺蛾子。陷入了深思。。。。。。</p>
<p>这时候坚定一定是zuul的配置出问题了，打开zull的配置和git上的记录对比，没发现变动。去github上拉取框架源码，完全相同。到这事情似乎已经没办法进展了。然后去谷歌zuul的常规配置。和自己的配置对比：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line">    <span class="attr">interest-user:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/user/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-user</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">interest-approval:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/approval/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-approval</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>不对劲啊，既然zull是把别的端口映射过来，现在加入后台微服务开50个，routes的配置虽然写了路径，但是具体去找哪个端口？？难道是一个一个找？这样看来确实需要很长时间。OK，我再给你点时间，原来是10000现在给你50000够了吧？？</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">50000</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">50000</span></span><br></pre></td></tr></table></figure>

<p>重启之后，通过8081访问user，一直在转圈圈，转了一会发现真的访问到了，woc？？是看到了swagger，但是我的目的不是要看swagger啊，我的目的是要接口，这么长个时间，那还开发个毛线，这肯定无法睡服自己啊，这时候想，spring这么优秀的东西，不至于让 zuul自己去找映射的，肯定是可以配置的，打开百度搜索了一下，发现果然可以，加上后：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line">    <span class="attr">interest-user:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/user/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9088</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-user</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">interest-approval:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/interest/approval/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8099</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">interest-approval</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这次重启后端通过8081访问user的swagger，如丝般顺滑。原框架作者留下的坑加上自己菜。。。。</p>
<p>为此</p>
<p>重装了三次IDEA</p>
<p>熬了两个这么晚</p>
<p>他妈的晚安QAQ</p>
<p>等等等等，还发现一个好用的IDEA插件—-RestfulToolKit，</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200330024428.png" alt="image-20200330024103040"></p>
<p>这这这？？这还要什么postman和swagger啊。</p>
<p>晚安。。。。。</p>
]]></content>
      <categories>
        <category>Bug合集</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>身份证信息识别</title>
    <url>/2020/04/09/%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%BF%A1%E6%81%AF%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>调用阿里云实现身份证信息的识别</p>
</blockquote>
<h2 id="阿里云SDK"><a href="#阿里云SDK" class="headerlink" title="阿里云SDK"></a>阿里云SDK</h2><p>阿里云提供了身份证信息识别的java代码，先看源码，然后进行改写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.ocr.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONArray;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.api.gateway.demo.util.HttpUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.commons.codec.binary.Base64.encodeBase64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用APPCODE进行云市场ocr服务接口调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APPCodeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取参数的json对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">getParam</span><span class="params">(<span class="keyword">int</span> type, String dataValue)</span> </span>&#123;</span><br><span class="line">        JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj.put(<span class="string">&quot;dataType&quot;</span>, type);</span><br><span class="line">            obj.put(<span class="string">&quot;dataValue&quot;</span>, dataValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String host = <span class="string">&quot;http://dm-51.data.aliyun.com&quot;</span>;</span><br><span class="line">        String path = <span class="string">&quot;/rest/160601/ocr/ocr_idcard.json&quot;</span>;</span><br><span class="line">        String appcode = <span class="string">&quot;你的APPCODE&quot;</span>;</span><br><span class="line">        String imgFile = <span class="string">&quot;图片路径&quot;</span>;</span><br><span class="line">        Boolean is_old_format = <span class="keyword">false</span>;<span class="comment">//如果文档的输入中含有inputs字段，设置为True， 否则设置为False</span></span><br><span class="line">        <span class="comment">//请根据线上文档修改configure字段</span></span><br><span class="line">        JSONObject configObj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        configObj.put(<span class="string">&quot;side&quot;</span>, <span class="string">&quot;face&quot;</span>);</span><br><span class="line">        String config_str = configObj.toString();</span><br><span class="line">        <span class="comment">//            configObj.put(&quot;min_size&quot;, 5);</span></span><br><span class="line">        <span class="comment">//            String config_str = &quot;&quot;;</span></span><br><span class="line"></span><br><span class="line">        String method = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">//最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105</span></span><br><span class="line">        headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE &quot;</span> + appcode);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对图像进行base64编码</span></span><br><span class="line">        String imgBase64 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(imgFile);</span><br><span class="line">            <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">            FileInputStream finputstream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            finputstream.read(content);</span><br><span class="line">            finputstream.close();</span><br><span class="line">            imgBase64 = <span class="keyword">new</span> String(encodeBase64(content));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拼装请求body的json字符串</span></span><br><span class="line">        JSONObject requestObj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(is_old_format) &#123;</span><br><span class="line">                JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                obj.put(<span class="string">&quot;image&quot;</span>, getParam(<span class="number">50</span>, imgBase64));</span><br><span class="line">                <span class="keyword">if</span>(config_str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    obj.put(<span class="string">&quot;configure&quot;</span>, getParam(<span class="number">50</span>, config_str));</span><br><span class="line">                &#125;</span><br><span class="line">                JSONArray inputArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">                inputArray.add(obj);</span><br><span class="line">                requestObj.put(<span class="string">&quot;inputs&quot;</span>, inputArray);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                requestObj.put(<span class="string">&quot;image&quot;</span>, imgBase64);</span><br><span class="line">                <span class="keyword">if</span>(config_str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    requestObj.put(<span class="string">&quot;configure&quot;</span>, config_str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String bodys = requestObj.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 重要提示如下:</span></span><br><span class="line"><span class="comment">             * HttpUtils请从</span></span><br><span class="line"><span class="comment">             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java</span></span><br><span class="line"><span class="comment">             * 下载</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 相应的依赖请参照</span></span><br><span class="line"><span class="comment">             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys);</span><br><span class="line">            <span class="keyword">int</span> stat = response.getStatusLine().getStatusCode();</span><br><span class="line">            <span class="keyword">if</span>(stat != <span class="number">200</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Http code: &quot;</span> + stat);</span><br><span class="line">                System.out.println(<span class="string">&quot;http header error msg: &quot;</span>+ response.getFirstHeader(<span class="string">&quot;X-Ca-Error-Message&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;Http body error msg:&quot;</span> + EntityUtils.toString(response.getEntity()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String res = EntityUtils.toString(response.getEntity());</span><br><span class="line">            JSONObject res_obj = JSON.parseObject(res);</span><br><span class="line">            <span class="keyword">if</span>(is_old_format) &#123;</span><br><span class="line">                JSONArray outputArray = res_obj.getJSONArray(<span class="string">&quot;outputs&quot;</span>);</span><br><span class="line">                String output = outputArray.getJSONObject(<span class="number">0</span>).getJSONObject(<span class="string">&quot;outputValue&quot;</span>).getString(<span class="string">&quot;dataValue&quot;</span>);</span><br><span class="line">                JSONObject out = JSON.parseObject(output);</span><br><span class="line">                System.out.println(out.toJSONString());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(res_obj.toJSONString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求分析和代码改写"><a href="#需求分析和代码改写" class="headerlink" title="需求分析和代码改写"></a>需求分析和代码改写</h2><p>我们要把这个代码改写成工具类方便调用，这样controller里面的内容比较清晰明了。需求是，在注册的时候把身份证信息传上来，然后调用api进行身份证信息的识别，在注册的时候肯定是本地上传文件，所以前端过来的参数时multipartfile类型，我们要转换成base64类型(注意不要直接传base64作为参数类型，太长了，不允许)。</p>
<p>所以我们在controller里面调用工具类，把multipartfile类型转换成base64类型，工具类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">MultipartFile2Base64</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteArr = multipartFile.getBytes();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.encodeBase64(byteArr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在controller里面已经得到了图片的base64编码，然后调用改写好的阿里云接口就行，改写之后的代码如下(提供了base64代码瞬间变得简洁)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interest.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONArray;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 阿里云身份证识别服务接口调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HhZhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Created on 2020/4/1 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdCardUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取参数的json对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">getParam</span><span class="params">(<span class="keyword">int</span> type, String dataValue)</span> </span>&#123;</span><br><span class="line">        JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj.put(<span class="string">&quot;dataType&quot;</span>, type);</span><br><span class="line">            obj.put(<span class="string">&quot;dataValue&quot;</span>, dataValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String imgBase64)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String host = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String appcode = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Boolean is_old_format = <span class="keyword">false</span>;<span class="comment">//如果文档的输入中含有inputs字段，设置为True， 否则设置为False</span></span><br><span class="line">        <span class="comment">//请根据线上文档修改configure字段</span></span><br><span class="line">        JSONObject configObj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="comment">//只识别正面，获取姓名存入数据库</span></span><br><span class="line">        configObj.put(<span class="string">&quot;side&quot;</span>, <span class="string">&quot;face&quot;</span>);</span><br><span class="line">        String config_str = configObj.toString();</span><br><span class="line">        <span class="comment">//            configObj.put(&quot;min_size&quot;, 5);</span></span><br><span class="line">        <span class="comment">//            String config_str = &quot;&quot;;</span></span><br><span class="line"></span><br><span class="line">        String method = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">//最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105</span></span><br><span class="line">        headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE &quot;</span> + appcode);</span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 拼装请求body的json字符串</span></span><br><span class="line">        JSONObject requestObj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(is_old_format) &#123;</span><br><span class="line">                JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                obj.put(<span class="string">&quot;image&quot;</span>, getParam(<span class="number">50</span>, imgBase64));</span><br><span class="line">                <span class="keyword">if</span>(config_str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    obj.put(<span class="string">&quot;configure&quot;</span>, getParam(<span class="number">50</span>, config_str));</span><br><span class="line">                &#125;</span><br><span class="line">                JSONArray inputArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">                inputArray.add(obj);</span><br><span class="line">                requestObj.put(<span class="string">&quot;inputs&quot;</span>, inputArray);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                requestObj.put(<span class="string">&quot;image&quot;</span>, imgBase64);</span><br><span class="line">                <span class="keyword">if</span>(config_str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    requestObj.put(<span class="string">&quot;configure&quot;</span>, config_str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String bodys = requestObj.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 重要提示如下:</span></span><br><span class="line"><span class="comment">             * HttpUtils请从</span></span><br><span class="line"><span class="comment">             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java</span></span><br><span class="line"><span class="comment">             * 下载</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 相应的依赖请参照</span></span><br><span class="line"><span class="comment">             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HttpResponse response = HttpUtil.doPost(host, path, method, headers, querys, bodys);</span><br><span class="line">            <span class="keyword">int</span> stat = response.getStatusLine().getStatusCode();</span><br><span class="line">            <span class="keyword">if</span>(stat != <span class="number">200</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Http code: &quot;</span> + stat);</span><br><span class="line">                System.out.println(<span class="string">&quot;http header error msg: &quot;</span>+ response.getFirstHeader(<span class="string">&quot;X-Ca-Error-Message&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;Http body error msg:&quot;</span> + EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String res = EntityUtils.toString(response.getEntity());</span><br><span class="line">            JSONObject res_obj = JSON.parseObject(res);</span><br><span class="line">            <span class="keyword">if</span>(is_old_format) &#123;</span><br><span class="line">                JSONArray outputArray = res_obj.getJSONArray(<span class="string">&quot;outputs&quot;</span>);</span><br><span class="line">                String output = outputArray.getJSONObject(<span class="number">0</span>).getJSONObject(<span class="string">&quot;outputValue&quot;</span>).getString(<span class="string">&quot;dataValue&quot;</span>);</span><br><span class="line">                JSONObject out = JSON.parseObject(output);</span><br><span class="line">                <span class="comment">//System.out.println(out.toJSONString());</span></span><br><span class="line">                <span class="keyword">return</span> out.toJSONString();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(res_obj.toJSONString());</span></span><br><span class="line">                <span class="keyword">return</span> res_obj.toJSONString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>一是不要把base64编码直接作为参数</p>
</li>
<li><p>二是调用接口返回的类型是一个String，要转换成对象才方便存取，工具类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">json2Map</span><span class="params">(String jsonStr)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(jsonStr != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(jsonStr))&#123;</span><br><span class="line">            <span class="comment">//最外层解析</span></span><br><span class="line">            JSONObject json = JSONObject.fromObject(jsonStr);</span><br><span class="line">            <span class="keyword">for</span> (Object k : json.keySet()) &#123;</span><br><span class="line">                Object v = json.get(k);</span><br><span class="line">                <span class="comment">//如果内层还是数组的话，继续解析</span></span><br><span class="line">                <span class="keyword">if</span> (v <span class="keyword">instanceof</span> JSONArray) &#123;</span><br><span class="line">                    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();</span><br><span class="line">                    Iterator&lt;JSONObject&gt; it = ((JSONArray) v).iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        JSONObject json2 = it.next();</span><br><span class="line">                        list.add(json2Map(json2.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.put(k.toString(), list);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(k.toString(), v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200409132257.png" alt="image-20200409132248536"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>阿里云SDK</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法生成ID</title>
    <url>/2020/03/29/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90ID/</url>
    <content><![CDATA[<h3 id="抽取工具类"><a href="#抽取工具类" class="headerlink" title="抽取工具类"></a>抽取工具类</h3><p>之前的数据库设计采取的是主键自增的方式。后来改为了雪花算法。关于雪花算法的具体实现问题，可以抽取一个工具类IDworker，IDworker中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interest.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.NetworkInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;名称：IdWorker.java&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;描述：分布式自增长ID&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     Twitter的 Snowflake　JAVA实现方案</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用：</span></span><br><span class="line"><span class="comment"> * 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000</span></span><br><span class="line"><span class="comment"> * 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，</span></span><br><span class="line"><span class="comment"> * 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），</span></span><br><span class="line"><span class="comment"> * 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。</span></span><br><span class="line"><span class="comment"> * 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），</span></span><br><span class="line"><span class="comment"> * 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 6)4位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Polim</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line">    <span class="comment">// 机器标识位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">// 数据中心标识位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">// 机器ID最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">// 数据中心ID最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="comment">// 毫秒内自增位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">// 机器ID偏左移12位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">// 数据中心ID左移17位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">// 时间毫秒左移22位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">    <span class="comment">/* 上次生产id时间戳 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// 0，并发控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">// 数据标识id部分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = getDatacenterId(maxDatacenterId);</span><br><span class="line">        <span class="keyword">this</span>.workerId = getMaxWorkerId(datacenterId, maxWorkerId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId</span></span><br><span class="line"><span class="comment">     *            工作机器ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId</span></span><br><span class="line"><span class="comment">     *            序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            <span class="comment">// 当前毫秒内，则+1</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前毫秒内计数满了，则等待下一秒</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">// ID偏移组合生成最终的ID，并返回ID</span></span><br><span class="line">        <span class="keyword">long</span> nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift)</span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nextId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = <span class="keyword">this</span>.timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = <span class="keyword">this</span>.timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 获取 maxWorkerId</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMaxWorkerId</span><span class="params">(<span class="keyword">long</span> datacenterId, <span class="keyword">long</span> maxWorkerId)</span> </span>&#123;</span><br><span class="line">        StringBuffer mpid = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        mpid.append(datacenterId);</span><br><span class="line">        String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        <span class="keyword">if</span> (!name.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * GET jvmPid</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            mpid.append(name.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * MAC + PID 的 hashcode 获取16个低位</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">return</span> (mpid.toString().hashCode() &amp; <span class="number">0xffff</span>) % (maxWorkerId + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 数据标识id部分</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getDatacenterId</span><span class="params">(<span class="keyword">long</span> maxDatacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> id = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">            NetworkInterface network = NetworkInterface.getByInetAddress(ip);</span><br><span class="line">            <span class="keyword">if</span> (network == <span class="keyword">null</span>) &#123;</span><br><span class="line">                id = <span class="number">1L</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] mac = network.getHardwareAddress();</span><br><span class="line">                id = ((<span class="number">0x000000FF</span> &amp; (<span class="keyword">long</span>) mac[mac.length - <span class="number">1</span>])</span><br><span class="line">                        | (<span class="number">0x0000FF00</span> &amp; (((<span class="keyword">long</span>) mac[mac.length - <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>))) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">                id = id % (maxDatacenterId + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; getDatacenterId: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Bean注入"><a href="#Bean注入" class="headerlink" title="Bean注入"></a>Bean注入</h3><p>项目中把一些工具类放在一个commom模块，然后通过依赖引进其他模块。在启动类中注入idWorker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interest.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interest.common.utils.IdWorker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//@MapperScan(&quot;com.interest.user.mapper&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.interest.user&quot;,&quot;com.interest.common&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterestUserApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(InterestUserApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdWorker <span class="title">idWorkker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IdWorker(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="雪花算法生成ID"><a href="#雪花算法生成ID" class="headerlink" title="雪花算法生成ID"></a>雪花算法生成ID</h3><p>在需要使用的代码块(一般是在serviceImpl会用到)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IdWorker idWorker;</span><br></pre></td></tr></table></figure>

<p>然后就可以用雪花算法生成ID了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String num = idWorker.nextId()+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        userEntity.setUserID(num);</span><br><span class="line">        userDao.insertUser(userEntity);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2021/03/24/Mysql/</url>
    <content><![CDATA[<h1 id="1、存储引擎"><a href="#1、存储引擎" class="headerlink" title="1、存储引擎"></a>1、存储引擎</h1><p>Mysql默认的存储引擎是InnoDB，在5.7版本只有InnoDB是支持事务的。</p>
<ul>
<li>查看默认的存储引擎：mysql&gt; show variables like ‘%storage_engine%’;</li>
<li>查看表的存储引擎：show table status like “table_name” ;</li>
</ul>
<h2 id="MyISAM和InnoDB区别？"><a href="#MyISAM和InnoDB区别？" class="headerlink" title="MyISAM和InnoDB区别？"></a>MyISAM和InnoDB区别？</h2><p>在5.5之前，默认引擎是MyISAM 。优点有：全文索引，压缩，空间函数，但是不支持事务和行级锁，最大的缺陷是崩溃之后无法安全恢复，在5.5之后，引入InnoDB并成为默认引擎。</p>
<p><strong>两者的对比</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">行级锁</td>
<td align="center">表级锁</td>
<td align="center">表级锁和行<strong>级锁</strong>(默认)</td>
</tr>
<tr>
<td align="center">事务和崩溃后安全恢复</td>
<td align="center">不支持</td>
<td align="center">支持，同时具有回滚，崩溃修复能力</td>
</tr>
<tr>
<td align="center">外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">MVCC</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<p>MVCC多版本控制，比单纯的锁更加高效，只在<code>Read Committed</code>和<code>Repetable read</code>两个隔离级别工作，可以使用乐观锁和悲观锁来实现。</p>
<p>MyISAM更注重性能。但不是首选。</p>
<h1 id="2、字符集与校对规则"><a href="#2、字符集与校对规则" class="headerlink" title="2、字符集与校对规则"></a>2、字符集与校对规则</h1><p>字符集指的是一种从而二进制编码到某类字符符号的映射。校对规则是指某种字符集下的排序规则。MySql中每一种字符集都会对应一系列的校对规则。</p>
<p>M采用的是类似继承的方式制定字符集的默认值，每个数据库和每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集(这些表在没有指定字符集的情况下，才会采用摩恩字符集)。</p>
<p>详细参考：<a href="https://www.cnblogs.com/geaozhang/p/6724393.html#MySQLyuzifuji">字符集与校对规则</a></p>
<h1 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h1><p><a href="https://krains.gitee.io/blogs/MySQL/MySQL%E7%B4%A2%E5%BC%95.html#b-tree">参考</a></p>
<p>索引的数据结构主要有：B树和哈希索引。哈希索引的底层就是哈希表，因为在绝大多数需求为单条记录查询的时候，可以选择哈希索引，其他情况下选择B树索引。</p>
<p>B树使用的是B+树。两种存储引擎的实现方式不同：</p>
<ul>
<li><p>MyIASM</p>
<p>叶节点的data区域存放是是数据记录的地址。在索引检索的时候，按照B树算法索引，指定的Key存在，则取出data域的值，然后以data域的值为地址读取对应的数据记录。这被称为“非聚簇索引”。</p>
</li>
<li><p>InnoDB</p>
<p>数据文件本身就是索引文件。树的叶节点data域保存了完整的数据记录，因此InnoDB表数据文件本身就是主索引，这称为“聚簇索引”。其余的索引作为辅助索引，辅助索引的data记录的是相应记录主键的值而不是地址。</p>
<p>在根据主索引搜索时，直接找到Key所在的节点；在根据辅助索引查找时，先取出主键的值，再走一遍主索引。因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，会造成主索引频繁分裂。</p>
</li>
</ul>
<h1 id="4、查询缓存"><a href="#4、查询缓存" class="headerlink" title="4、查询缓存"></a>4、查询缓存</h1><p>8.0版本移除，不实用。</p>
<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。</p>
<h1 id="5、事务"><a href="#5、事务" class="headerlink" title="5、事务"></a>5、事务</h1><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul>
<li>原子性：事务是自小的执行单位。原子性确保动作要么全部完成，要么全部不执行。</li>
<li>一致性：数据库从一个正确状态变化到另一个一致性状态。</li>
<li>隔离性：并发访问数据库，两个用户的事务不干扰。并发事务之间的数据库是独立的。</li>
<li>持久性：对数据库的改变是持久的，即使数据库发生故障也不应该有影响。</li>
</ul>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><ul>
<li><p><strong>脏读</strong></p>
<p>一个事务修改数据库，还没提交。另一个事务读数据，因为这个数据还没提交，所以读出的是脏数据。对脏数据的操作可能不正确。</p>
</li>
<li><p>丢失修改</p>
<p>两个事务读一个数据，第一个事务修改之后第二个事务也修改，这样第一个事务修改的结果就丢失了。保留第二次修改的结果。</p>
</li>
<li><p>不可重复读</p>
<p>一个事务内多次读用一个数据，在两次读数据之间，由于第二个事务修改数据，导致两次读的数据不同，称为不可重复读。</p>
</li>
<li><p>幻读</p>
<p>它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
</li>
</ul>
<p>不可重复读的重点是多次读取发现某些列被修改。</p>
<p>幻读重点是多次读取发现记录增多后者减少。</p>
<h2 id="数据库的隔离级别："><a href="#数据库的隔离级别：" class="headerlink" title="数据库的隔离级别："></a>数据库的隔离级别：</h2><ul>
<li><p>读未提交</p>
<p>允许读取尚未提交的数据变更，可能导致脏读幻读或者不可重复读。</p>
</li>
<li><p>读已提交</p>
<p>允许读取并发事务已经提交的数据。避免脏读，但是幻读和不可重复读可能发生。</p>
</li>
<li><p>可重复读</p>
<p>对同一字段的多次读取结果都是一致的，除非被本身事务自己修改。</p>
</li>
<li><p>可串行化</p>
<p>最高的更隔离级别。服务ACID，所以的事务逐个执行，这样事务之间不产生干扰</p>
</li>
</ul>
<p>InnoDB默认是可重复读。使用的是next-key lock算法，避免幻读，已经达到了可串行化的隔离级别。隔离级别越低，锁越少，所以大部分数据库的隔离级别都是读已提交，但是InnoDB使用可重复读，并且不会有性能损失。InnoDB在分布式事务的情况下使用可串行化的隔离级别。</p>
<h2 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h2><ul>
<li>表级锁：粒度最大的锁，整张表加锁。实现简单，资源消耗少，加锁快，不会出现死锁。出发锁冲突的概率高，并发度最低。</li>
<li>行级锁：粒度最小，当前操作行加锁。大大减少数据库操作的冲突，并发度高。开销大，加锁慢，会出现死锁。</li>
</ul>
<p>InnoDB存储引擎的算法有三种：</p>
<ul>
<li>Reacord lock：单行记录锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身。</li>
<li>Next-key lock：record+gap，包含记录本身。</li>
</ul>
<p>补充：</p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h1 id="6、大表优化"><a href="#6、大表优化" class="headerlink" title="6、大表优化"></a>6、大表优化</h1><p>MYSQL表单过大，数据库的CRUD性能下降，措施如下：</p>
<ul>
<li><p>限定数据范围</p>
<p>禁止不带任何限制数据范围条件范围的查询语句。</p>
</li>
<li><p>读写分离</p>
<p>主库写，从库读。</p>
</li>
<li><p>垂直分区</p>
<p>数据表的相关性进行拆分。把一张列比较多的表拆分成多张表。</p>
<ul>
<li>优点：列数据变小，在查询时减少读取的block数，减少IO次数。简化表结构，易于维护。</li>
<li>缺点：主键冗余，需要管理冗余列，引起join操作，事务变得复杂。</li>
</ul>
</li>
<li><p>水平分区</p>
<p>保持数据表结构不变，通过策略存储数据分片，这样每一片数据分散到不同的表或者库中，达到分布式的目的。</p>
<p>水平拆分支持大的数据量。但是分表仅仅解决了单一表数据量大的问题，但是表数据还在同一台机器上，其实对于并发能力没有太多提升。所以水平拆分最好分库。</p>
<p>分片支持大的数据量存储，但是分片事务难以解决，逻辑复杂，尽量不分片，非要分片，尽量选择客户端分片，可以减少一次和中间件的网络IO</p>
<p>数据库分片的两种常见方案：</p>
<ul>
<li>客户端代理：<strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> （推荐） 、阿里的TDDL是两种比较常用的实现。</li>
<li>中间件代理：<strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
</li>
</ul>
<p><strong>分库分表之后，ID主键如何处理：</strong></p>
<ul>
<li>UUID：太长无序不可读，查询效率低，比较适合用于生成名字唯一的标识比如文件的名字。</li>
<li>自增ID：两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li>redis：性能好，灵活方便，不依赖数据库。</li>
<li>雪花算法</li>
</ul>
<h1 id="7、池化"><a href="#7、池化" class="headerlink" title="7、池化"></a>7、池化</h1><p>这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd">池化设计思想</a>介绍的还不错。</p>
<p>数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。<strong>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中</strong>。 连接池还减少了用户必须等待建立与数据库的连接的时间。</p>
<h1 id="8、常见问题："><a href="#8、常见问题：" class="headerlink" title="8、常见问题："></a>8、常见问题：</h1><h2 id="MySQL高性能规范"><a href="#MySQL高性能规范" class="headerlink" title="MySQL高性能规范"></a>MySQL高性能规范</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd">参考阅读</a></p>
<h2 id="SQL执行的很慢的原因"><a href="#SQL执行的很慢的原因" class="headerlink" title="SQL执行的很慢的原因"></a>SQL执行的很慢的原因</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd">参考阅读</a></p>
<h2 id="行存储与列存储"><a href="#行存储与列存储" class="headerlink" title="行存储与列存储"></a>行存储与列存储</h2><p><a href="https://zhuanlan.zhihu.com/p/35622907">摘自</a></p>
<p>主流的（OLTP）数据库大多数采用行存储，随着分析性数据库（OLAP）数据库的兴起，列存储又变的流行。</p>
<p>列存储优势一方面体现在存储上节约空间，减少IO。另一方面依靠列式数据结构做了计算上的优化。</p>
<h3 id="什么是列式存储"><a href="#什么是列式存储" class="headerlink" title="什么是列式存储"></a>什么是列式存储</h3><p><img src="https://pic2.zhimg.com/80/v2-8b8fc4a44e17f2d10b82a7f802a31011_720w.jpg" alt="img"></p>
<p>传统OLTP数据库通常采用行存储，所有的列依次排列成一行，以行为单位存储，再配合B+树或者SS-Table作为索引，就能快速通过主键找到相应的行数据。</p>
<p>行存储对于OLTP场景很自然：大多数操作都是以实体为单位，把一行数据存储在相邻的位置是个很好的选择。</p>
<p>对于OLAP场景来说，一个典型的查询需要遍历整张表，进行分组、排序、聚合等操作，这样一来行存储就没有优势了。更糟糕的是，分新型SQL通常不会用到所有的列，仅仅对某些感兴趣的列运算，一行中的无关列也不得不参与扫描。</p>
<p>列存储就是为这样的需求设计的。如下图所示，同一列的数据被一个一个紧挨着放在一起，表的每列构成一个长数组。</p>
<p><img src="https://pic2.zhimg.com/80/v2-57bf414b5fc1af277cbf74d9e4412bc1_720w.jpg" alt="img"></p>
<p>列存储对于OLTP的场景不友好，一行数据的写入需要同时修改多个列。但是对于OLAP数据库有着很大的优势。</p>
<ul>
<li>当查询语句只设计到部分列时，只需要扫描相关的列。</li>
<li>每一列的数据都是相同类型，彼此间的相关性更大，对列数据存储的压缩效率高。</li>
</ul>
<blockquote>
<p><strong>Bigtable(HBase)是列存储吗？</strong></p>
<p>其实不是列存储，是按照key-value pair存储数据，和列存储无关系。</p>
<p>但是BT有列簇概念。列簇可以指定给某个locality group，决定改列簇数据的物理位置，从而让同一主键的各个列簇分别存放在最优的物理节点上，</p>
<p>由于 column family 内的数据通常具有相似性，对它做压缩要比对整个表压缩效果更好。</p>
<blockquote>
<p>列式数据库可以是关系型、也可以是 NoSQL，这和是否是列式并无关系。</p>
</blockquote>
</blockquote>
<h3 id="DSM-分页模式"><a href="#DSM-分页模式" class="headerlink" title="DSM 分页模式"></a>DSM 分页模式</h3><p>我们知道，由于机械磁盘受限于磁头寻址过程，读写通常都以一块（block）为单位，<strong>故在操作系统中被抽象为块设备</strong>，与流设备相对。这能帮助上层应用是更好地管理储存空间、增加读写效率等。这一特性直接影响了数据库储存格式的设计：数据库的 Page 对应一个或几个物理扇区，让数据库的 Page 和扇区对齐，提升读写效率。</p>
<p>大多数服务于在线查询的DBMS采用NSM即安行存储的方式，将完整的行从header开依次存放。页的最后有一个索引，存放了页内各行的起始偏移量。由于每行的长度不一定固定，索引可以帮我们快速找到需要的行，无序逐个扫描。但是缺点在于，如果每次只涉及到很小的一部分列，那多余的列依然浪费内存以及CPU cache，导致更多的IO，为了避免这一问题，分析性数据库采用DSM列存储：将relationan按照列拆分成多个sub-relation。类似的，在页尾部存放一个索引。</p>
<p>NSM可以快速取出某一行的数据，因为一行的数据保存在同一页；DSM能更好的利用CPU cache以及更紧凑的压缩。</p>
<blockquote>
<p>分布式储存系统虽然不再有页的概念，但是仍然会将文件切割成分块进行储存，但分块的粒度要远远大于一般扇区的大小（如 HDFS 的 Block Size 一般是 128MB）。更大的读写粒度是为了适应网络 IO 更低的带宽以获得更大的吞吐量，但另一方面也牺牲了细粒度随机读写。</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-f6b341f0aa6345e5fe7f1c3dc52da510_720w.jpg" alt="img"></p>
<h3 id="列存储与分布式文件系统"><a href="#列存储与分布式文件系统" class="headerlink" title="列存储与分布式文件系统"></a>列存储与分布式文件系统</h3><p>在现代的大数据架构中，GFS，HDFS等分布式文件系统已经成为存放按规模数据集的主流方式，。分布式文件系统相比单机的磁盘，具备多副本高可用容量大成本低等优势，但是也有一些单机架构没有的问题。</p>
<ul>
<li>读写均要经过网络，吞吐量可以追平甚至超过硬盘，但是<strong>延迟要比硬盘大得多</strong>，且受网络环境影响很大。</li>
<li>可以进行大吞吐量的顺序读写，但随机访问性能很差，大多<strong>不支持随机写入</strong>。为了抵消网络的 overhead，通常写入都以几十 MB 为单位。</li>
</ul>
<p>以上缺点对于重度依赖读写的OLTP场景数据库来说是致命的。所以很多定位于OLAP的列存储放弃OLTP能力，从而构建在分布式文件系统之上。</p>
<p>充分发挥分布式文件系统的性能，有以下几种方式：按块读取数据，流式读取，追加写入等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了列式存储的存储结构设计。抛开种种繁复的细节，我们看到，以下这些思想或设计是具有共性的。</p>
<ol>
<li><strong>跳过无关的数据</strong>。从行存到列存，就是消除了无关列的扫描；ORC 中通过三层索引信息，能快速跳过无关的数据分片。</li>
<li><strong>编码既是压缩，也是索引</strong>。Dremel 中用精巧的嵌套编码避免了大量 NULL 的出现；C-Store 对 distinct 值的编码同时也是对 distinct 值的索引；PowerDrill 则将字典编码用到了极致（见下一篇文章）。</li>
<li><strong>假设数据不可变</strong>。无论 C-Store、Dremel 还是 ORC，它们的编码和压缩方式都完全不考虑数据更新。如果一定要有更新，暂时写到别处、读时合并即可。</li>
<li><strong>数据分片</strong>。处理大规模数据，既要纵向切分也要横向切分，不必多说。</li>
</ol>
<h2 id="MYSQL复制"><a href="#MYSQL复制" class="headerlink" title="MYSQL复制"></a>MYSQL复制</h2><p>摘自<a href="https://www.jianshu.com/p/63c1a1babfd1">简书</a></p>
<blockquote>
<p>保证主服务器(master)和从服务器(Slave)的数据是一致性的，向master插入数据后，slave会自动从master把修改的数据同步过来(有一定延迟)，通过这种方式保证数据一致性，就是mysql复制。</p>
</blockquote>
<h3 id="复制能解决什么问题？"><a href="#复制能解决什么问题？" class="headerlink" title="复制能解决什么问题？"></a>复制能解决什么问题？</h3><ul>
<li><p>高可用和故障切换</p>
<p>master挂掉后可以指定一台slave充当master继续保证服务运行。</p>
</li>
<li><p>负载均衡</p>
<p>开发中可能会遇到锁表，导致暂时不能使用读的操作，使用主从复制，主库负责写，从库负责读，这样即使主库锁表，读从库也能保证业务的正常运行。</p>
<p>调查发现一般读写的比例是10:1，所以需要多个slave。保证了系统的高可用。</p>
</li>
<li><p>数据备份</p>
</li>
<li><p>业务模块化</p>
<p>可以一个业务模块读取slave，再针对不同的业务场景进行数据库的索引创建和根据业务选择mysql引擎，不同的slave可以根据不同需求设置不同的索引和存储引擎。</p>
</li>
</ul>
<p><strong>主从节点需要注意：</strong></p>
<p>(1)主从服务器操作系统版本和位数一致；<br> (2) Master和Slave数据库的版本要一致；<br> (3) Master和Slave数据库中的数据要一致；<br> (4) Master开启二进制日志，Master和Slave的server_id在局域网内必须唯一；</p>
<h3 id="复制的流程"><a href="#复制的流程" class="headerlink" title="复制的流程"></a>复制的流程</h3><ul>
<li>master将数据改变写到二进制日志(binary log)中，也就是配置文件login-bin 指定的文件。</li>
<li>slave通过线程IO读取日志文件并写入到中继日志（relay log）</li>
<li>slave重做中继日志中的事件，把中继日志的事件信息一条条的本地执行，完成数据在本地的存储，从而实现将改变反映到他自己的数据（数据重放）。</li>
</ul>
<p><strong>复制涉及到三个线程</strong>：</p>
<ul>
<li><p>主节点binary log dump线程（IO线程）</p>
<p>slave连接master时，master创建log dump线程，发送bin-log内容。在读取bin-log中的操作时，线程会给bin-log加锁。</p>
</li>
<li><p>从节点IO线程‘</p>
<p>当从节点执行<code>start slave</code>命令之后，从节点创建一个IO线程来连接主节点，请求从主库中更新bin-log。IO线程收到主节点的binlog sump线程发来的更新之后，保存在本地的relay-log中。</p>
</li>
<li><p>从节点SQL线程</p>
<p>读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据库的一致性。</p>
</li>
</ul>
<h3 id="复制类型"><a href="#复制类型" class="headerlink" title="复制类型"></a>复制类型</h3><ul>
<li><p>基于语句的复制 statement-base Replication(SBR)</p>
<p>在master上执行的SQL语句，在slave上会执行相同的语句。Mysql默认采用基于语句的复制，效率比较高。一旦发现没法精准复制时，会自动选基于行的复制。</p>
<blockquote>
<p>优点是只需要记录修改数据的sql语句到binlog，减少binlog日志量，节约IO。</p>
<p>缺点是语句很复杂的时候，slave执行消耗过多资源，而基于行复制的话，只会记录变更的行记录。</p>
</blockquote>
</li>
<li><p>基于行的复制</p>
<p>把改变的内容复制到slave，而不是把命令在slave执行一遍。</p>
<blockquote>
<p>优点：只会记录变更的行记录，哪怕一个语句很复杂，但是它最后只影响几条记录，那么行的复制，只会把影响到几条记录记录到binlog，降低slave重放日志时的资源消耗。</p>
<p>缺点：日志庞大，不利于数据库的还原。</p>
</blockquote>
</li>
<li><p>混合类型的复制</p>
<p>默认采用基于语句的复制，当发现基于语句的复制无法精确的复制时，采用基于行的复制。</p>
</li>
</ul>
<h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><ul>
<li><p><strong>第一范式</strong>(确保每列保持原子性)</p>
<p>最基本的范式。如果数据库表中所有字段都是不可分解的原子值，说明满足第一范式。如地址，有时候需要访问地址中的省份部分，有时候访问城市部分，这时候将地址拆分成省份、城市、详细地址等多个部分进行存储，这样设计就满足了第一范式。</p>
</li>
<li><p><strong>第二范式</strong>(确保表中的每列都和主键相关)</p>
<p>在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/2012040114063976.png" alt="2012040114063976"></p>
<p>例如这张表，就要拆成，订单信息表，订单项目表，商品信息表。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/2012040114082156.png" alt="2012040114082156"></p>
</li>
<li><p>第三范式(确保每列都和主键直接相关，而不是间接相关)</p>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/03/24/Redis/</url>
    <content><![CDATA[<h1 id="一、Redis相关操作"><a href="#一、Redis相关操作" class="headerlink" title="一、Redis相关操作"></a>一、Redis相关操作</h1><h2 id="1-docker安装redis"><a href="#1-docker安装redis" class="headerlink" title="1.docker安装redis"></a>1.docker安装redis</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -d --name redis -p 6379:6379 redis</span></span><br><span class="line">docker exec -it redis redis-cli</span><br></pre></td></tr></table></figure>

<h2 id="2-redis配置"><a href="#2-redis配置" class="headerlink" title="2.redis配置"></a>2.redis配置</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">进入解压的Redis目录，将redis.conf复制到安装文件的目录下</span><br><span class="line">cp redis.conf /usr/local/redis</span><br><span class="line">启动自定义配置的Redis</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf</span><br></pre></td></tr></table></figure>

<h2 id="3-配置详解"><a href="#3-配置详解" class="headerlink" title="3.配置详解"></a>3.配置详解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize ： 默认为no，修改为yes启用守护线程</span><br><span class="line">port ：设定端口号，默认为6379</span><br><span class="line">bind ：绑定IP地址</span><br><span class="line">databases ：数据库数量，默认16</span><br><span class="line">save &lt;second&gt; &lt;changes&gt; ：指定多少时间、有多少次更新操作，就将数据同步到数据文件</span><br><span class="line">#redis默认配置有三个条件，满足一个即进行持久化</span><br><span class="line">save 900 1 #900s有1个更改</span><br><span class="line">save 300 10 #300s有10个更改</span><br><span class="line">save 60 10000 #60s有10000更改</span><br><span class="line">dbfilename ：指定本地数据库的文件名，默认为dump.rdb</span><br><span class="line">dir ：指定本地数据库的存放目录，默认为.&#x2F;当前文件夹</span><br><span class="line">requirepass ：设置密码，默认关闭</span><br><span class="line">redis -cli -h host -p port -a password</span><br></pre></td></tr></table></figure>

<h2 id="4-redis常用命令"><a href="#4-redis常用命令" class="headerlink" title="4.redis常用命令"></a>4.redis常用命令</h2><p>redis五种数据类型：<strong>string、hash、list、set、zset</strong></p>
<ul>
<li>DEL key</li>
<li>Dump key：序列化给定key，返回被序列化的值</li>
<li>EXIST key：检查KEY是否存在</li>
<li>EXPIRE key second：为key设定过期时间</li>
<li>TTL key：返回key剩余时间</li>
<li>PERSIST key：移除key的过期时间，持久保存</li>
<li>KEY pattern：查询所有符号给定模式的key</li>
<li>RENAME key：修改key的名称</li>
<li>MOVE key db：移动key到指定数据库中</li>
<li>TYPE key：返回key所存储的值的类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXPIRE key second的使用场景：</span><br><span class="line"><span class="number">1</span>、限时的优惠活动</span><br><span class="line"><span class="number">2</span>、网站数据缓存</span><br><span class="line"><span class="number">3</span>、手机验证码</span><br><span class="line"><span class="number">4</span>、限制网站访客频率</span><br></pre></td></tr></table></figure>

<p><strong>key的命名建议</strong></p>
<ol>
<li>key不要太长，尽量不要超过1024字节。不仅消耗内存，也会降低查找的效率</li>
<li>key不要太短，太短可读性会降低</li>
<li>在一个项目中，key最好使用统一的命名模式，如user:123:password</li>
<li>key区分大小写</li>
</ol>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string类型是二进制安全的，redis的string可以包含任何数据，如图像、序列化对象。一个键最多能存储512MB。二进制安全是指，在传输数据的时候，能保证二进制数据的信息安全，也就是不会被篡改、破译；如果被攻击，能够及时检测出来。</p>
<p><strong>常用命令</strong></p>
<ul>
<li><strong>setkey_name value</strong>：命令不区分大小写，但是key_name区分大小写</li>
<li><strong>SETNX key value</strong>：当key不存在时设置key的值。（SET if Not eXists）</li>
<li><strong>get key_name</strong></li>
<li><strong>GETRANGE key start end</strong>：获取key中字符串的子字符串，从start开始，end结束</li>
<li>**MGET key1 [key2 …]**：获取多个key</li>
<li><strong>GETSET KEY_NAME VALUE</strong>：设定key的值，并返回key的旧值。当key不存在，返回nil</li>
<li><strong>STRLEN key</strong>：返回key所存储的字符串的长度</li>
<li><strong>INCR KEY_NAME</strong> ：INCR命令key中存储的值+1,如果不存在key，则key中的值话先被初始化为0再加1</li>
<li><strong>INCRBY KEY_NAME</strong> 增量</li>
<li><strong>DECR KEY_NAME</strong>：key中的值自减一</li>
<li><strong>DECRBY KEY_NAME</strong></li>
<li><strong>append key_name value</strong>：字符串拼接，追加至末尾，if不存在，为其赋值</li>
</ul>
<p><strong>string的应用场景</strong></p>
<p>1、String通常用于保存单个字符串或JSON字符串数据 </p>
<p>2、因为String是二进制安全的，所以可以把保密要求高的<strong>图片文件内容</strong>作为字符串来存储</p>
<p> 3、计数器：常规Key-Value缓存应用，如微博数、粉丝数。INCR本身就具有原子性特性，所以不会有线程安全问题 。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>Redis hash是一个string类型的field和value的映射表，<strong>hash特别适用于存储对象</strong>。每个hash可以存储232-1键值对。可以看成KEY和VALUE的MAP容器。相比于JSON，hash占用很少的内存空间。</p>
<p><strong>常用命令</strong></p>
<ul>
<li>HSET key_name field value：为指定的key设定field和value </li>
<li>hmset key field value[field1,value1]</li>
<li>hget key field</li>
<li>hmget key field[field1]</li>
<li>hgetall key：返回hash表中所有字段和值</li>
<li>hkeys key：获取hash表所有字段</li>
<li>hlen key：获取hash表中的字段数量 </li>
<li>-hdel key field [field1]：删除一个或多个hash表的字段</li>
</ul>
<p><strong>hash的应用场景</strong></p>
<p>hash的应用场景，通常用来存储一个用户信息的对象数据</p>
<p>1、相比于存储对象的string类型的json串，json串修改单个属性需要将整个值取出来。而hash不需要</p>
<p>2、相比于多个key-value存储对象，hash节省了很多内存空间</p>
<p>3、如果hash的属性值被删除完，那么hash的key也会被redis删除</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>类似于java中的LinkedList</p>
<p><strong>常用命令</strong></p>
<ul>
<li>lpush key value1 [value2]</li>
<li>rpush key value1 [value2]</li>
<li>lpushx key value：从左侧插入值，如果list不存在，则不操作</li>
<li>rpushx key value：从右侧插入值，如果list不存在，则不操作</li>
<li>llen key：获取列表长度</li>
<li>lindex key index：获取指定索引的元素</li>
<li>lrange key start stop：获取列表指定范围的元素</li>
<li>lpop key ：从左侧移除第一个元素</li>
<li>prop key：移除列表最后一个元素</li>
<li>blpop key [key1] timeout：移除并获取列表第一个元素，如果列表没有元素会阻塞列表到等待超时或发现可弹出元素为止</li>
<li>brpop key [key1] timeout：移除并获取列表最后一个元素，如果列表没有元素会阻塞列表到等待超时或发现可弹出元素为止</li>
<li>ltrim key start stop ：对列表进行修改，让列表只保留指定区间的元素，不在指定区间的元素就会被删除</li>
<li>lset key index value ：指定索引的值</li>
<li>linsert key before|after world value：在列表元素前或则后插入元素</li>
</ul>
<p><strong>应用场景</strong></p>
<p>1、对数据大的集合数据删减     列表显示、关注列表、粉丝列表、留言评价…分页、热点新闻等</p>
<p>2、任务队列     list通常用来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样通过order by来排序</p>
<p><strong>补充</strong></p>
<p>rpoplpush list1 list2 移除list1最后一个元素，并将该元素添加到list2并返回此元素。用此命令可以实现订单下单流程、用户系统登录注册短信等。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>唯一、无序</p>
<p><strong>常用命令</strong></p>
<ul>
<li>sadd key value1[value2]：向集合添加成员</li>
<li>scard key：返回集合成员数</li>
<li>smembers key：返回集合中所有成员</li>
<li>sismember key member：判断memeber元素是否是集合key成员的成员</li>
<li>srandmember key [count]：返回集合中一个或多个随机数</li>
<li>srem key member1 [member2]：移除集合中一个或多个成员</li>
<li>spop key：移除并返回集合中的一个随机元素</li>
<li>smove source destination member：将member元素从source集合移动到destination集合</li>
<li>sdiff key1 [key2]：返回所有集合的差集</li>
<li>sdiffstore destination key1[key2]：返回给定所有集合的差集并存储在destination中</li>
</ul>
<p><strong>应用场景</strong></p>
<p>对两个集合间的数据【计算】进行交集、并集、差集运算</p>
<p>1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。</p>
<p>2、利用唯一性，可以统计访问网站的所有独立 IP</p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>有序且不重复、每个元素都会关联一个double类型的分数，redis通过分数进行从小到大的排序。分数可以重复</p>
<p><strong>常用命令</strong></p>
<ul>
<li>ZADD key score1 memeber1</li>
<li>ZCARD key ：获取集合中的元素数量</li>
<li>ZCOUNT key min max 计算在有序集合中指定区间分数的成员数</li>
<li>ZCOUNT key min max 计算在有序集合中指定区间分数的成员数</li>
<li>ZRANK key member：返回有序集合指定成员的索引</li>
<li>ZREVRANGE key start stop ：返回有序集中指定区间内的成员，通过索引，分数从高到底</li>
<li>ZREM key member [member …] 移除有序集合中的一个或多个成员</li>
<li>ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员(第一名是0)(低到高排序）</li>
<li>ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员</li>
</ul>
<p><strong>应用场景</strong></p>
<p>常用于排行榜</p>
<p>1、推特可以以发表时间作为score存储</p>
<p>2、存储成绩</p>
<p>3、做带权重的队列，让重要的任务先执行</p>
<h1 id="二、SpringBoot整合Redis"><a href="#二、SpringBoot整合Redis" class="headerlink" title="二、SpringBoot整合Redis"></a>二、SpringBoot整合Redis</h1><p>基于内存进行存储，支持key-value的存储形式，底层是用C语言写的。</p>
<p>基于key-value形式的数据字典，结构非常简单，没有数据表的概念，直接用键值对的形式完成数据的管理，支持5种数据类型：</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>集合</li>
<li>有序集合</li>
<li>哈希</li>
</ul>
<figure class="highlight plain"><figcaption><span>off</span></figcaption><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Redis启动批处理程序</span><br><span class="line">title redis-server</span><br><span class="line">set ENV_HOME&#x3D;&quot;C:\redis&quot;</span><br><span class="line">C:</span><br><span class="line">color 0F</span><br><span class="line">cd %ENV_HOME%</span><br><span class="line">redis-server redis.windows.conf</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot-整合-Redis"><a href="#Spring-Boot-整合-Redis" class="headerlink" title="Spring Boot 整合 Redis"></a>Spring Boot 整合 Redis</h2><p>实际上使用Spring Data Redis操作Redis，</p>
<p>1、创建maven工程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.hhzhu&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redis_practice&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>2、创建实体类，实现序列化接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//实现序列化接口，否则无法存入redis</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、创建控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="comment">//Request将json数据转换成java对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;student&quot;</span>,student);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、创建配置文件appliacation.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    database: 0</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>

<p>5、创建启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6、CRUD</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="comment">//Request将json数据转换成java对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;student&quot;</span>,student);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get/&#123;key&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;key&quot;)</span> String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Student) redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;key&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;key&quot;)</span> String key)</span></span>&#123;</span><br><span class="line">        redisTemplate.delete(key);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Redis-5种数据类型"><a href="#Redis-5种数据类型" class="headerlink" title="Redis 5种数据类型"></a>Redis 5种数据类型</h2><ul>
<li><p><strong>字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/string&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">stringTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;str&quot;</span>,<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="comment">//System.out.println(redisTemplate.opsForValue().get(&quot;str&quot;));</span></span><br><span class="line">    String str = (String) redisTemplate.opsForValue().get(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">listTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ListOperations&lt;String,String&gt; listOperations = redisTemplate.opsForList();</span><br><span class="line">    listOperations.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    listOperations.leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    listOperations.rightPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    List&lt;String&gt; list = listOperations.range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>集合(set)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">setTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SetOperations&lt;String,String&gt; setOperations = redisTemplate.opsForSet();</span><br><span class="line">    setOperations.add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    setOperations.add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    setOperations.add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    setOperations.add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    setOperations.add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    setOperations.add(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    Set&lt;String&gt; set = setOperations.members(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>有序集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/zset&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">zsetTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ZSetOperations&lt;String,String&gt; zSetOperations = redisTemplate.opsForZSet();</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;Hello&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">    Set&lt;String&gt; set = zSetOperations.range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>哈希</strong></p>
<p>Hash：key value</p>
<p>HashOperations：key hashkey value</p>
<p>key是每一组数据的ID，hashkey和value是一组完整的HashMap数据，通过key来区分不同的HashMap<img src="https://i.loli.net/2020/03/15/xPHZi46UdrbT2YL.png" alt="未命名文件 _1_.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(key1,value1);</span><br><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(key2,value2);</span><br><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(key3,value3);</span><br><span class="line"></span><br><span class="line">HashOperations&lt;String,String,String&gt; hashOperation = redisTemplate.opsForHash();</span><br><span class="line">hashOperation.put(hashMap1,key1,value1);</span><br><span class="line">hashOperation.put(hashMap2,key2,value2);</span><br><span class="line">hashOperation.put(hashMap3,key3,value3);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hash&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hashTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashOperations&lt;String,String,String&gt; hashOperations = redisTemplate.opsForHash();</span><br><span class="line">    hashOperations.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;hashKey&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(hashOperations.get(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;hashKey&quot;</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、Redis常见问题"><a href="#三、Redis常见问题" class="headerlink" title="三、Redis常见问题"></a>三、Redis常见问题</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>使用C语言开发的k-v数据库，数据存储在内存，读写速度很快，一般用于缓存方向，也可以用来做分布式锁，消息队列。提供了五中数据类型String,hash,list,set,zset。支持事务，持久化，lua脚本，多重集群方案。</p>
<h2 id="分布式缓存常见的技术选型"><a href="#分布式缓存常见的技术选型" class="headerlink" title="分布式缓存常见的技术选型"></a>分布式缓存常见的技术选型</h2><p>Memcached和Redis。</p>
<p>前者是分布式缓存刚兴起，后来随着Redis发展，都是用redis了。分布式缓存主要解决的问题是，单击缓存的容量收到服务器限制且无法保存通用的消息。因为本地缓存只在当前服务有效。</p>
<h2 id="redis和Memcached的区别和共同点"><a href="#redis和Memcached的区别和共同点" class="headerlink" title="redis和Memcached的区别和共同点"></a>redis和Memcached的区别和共同点</h2><p><strong>共同点：</strong></p>
<ul>
<li>基于内存</li>
<li>过期策略</li>
<li>高性能</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>redis数据类型更丰富-五种，后者只是简单的k-v</li>
<li>redis数据持久化，重启的时候可以再次加载使用。后者单纯放在内存。</li>
<li>redis灾难恢复机制。因为可以持久化</li>
<li>redis在内存用完之后，可以将数据放磁盘，后者直接报异常。</li>
<li>M没有原生的集群模式。redis原生支持cluster模式</li>
<li>M多线程非阻塞IO复用的网络模型；R单线程多路IO复用模型（R6.0之后引入多线程）</li>
<li>R支持发布订阅模型，Lua脚本，事务。M不支持。</li>
<li>M过期数据只用了惰性删除，R使用了惰性删除和定期删除。</li>
</ul>
<h2 id="缓存数据的处理流程"><a href="#缓存数据的处理流程" class="headerlink" title="缓存数据的处理流程"></a>缓存数据的处理流程</h2><ul>
<li>数据在缓存直接返回</li>
<li>不在缓存查数据库</li>
<li>数据库存在更新缓存</li>
<li>数据库不在返回空</li>
</ul>
<h2 id="为什么用R缓存"><a href="#为什么用R缓存" class="headerlink" title="为什么用R缓存"></a>为什么用R缓存</h2><p><strong>高性能：</strong></p>
<p>直接访问数据库会比较慢，因为要从次硬盘读取。对于某些不常改变的高频数据，可以放在缓存中，访问时直接存缓存读取，这样比较快。需要保证数据一致性，当数据库的数据改变时，缓存的数据也要同步更新。</p>
<p><strong>高并发：</strong></p>
<p>MYSQL的QPS在1W左右（4core 8G），使用R之后可以达到10W-30W+。</p>
<blockquote>
<p>QPS：服务器每秒可以执行的查询次数。</p>
</blockquote>
<h2 id="R单线程模型"><a href="#R单线程模型" class="headerlink" title="R单线程模型"></a>R单线程模型</h2><blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，文本事件处理器主要是4个部分：</p>
<ul>
<li>多个socket（客户端连接）</li>
<li>IO多路复用（支持多个客户端连接的关键）</li>
<li>文本事件分派器（将socket关联到相应的时间处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210325164739624.png" alt="image-20210325164739624"></p>
<h2 id="R为什么不使用多线程"><a href="#R为什么不使用多线程" class="headerlink" title="R为什么不使用多线程"></a>R为什么不使用多线程</h2><p>单线程模型，但是在4.0之后就加入了对多线程的支持。但是多线程主要是针对一些大键值对的删除操作的命令。</p>
<p>大体来说R还是单线程处理，为何不使用多线程？</p>
<ul>
<li>单线程编程容易且易维护</li>
<li>性能瓶颈不在CPU，在于内存和网络</li>
<li>多线程存在死锁，线程上下文切换问题，甚至影响性能。</li>
</ul>
<h2 id="为什么6-0引入多线程。"><a href="#为什么6-0引入多线程。" class="headerlink" title="为什么6.0引入多线程。"></a>为什么6.0引入多线程。</h2><p>主要是为了提高网络IO性能瓶颈。</p>
<p>虽然6.0引入多线程，但是只在网路数据的读写这类耗时操作使用，执行命令仍然是单线程。默认是禁用的。</p>
<p>开多线程之后，还需要设置线程数，否则不生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span><br></pre></td></tr></table></figure>

<h2 id="缓存数据设置过期时间有啥用"><a href="#缓存数据设置过期时间有啥用" class="headerlink" title="缓存数据设置过期时间有啥用"></a>缓存数据设置过期时间有啥用</h2><p>内存有限。</p>
<p>业务场景需要。(token，短信验证码)</p>
<h2 id="R如何判断数据是否过期呢？"><a href="#R如何判断数据是否过期呢？" class="headerlink" title="R如何判断数据是否过期呢？"></a>R如何判断数据是否过期呢？</h2><p>过期字典来保存过期时间。过期字典的k指向数据库的某个key，保存了数据库键的过期时间（毫秒精度的unix时间戳)</p>
<h2 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h2><ul>
<li>惰性删除：取出key的时候过期检查。CPU友好，但是可能太多过期K没删除</li>
<li>定期删除：每隔一段时间抽取K删除过期K。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
</ul>
<p>一种是内存友好，一种CPU友好，所以R是定期+惰性。</p>
<p>仅仅通过K的过期时间有问题，因为可能存在定期删除和惰性漏掉的问题，这样导致大量过期K堆积在内存。–内存淘汰机制。</p>
<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><ul>
<li>volatile-lru：从已设置过期时间的数据集挑选最少使用的数据淘汰</li>
<li>V-ttl：从已设置过期时间的数据集挑选将要过期的数据淘汰。</li>
<li>V-random：字面意思</li>
<li>allkeys-lru：当内存不足以容纳写入新数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li>a-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-evition：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ul>
<p>4.0版本以后增加了两种：</p>
<ul>
<li>v-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>a-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p><strong>快照和只追加文件</strong></p>
<ul>
<li><p>快照持久化</p>
<p>通过创建快照的方式获得存储在内存里面的数据的某个时间节点的副本。创建快照后可以进行备份，或者复制到其他服务器从而常创建具有相同数据的服务器副本（主从结构）。</p>
<p>快照是默认的持久化方式</p>
</li>
<li><p>AOF持久化</p>
<p>实时性更好，成为主流的方案，默认不开启，通过appendonly yes开启。</p>
<p>开启后，每次执行一条更改Redis的命令，redis就会将命写入AOF文件。默认的文件时appendonly.aof。</p>
<p>在redis存在三种不同的AOF持久化方式，分别是：</p>
<ul>
<li>appendsync always # 每次更细都写AOF</li>
<li>appendsync everysec # 每秒钟同步一次</li>
<li>appendsync no # OS决定什么时候同步</li>
</ul>
<p>兼顾数据和写入性能，选择everysec。对性能几乎没影响。</p>
</li>
</ul>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>  通过<code>MULTI</code>,<code>EXEC</code>,<code>DISCARD</code>,<code>WATCH</code>命令实现事务。使用 <a href="https://redis.io/commands/multi">MULTI</a>命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec">EXEC</a>命令将执行所有命令。</p>
<p>R的事务和数据库的事务不太一样，事务四大特性：</p>
<ul>
<li>原子性：动作要么全部完成，要么不起作用。</li>
<li>一致性：事务提交后，数据保持一致，多个事务对同一个数据库读取的结果是相同的。</li>
<li>隔离性：并发访问数据库，一个用户的事务不被打扰，并发事务之间数据库是独立的。</li>
<li>持久性：一个事物提交后，对数据的改变是持久的，及时数据库发生故障也不能有任何影响。</li>
</ul>
<p>Redis不支持回滚，不满足原子性。而且不满足持久性。为啥呢？因为他们认为没必要回滚，这样更简单且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p>R的事务可以理解为：提供了一种将多个命令请求打包的功能，然后再按照顺序执行所有命令，并且不会被中途打断。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li><p>是啥？</p>
<p>大量请求的Key不在缓存，直接到数据库。黑客故意制造缓存中不存在的Key请求，导致大量请求落到数据库。</p>
</li>
<li><p>如何解决？</p>
<p>最基本的是做好参数校验，不合法的参数直接返回客户端，例如ID不小于0，邮箱格式等。</p>
<ul>
<li><p>缓存无效key</p>
<p>缓存和数据库都查不到，就缓存这个无效key，适用于key变化不频繁的情况。会导致缓存大量无效key，可以尽量将key的过期时间设置短一点，例如1min。</p>
</li>
<li><p>布隆过滤器</p>
<p>通过它可以方便的判断一个给定数据是否存在于海量数据中。具体的做法是：把所有可能的请求的值放在过滤器，请求过来，先判断请求的值是否在过滤器，不存在的话，返回参数信息错误。存在的话，再去走缓存的流程。</p>
<p>过滤器时候存在，小概率<strong>误判</strong>；说不存在，一定不存在。</p>
<ul>
<li><p>元素加入过滤器</p>
<p>1.使用过滤器中的哈希函数对元素值计算，得到哈希值。(几个哈希函数得到几个哈希值)</p>
<p>2.根据得到的哈希值，数组中对应的下标标记为1</p>
</li>
<li><p>判断是否存在</p>
<p>1.对给定元素计算哈希值。</p>
<p>2.得到值之后判断数组中的每个元素位置是否都为1，是，说明在过滤器，存在一个值不是1，说明不在。</p>
</li>
</ul>
<p>有一种情况：不同字符串可能哈希出来的位置相同。(哈希冲突,最原始的问题)</p>
</li>
</ul>
</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>就是一个很长的数组，在存入数据的过程中，先通过三次（也可能是更多次）的哈希计算，然后把这些hash的值都标记为1，在查询的时候，先通过三次hash值，然后去查数组，有一个不是1，则数据一定不存在。但是过滤器很难实现删除操作，本质原因是没有解决哈希冲突。</p>
<p>有点是插入和删除很快。保密性好，因为只存0和1.</p>
<p>缺点就是不好删除；容易出现误判，原因是哈希冲突。问题就是如何去计量避免误判呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">//期望的误判率</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> fpp = <span class="number">0.01</span>;</span><br><span class="line">        <span class="comment">//布隆过滤器</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(),size,fpp);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">1000000</span>;</span><br><span class="line">        psvm&#123;</span><br><span class="line">            <span class="comment">//插入10万样本数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">                bloomFilter.put(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用另外十万测试数据，测试误判率</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = total;i&lt;total+<span class="number">100000</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bloomFilter.mightContain(i))&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sout(i+<span class="string">&quot;误判了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sout(<span class="string">&quot;总的误判数是：&quot;</span>+count);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是误判率不能设置成无线小，这会拖慢过滤器的计算速度。</p>
<blockquote>
<p>误判率的底层原理：</p>
<p>给出更多的哈希函数和数组空间，使用多个哈希函数算出来的哈希位置也不一样，多对应的二进制数据也就越多，这样就可以减少重复的概率。</p>
</blockquote>
<p><strong>使用布隆过滤器解决redis缓存穿透的问题：</strong></p>
<p>将数据库的数据全部存放在布隆过滤器上，先查过滤器。没有返回，有的哈，从redis查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisBloomFilter</span></span>&#123;</span><br><span class="line">    psvm&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer.setSddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        config.useSingleServer().setPassword(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        <span class="comment">//构造过滤器</span></span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line">        RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">&quot;phoneList&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化过滤器，预计元素是1000000L,误差率是3%</span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">10000L</span>,<span class="number">0.03</span>);</span><br><span class="line">        <span class="comment">//将号码10086插入到过滤器</span></span><br><span class="line">        bloomFilter.put(<span class="string">&quot;10086&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断号码是否在过滤器</span></span><br><span class="line">        sout(bloomFilter.contains(<span class="string">&quot;123456&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存在同一时间大面积失效,后面的请求落在数据库，造成短时间内数据库承受大量请求。（缓存模块宕机）</p>
<p>还有一种是有一些被大量访问的数据在某一时刻失效，导致请求落在数据库。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>缓存服务宕机<ul>
<li>redis集群</li>
<li>限流，避免同时处理大量请求。</li>
</ul>
</li>
<li>热点缓存失效：<ul>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ul>
</li>
</ul>
<h2 id="如何保证缓存和数据库的一致性"><a href="#如何保证缓存和数据库的一致性" class="headerlink" title="如何保证缓存和数据库的一致性"></a>如何保证缓存和数据库的一致性</h2><p><strong>旁路缓存模式</strong></p>
<p>遇到写请求是这样的，更新DB，直接删除缓存。</p>
<p>数据库更新成功缓存删除失败。两个方案：</p>
<ul>
<li>缓存失效时间变短（不推荐）：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li>增加cache更新重试机制（常用）：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ul>
<p>​    </p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合rabbitMQ</title>
    <url>/2020/03/15/SpringBoot%E6%95%B4%E5%90%88rabbitMQ/</url>
    <content><![CDATA[<h1 id="1-消息队列概述"><a href="#1-消息队列概述" class="headerlink" title="1.消息队列概述"></a>1.消息队列概述</h1><h2 id="1-1-消息队列和MQ"><a href="#1-1-消息队列和MQ" class="headerlink" title="1.1.消息队列和MQ"></a>1.1.消息队列和MQ</h2><p>MQ全称Message Queue，消息队列是应用程序之间的通信方法。</p>
<ul>
<li><p>为什么使用MQ？</p>
<p>在项目中，可将一些无需及时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，这种处理方式大大节省了服务器的响应时间，从而<strong>提高系统的吞吐量</strong>。</p>
</li>
<li><p>应用场景</p>
<ul>
<li><p>任务异步处理</p>
</li>
<li><p>应用程序解耦</p>
<p>相当于中介，生产方通过MQ与消费者交互。</p>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-AMQP和JMS"><a href="#1-2-AMQP和JMS" class="headerlink" title="1.2.AMQP和JMS"></a>1.2.AMQP和JMS</h2><p>MQ的两种实现方式—&gt;AMQP，JMS。</p>
<h3 id="1-2-1-AMQP"><a href="#1-2-1-AMQP" class="headerlink" title="1.2.1 AMQP"></a>1.2.1 AMQP</h3><p>是一种协议（链接协议），和JMS的本质区别是不从API层进行限定，直接定义网络交换的数据格式。</p>
<h3 id="1-2-2-JMS"><a href="#1-2-2-JMS" class="headerlink" title="1.2.2 JMS"></a>1.2.2 JMS</h3><p>java消息服务，是一个<strong>java平台</strong>中关于面向消息中间件的<strong>API</strong>，应用于两个程序之间，或分布式系统中发送消息，进行异步通信。</p>
<h3 id="1-2-3-AMQP和IMS区别"><a href="#1-2-3-AMQP和IMS区别" class="headerlink" title="1.2.3 AMQP和IMS区别"></a>1.2.3 AMQP和IMS区别</h3><ul>
<li>JMS定义统一的接口，对消息进行统一操作；A是通过协议来统一数据交换的格式。</li>
<li>J必须是Java语言，A是协议，跨语言</li>
<li>J规定两种消息模式；A更丰富。</li>
</ul>
<h2 id="1-3-消息队列产品"><a href="#1-3-消息队列产品" class="headerlink" title="1.3.消息队列产品"></a>1.3.消息队列产品</h2><ul>
<li>ActiveMQ：基于JMS</li>
<li>ZeroMQ：基于C开发</li>
<li>RabbitMQ：AMQP协议，erlang语言，性能好</li>
<li>RocketMQ：基于JMS，alibaba</li>
<li>kafka：类似于MQ的产品，分布式消息系统，高吞吐量</li>
</ul>
<h2 id="1-4-RabbitMQ"><a href="#1-4-RabbitMQ" class="headerlink" title="1.4.RabbitMQ"></a>1.4.RabbitMQ</h2><p>提供6种模式：简单模式，work模式，publish/subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用。</p>
<h1 id="2-安装及配置MQ"><a href="#2-安装及配置MQ" class="headerlink" title="2.安装及配置MQ"></a>2.安装及配置MQ</h1><ul>
<li><p>安装erlang</p>
</li>
<li><p>安装MQ</p>
</li>
<li><p>安装MQ的图形管理插件</p>
</li>
<li><p>创建管理用户</p>
</li>
<li><p>创建虚拟主机Virtual Hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">1[安装erlang]--&gt;2[安装RabbitMQ]</span><br><span class="line">2--&gt;3[安装管理插件]</span><br><span class="line">3--&gt;4[创建用户]</span><br><span class="line">4--&gt;5[创建虚拟主机]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装过程中以管理员身份运行</p>
</blockquote>
</li>
</ul>
<h1 id="3-RabbitMQ入门"><a href="#3-RabbitMQ入门" class="headerlink" title="3.RabbitMQ入门"></a>3.RabbitMQ入门</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-1-生产者"><a href="#3-1-生产者" class="headerlink" title="3.1 生产者"></a>3.1 生产者</h2><p>生产者发送消息到RabbitMQ的队列（simple_queue）；消费者可以从队列中获取信息，可以使用简单模式（simple）。</p>
<ul>
<li><p>创建连接工厂(设置MQ的连接参数)</p>
</li>
<li><p>创建连接</p>
</li>
<li><p>创建频道</p>
</li>
<li><p>声明队列</p>
</li>
<li><p>发送消息</p>
</li>
<li><p>关闭资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *简单模式：发送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1创建连接工厂,ctrl+ait+v快速生成对象</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机默认localhost</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">//端口：默认5672</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//虚拟主机：默认/</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/hhzhu&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名，默认guest</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;shei&quot;</span>);</span><br><span class="line">        <span class="comment">//2创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//4声明队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：是否定义持久化</span></span><br><span class="line"><span class="comment">         * 参数3：是否独占本连接</span></span><br><span class="line"><span class="comment">         * 参数4：是否不用时自动删除</span></span><br><span class="line"><span class="comment">         * 参数5：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5发送消息</span></span><br><span class="line">        String message = <span class="string">&quot;你好，小兔纸。&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：交换机名称，空串使用迷人交换机</span></span><br><span class="line"><span class="comment">         * 参数2：路由key，简单模式中，可以使用队列名称</span></span><br><span class="line"><span class="comment">         * 参数3：消息其他属性</span></span><br><span class="line"><span class="comment">         * 参数4：消息内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;已发送消息：&quot;</span>+message);</span><br><span class="line">        <span class="comment">//6关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在设置连接工场的时候，不设置会有默认；</p>
</blockquote>
</li>
</ul>
<h2 id="3-2-消费者"><a href="#3-2-消费者" class="headerlink" title="3.2 消费者"></a>3.2 消费者</h2><p>从RabbitMQ中队列(与生产者发送消息的队列一致)接收消息。</p>
<ul>
<li><p>创建连接工厂的连接参数</p>
</li>
<li><p>创建连接(抽取一个获取连接的工具类)</p>
</li>
<li><p>创建频道</p>
</li>
<li><p>声明队列</p>
</li>
<li><p>创建消费者(接收消息并处理接收到的消息)</p>
</li>
<li><p>监听队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *使用简单模式，消费者接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(Producer.QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key为：&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                System.out.println(<span class="string">&quot;交换机为：&quot;</span>+envelope.getExchange());</span><br><span class="line">                <span class="comment">//消息ID</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消息ID为：&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                <span class="comment">//接收到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的消息为：&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名</span></span><br><span class="line"><span class="comment">         * 参数2：是否自动确认，设置true表示消息接收到自动向MQ回复接收到了，MQ将消息从队列删除，false则需要手动确认</span></span><br><span class="line"><span class="comment">         * 参数3：消息的消费者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(Producer.QUEUE_NAME,<span class="keyword">true</span>,defaultConsumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者持续监听队列消息，不需要关闭资源</p>
<p>如果消费者在听一个队列中有多个，消息如何分配？</p>
</blockquote>
</li>
</ul>
<h1 id="4-RabbitMQ工作模式"><a href="#4-RabbitMQ工作模式" class="headerlink" title="4.RabbitMQ工作模式"></a>4.RabbitMQ工作模式</h1><h2 id="4-1-Work-queue工作模式"><a href="#4-1-Work-queue工作模式" class="headerlink" title="4.1 Work queue工作模式"></a>4.1 Work queue工作模式</h2><p>与simple相比，多了一个或多个消费者，多个消费者共同消费同一个队列中的消息。(消费者之间对消息的接收是竞争关系)。一个消息只能被一个消费者接收。</p>
<p><strong>应用场景：</strong>可以在消费者端处理任务比较耗时的时候，添加对同一个队列的消费者来提高任务处理能力。</p>
<p>生产者：发送30个消息</p>
<p>消费者：创建2个消费者监听同一个队列，查看两个消费者接收消息是否存在重复。</p>
<ul>
<li><p>抽取连接工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *创建连接工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1创建连接工厂,ctrl+ait+v快速生成对象</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//主机默认localhost</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">//端口：默认5672</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//虚拟主机：默认/</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/hhzhu&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名，默认guest</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;shei&quot;</span>);</span><br><span class="line">        <span class="comment">//2创建连接</span></span><br><span class="line">        <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *work工作队列模式：发送消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//3创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//4声明队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：是否定义持久化</span></span><br><span class="line"><span class="comment">         * 参数3：是否独占本连接</span></span><br><span class="line"><span class="comment">         * 参数4：是否不用时自动删除</span></span><br><span class="line"><span class="comment">         * 参数5：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//5发送消息</span></span><br><span class="line">            String message = <span class="string">&quot;你好，小兔纸。work模式&quot;</span>+i ;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数1：交换机名称，空串使用迷人交换机</span></span><br><span class="line"><span class="comment">             * 参数2：路由key，简单模式中，可以使用队列名称</span></span><br><span class="line"><span class="comment">             * 参数3：消息其他属性</span></span><br><span class="line"><span class="comment">             * 参数4：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>消费者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *使用简单模式，消费者接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(Producer.QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//每次可以获取多少个信息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//路由key</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;路由key为：&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                    <span class="comment">//交换机</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;交换机为：&quot;</span>+envelope.getExchange());</span><br><span class="line">                    <span class="comment">//消息ID</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;消息ID为：&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                    <span class="comment">//接收到的消息</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者1---接收到的消息为：&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">//确认消息</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 参数1：消息ID</span></span><br><span class="line"><span class="comment">                     * 参数2：是否确认，false表示只有当前这个消息被处理。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名</span></span><br><span class="line"><span class="comment">         * 参数2：是否自动确认，设置true表示消息接收到自动向MQ回复接收到了，MQ将消息从队列删除，false则需要手动确认</span></span><br><span class="line"><span class="comment">         * 参数3：消息的消费者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(Producer.QUEUE_NAME,<span class="keyword">true</span>,defaultConsumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>消费者2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *使用简单模式，消费者接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(Producer.QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//每次可以获取多少个信息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//路由key</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;路由key为：&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                    <span class="comment">//交换机</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;交换机为：&quot;</span>+envelope.getExchange());</span><br><span class="line">                    <span class="comment">//消息ID</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;消息ID为：&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                    <span class="comment">//接收到的消息</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者2---接收到的消息为：&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">//确认消息</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 参数1：消息ID</span></span><br><span class="line"><span class="comment">                     * 参数2：是否确认，false表示只有当前这个消息被处理。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名</span></span><br><span class="line"><span class="comment">         * 参数2：是否自动确认，设置true表示消息接收到自动向MQ回复接收到了，MQ将消息从队列删除，false则需要手动确认</span></span><br><span class="line"><span class="comment">         * 参数3：消息的消费者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(Producer.QUEUE_NAME,<span class="keyword">true</span>,defaultConsumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-2-订阅模式"><a href="#4-2-订阅模式" class="headerlink" title="4.2 订阅模式"></a>4.2 订阅模式</h2><p>说出订阅模式中的Exchange交换机的作用和交换机的三种类型</p>
<p>前面两个案例，只有3个角色：生产者，消费者，消息队列</p>
<p>在订阅者模型，多了一个Exchange角色，过程略有变化：</p>
<ul>
<li>P：生产者，发送给exchange</li>
<li>C：消费者，一直等待消息的到来</li>
<li>Queue：接收消息，缓存消息</li>
<li>Exchange：交换机，接收P消息，知道如何处理消息，三种<ul>
<li>Fanout：广播，将消息交给所有的交换机队列(竞争)</li>
<li>Direct：定向，符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给routing patern的队列</li>
</ul>
</li>
</ul>
<p><strong>Exchange只负责转发消息，不具备存储能力</strong>，如果没有任何队列与exchange绑定，那么消息会丢失。</p>
<ul>
<li><p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *发布与订阅，生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机名称</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_EXCHANGE = <span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_QUEUE_1 = <span class="string">&quot;fanout_queue1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_QUEUE_2 = <span class="string">&quot;fanout_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//2创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：名称</span></span><br><span class="line"><span class="comment">         * 参数2：交换机类型(fanout,direct,topic)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(FANOUT_EXCHANGE, BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//4声明队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：是否定义持久化</span></span><br><span class="line"><span class="comment">         * 参数3：是否独占本连接</span></span><br><span class="line"><span class="comment">         * 参数4：是否不用时自动删除</span></span><br><span class="line"><span class="comment">         * 参数5：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(FANOUT_QUEUE_1,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(FANOUT_QUEUE_2,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5队列绑定到交换机</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：交换机名称</span></span><br><span class="line"><span class="comment">         * 参数3：路由key，这里没用到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(FANOUT_QUEUE_1,FANOUT_EXCHANGE,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.queueBind(FANOUT_QUEUE_2,FANOUT_EXCHANGE,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//5发送消息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;你好，小兔纸。发布与订阅---&quot;</span>+i;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数1：交换机名称，空串使用迷人交换机</span></span><br><span class="line"><span class="comment">             * 参数2：路由key，简单模式中，可以使用队列名称</span></span><br><span class="line"><span class="comment">             * 参数3：消息其他属性</span></span><br><span class="line"><span class="comment">             * 参数4：消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(FANOUT_EXCHANGE, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>消费者</strong>1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *使用发布与订阅模式，消费者接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//2创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(Producer.FANOUT_EXCHANGE,BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//4声明队列</span></span><br><span class="line">        channel.queueDeclare(Producer.FANOUT_QUEUE_1,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5队列绑定到交换机上</span></span><br><span class="line">        channel.queueBind(Producer.FANOUT_QUEUE_1,Producer.FANOUT_EXCHANGE,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//6创建消费者</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key为：&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                System.out.println(<span class="string">&quot;交换机为：&quot;</span>+envelope.getExchange());</span><br><span class="line">                <span class="comment">//消息ID</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消息ID为：&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                <span class="comment">//接收到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1接收到的消息为：&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名</span></span><br><span class="line"><span class="comment">         * 参数2：是否自动确认，设置true表示消息接收到自动向MQ回复接收到了，MQ将消息从队列删除，false则需要手动确认</span></span><br><span class="line"><span class="comment">         * 参数3：消息的消费者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(Producer.FANOUT_QUEUE_1,<span class="keyword">true</span>,defaultConsumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>消费者2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hhzhu.ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hhzhu.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *使用发布与订阅模式，消费者接收消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhuHh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> Create on 2020/3/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//2创建频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(Producer.FANOUT_EXCHANGE,BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//4声明队列</span></span><br><span class="line">        channel.queueDeclare(Producer.FANOUT_QUEUE_2,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5队列绑定到交换机上</span></span><br><span class="line">        channel.queueBind(Producer.FANOUT_QUEUE_2,Producer.FANOUT_EXCHANGE,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//6创建消费者</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//路由key</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key为：&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                System.out.println(<span class="string">&quot;交换机为：&quot;</span>+envelope.getExchange());</span><br><span class="line">                <span class="comment">//消息ID</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消息ID为：&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">                <span class="comment">//接收到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2接收到的消息为：&quot;</span>+<span class="keyword">new</span> String(body,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名</span></span><br><span class="line"><span class="comment">         * 参数2：是否自动确认，设置true表示消息接收到自动向MQ回复接收到了，MQ将消息从队列删除，false则需要手动确认</span></span><br><span class="line"><span class="comment">         * 参数3：消息的消费者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(Producer.FANOUT_QUEUE_2,<span class="keyword">true</span>,defaultConsumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础</title>
    <url>/2020/03/22/Vue%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>前导知识：html，css，js，ajax</p>
</blockquote>
<h1 id="Vue入门"><a href="#Vue入门" class="headerlink" title="Vue入门"></a>Vue入门</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>1、js框架</p>
<p>2、简化DOM操作</p>
<p>3、响应式数据驱动</p>
<h2 id="2-第一个vue程序"><a href="#2-第一个vue程序" class="headerlink" title="2.第一个vue程序"></a>2.第一个vue程序</h2><p><a href="https://cn.vuejs.org/">官网文档</a></p>
<p>在html文件中导入生产环境版本的包</p>
<ul>
<li>导入开发版本Vue.js</li>
<li>创建Vue实例对象，设置el属性和data属性</li>
<li>使用简单的模板语法把数据渲染到页面上</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue基础<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&quot;Hello Vue!&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐使用id选择器，开发时唯一。支持双标签。可以使用其他双标签，不能使用html和body</p>
</blockquote>
<p>data：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>data数据对象<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;school&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;school.name&#125;&#125; &#123;&#123;school.address&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;campus&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;campus.[0]&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;campus.[1]&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&quot;你好小黑&quot;</span>,</span></span><br><span class="line">            school:&#123;</span><br><span class="line"><span class="javascript">                name:<span class="string">&quot;小黑&quot;</span>,</span></span><br><span class="line"><span class="javascript">                mobile:<span class="string">&quot;15736734&quot;</span>,</span></span><br><span class="line"><span class="javascript">                address:<span class="string">&quot;上海市普陀区&quot;</span>,</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            campus:[<span class="string">&quot;北京社区&quot;</span>,<span class="string">&quot;上海社区&quot;</span>],</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="本地应用"><a href="#本地应用" class="headerlink" title="本地应用"></a>本地应用</h1><ul>
<li>内容绑定，事件绑定<ul>
<li>v-text</li>
<li>v-html</li>
<li>v-on</li>
</ul>
</li>
<li>显示切换，属性绑定<ul>
<li>v-show</li>
<li>v-if</li>
<li>v-bind</li>
</ul>
</li>
<li>列表循环，表单元绑定<ul>
<li>v-for</li>
<li>v-on补充</li>
<li>v-model</li>
</ul>
</li>
</ul>
<h2 id="1-v-text"><a href="#1-v-text" class="headerlink" title="1.v-text"></a>1.v-text</h2><ul>
<li>设置标签的内容</li>
<li>默认全部替换，部分替换使用差值表达式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-text<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span> = <span class="string">&quot;message+&#x27;!&#x27;&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span> = <span class="string">&quot;info&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--部分替换--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;深圳<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&quot;二狗&quot;</span>,</span></span><br><span class="line"><span class="javascript">            info:<span class="string">&quot;我也不知道要干嘛&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-v-html"><a href="#2-v-html" class="headerlink" title="2.v-html"></a>2.v-html</h2><ul>
<li>设置元素的innerHTML</li>
<li>内容中有html结构会被解析为标签</li>
<li>v-text只会解析成文本</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span> = <span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span> = <span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//content:&quot;你好呀小黑&quot;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            content:&quot;<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://victor-huihui.gitee.io&#x27;</span>&gt;</span>Blog Victor<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-v-on"><a href="#3-v-on" class="headerlink" title="3.v-on"></a>3.v-on</h2><ul>
<li>为元素绑定事件</li>
<li>事件名不需要写on</li>
<li>指令简写为@</li>
<li>绑定的方法定义在mrthods属性中</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-on</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-on<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v-on指令&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doIt&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v-on简写&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;doIt&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;双击事件&quot;</span> @<span class="attr">dblclick</span> = <span class="string">&quot;doIt&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> @<span class="attr">click</span>=<span class="string">&quot;changeFood&quot;</span>&gt;</span>&#123;&#123; food &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            food:<span class="string">&quot;海底捞很好7&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            doIt:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;您配吗&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        changeFood:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.food+=<span class="string">&quot;，那您多吃点8&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-计数器"><a href="#4-计数器" class="headerlink" title="4.计数器"></a>4.计数器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-on</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>计数器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-num&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sub&quot;</span>&gt;</span></span><br><span class="line">                -</span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">                +</span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.itheima.com/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            num:1</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            add:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(<span class="built_in">this</span>.num&lt;<span class="number">10</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.num++;</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;不能再加了&quot;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            sub:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(<span class="built_in">this</span>.num&gt;<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.num--;</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;不能再减了啊！&quot;</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-v-show"><a href="#5-v-show" class="headerlink" title="5.v-show"></a>5.v-show</h2><ul>
<li>修改元素的显示状态</li>
<li>原理是修改display实现显示隐藏</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-on</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-show<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;切换显示状态&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeIsShow&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;累加年龄&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;addAge&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./1183257.png&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">&quot;age&gt;=18&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./1183257.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            isShow:<span class="literal">false</span>,</span></span><br><span class="line">            age:17</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            changeIsShow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.isShow = !<span class="built_in">this</span>.isShow;</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            addAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.age++;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-v-if"><a href="#6-v-if" class="headerlink" title="6.v-if"></a>6.v-if</h2><ul>
<li>根据表达式真假切换显示状态</li>
<li>本质操纵DOM元素切换</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-if<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击显示&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;toggleIsShow&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>王二狗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>王三狗 v-show修饰<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;temperature&gt;=35&quot;</span>&gt;</span>热死了<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            isShow:<span class="literal">false</span>,</span></span><br><span class="line">            temperature:20</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            toggleIsShow:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.isShow=!<span class="built_in">this</span>.isShow;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-v-bind"><a href="#7-v-bind" class="headerlink" title="7.v-bind"></a>7.v-bind</h2><ul>
<li>为元素绑定属性</li>
<li>完整写法：v-bind:属性名</li>
<li>简写只保留  ：属性名</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-bind<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .active&#123;</span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid cornflowerblue;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgSrc&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;太帅无法显示&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span> = <span class="string">&quot;imgSrc&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;imgTitle+&#x27;!!!&#x27;&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;isActive?active:&#x27;&#x27;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;toggleActive&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span> = <span class="string">&quot;imgSrc&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;imgTitle&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:isActive&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;toggleActive&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            imgSrc:<span class="string">&quot;http://www.itheima.com/images/logo.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">            imgTitle:<span class="string">&quot;小黑本人&quot;</span>,</span></span><br><span class="line"><span class="javascript">            isActive:<span class="literal">false</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            toggleActive:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.isActive=!<span class="built_in">this</span>.isActive;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-v-for"><a href="#8-v-for" class="headerlink" title="8.v-for"></a>8.v-for</h2><ul>
<li>根据数据生成列表结构</li>
<li>数组和v-for结合</li>
<li>(item,index) in 数据</li>
<li></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-for<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in arr&quot;</span>&gt;</span>&#123;&#123;index+1&#125;&#125;item:&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-for</span>=<span class="string">&quot;item in vegetables&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            arr:[<span class="string">&quot;普陀区&quot;</span>,<span class="string">&quot;静安区&quot;</span>,<span class="string">&quot;宝山区&quot;</span>],</span></span><br><span class="line">            vegetables:[</span><br><span class="line">                &#123;name:西蓝花&#125;,</span><br><span class="line">                &#123;name:茄子&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-v-on补充"><a href="#9-v-on补充" class="headerlink" title="9.v-on补充"></a>9.v-on补充</h2><ul>
<li>事件绑定写成函数调用的形式，可以传入自定义参数</li>
<li>定义方法时定义形参接收传入的参数</li>
<li>时间后面跟上.修饰符可以对时间进行限制</li>
<li>.enter为回车</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-on补充<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;别点啊&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;doIt(666,&#x27;老铁&#x27;)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  @<span class="attr">keyup.enter</span>=<span class="string">&quot;sayHi&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            doIt:<span class="function"><span class="keyword">function</span> (<span class="params">p1,p2</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;别学IT啊兄弟&quot;</span>);</span></span><br><span class="line">                alert(p1+p2);</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            sayHi:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;吃了没啊&quot;</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-v-model"><a href="#10-v-model" class="headerlink" title="10.v-model"></a>10.v-model</h2><ul>
<li>便捷设置和获取表单元素的值</li>
<li>绑定的数据和表单元素关联</li>
<li>双向绑定</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-model<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改message&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;setM&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;getM&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> &gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&quot;小黑大骗子&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            getM:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="built_in">this</span>.message)</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            setM:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.message=<span class="string">&quot;小黑有好人卡&quot;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a>网络应用</h1><ul>
<li>axios：网络请求库</li>
<li>axios+vue：结合vue一起</li>
<li>天气预报案例</li>
</ul>
<h2 id="1-axios基本使用"><a href="#1-axios基本使用" class="headerlink" title="1.axios基本使用"></a>1.axios基本使用</h2><ul>
<li>先导入再使用</li>
<li>get或者set发送请求</li>
<li>then方法中的回调函数会再请求失败会成功的时候触发</li>
<li>通过回调函数获得相应内容或者错误信息</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">axios.get(地址?key=value&amp;key2=value2).then(function(response)&#123;&#125;,function(err)&#123;&#125;)</span><br><span class="line"></span><br><span class="line">axios.post(地址,key:value&amp;key2:value2).then(function(response)&#123;&#125;,function(err)&#123;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=chrome&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>axios基本使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;get请求&quot;</span> <span class="attr">class</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;post请求&quot;</span> <span class="attr">class</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 接口1：随机笑话</span><br><span class="line"><span class="javascript">     * URL：https:<span class="comment">//autumnfish.cn/api/joke/list</span></span></span><br><span class="line">     * 方法：get</span><br><span class="line">     * 参数：num(笑话条数，字数)</span><br><span class="line">     * 相应内容：随机笑话</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&quot;.get&quot;</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        axios.get(<span class="string">&quot;https://autumnfish.cn/api/joke/list?num=3&quot;</span>)</span></span><br><span class="line"><span class="javascript">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(response);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 接口2：用户注册</span><br><span class="line"><span class="javascript">     * URL：https:<span class="comment">//autumnfish.cn/api/user/reg</span></span></span><br><span class="line">     * post</span><br><span class="line">     * username(用户名，字符串)</span><br><span class="line">     * 注册成功或者失败</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&quot;.post&quot;</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        axios.post(<span class="string">&quot;https://autumnfish.cn/api/user/reg123&quot;</span>,&#123;<span class="attr">username</span>:<span class="string">&quot;hhzhu&quot;</span>&#125;)</span></span><br><span class="line"><span class="javascript">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(err);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-axios-vue"><a href="#2-axios-vue" class="headerlink" title="2.axios+vue"></a>2.axios+vue</h2><ul>
<li>axios回调函数的this已经改变，无法访问到data中的数据</li>
<li>把this保存起来，回调函数直接使用保存的this</li>
<li>和本地的区别是改变了数据来源</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=chrome&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>axios+vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取笑话&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;getJoke&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; joke &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 接口1：随机笑话</span><br><span class="line"><span class="javascript">     * URL：https:<span class="comment">//autumnfish.cn/api/joke</span></span></span><br><span class="line">     * 方法：get</span><br><span class="line">     * 参数：无</span><br><span class="line">     * 相应内容：随机笑话</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            joke:<span class="string">&quot;很好笑的笑话&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            getJoke:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//console.log(this.joke);</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> that=<span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">                axios.get(<span class="string">&quot;https://autumnfish.cn/api/joke&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(response.data);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//console.log(this.joke);</span></span></span><br><span class="line">                    that.joke=response.data;</span><br><span class="line"><span class="javascript">                &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-网络应用：天知道"><a href="#3-网络应用：天知道" class="headerlink" title="3.网络应用：天知道"></a>3.网络应用：天知道</h2><blockquote>
<p>回车查询，点击查询</p>
</blockquote>
<p><strong>回车查询：</strong></p>
<ul>
<li>按下回车(v-on.enter)</li>
<li>查询数据(axios,v-model)</li>
<li>渲染数据(c-for，that)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=chrome&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>axios+vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search_form&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/03/22/oZx5cQ1BS2CmdTz.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_group&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;city&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;searchWeather&quot;</span> <span class="attr">class</span>=<span class="string">&quot;input_txt&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入查询的天气&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;input_sub&quot;</span>&gt;</span></span><br><span class="line">                    搜索</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hotkey&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;weather_list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in weatherList&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info_type&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span>&#123;&#123;item.type&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info_temp&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123;item.low&#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">                    ~</span><br><span class="line">                    <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123;item.high&#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info_date&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">天气接口：</span></span><br><span class="line"><span class="comment">请求地址：http://wthrcdn.etouch.cn/weather_mini</span></span><br><span class="line"><span class="comment">参数：city</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        city:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        weatherList:[],</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        searchWeather:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//console.log(&quot;天气查询&quot;);</span></span><br><span class="line">            <span class="comment">//console.log(this.city);</span></span><br><span class="line">            <span class="comment">//调用接口</span></span><br><span class="line">            <span class="comment">//保存this</span></span><br><span class="line">            <span class="keyword">var</span> that=<span class="built_in">this</span></span><br><span class="line">            axios.get(<span class="string">&quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot;</span>+<span class="built_in">this</span>.city)</span><br><span class="line">                .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//console.log(response);</span></span><br><span class="line">                    <span class="comment">//console.log(response.data.data.forecast);</span></span><br><span class="line">                    that.weatherList=response.data.data.forecast;</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>点击查询：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">changeCity:<span class="function"><span class="keyword">function</span> (<span class="params">city</span>) </span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.city=city;</span><br><span class="line">           <span class="built_in">this</span>.searchWeather();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hotkey&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> @<span class="attr">onclick</span>=<span class="string">&quot;changeCity(&#x27;北京&#x27;)&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> @<span class="attr">onclick</span>=<span class="string">&quot;changeCity(&#x27;上海&#x27;)&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> @<span class="attr">onclick</span>=<span class="string">&quot;changeCity(&#x27;广州&#x27;)&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> @<span class="attr">onclick</span>=<span class="string">&quot;changeCity(&#x27;深圳&#x27;)&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2021/04/11/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h1 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1.二维数组中的查找"></a>1.二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>示例：<br>矩阵：[<br>[1,   4,  7, 11, 15],<br>[2,   5,  8, 12, 19],<br>[3,   6,  9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br>给定target = 5，返回true<br>给定20，返回false</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题可以从左下角或者从右上角开始游走，重要的是数组要判空，不然可能会出现数组越界的问题。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//二维数组判空</span></span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||(matrix.length==<span class="number">1</span>&amp;&amp;matrix[<span class="number">0</span>].length==<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">int</span> left = row-<span class="number">1</span>;<span class="comment">//行</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;<span class="comment">//列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row+col;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[left][right]&gt;target)&#123;</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">if</span>(left==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[left][right]&lt;target)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span>(right==col)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-数组中的重复数字"><a href="#2-数组中的重复数字" class="headerlink" title="2.数组中的重复数字"></a>2.数组中的重复数字</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span>或<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始的思路是先用快排对数组进行排序，然后遍历数组，但是排序超时。<br>这时候可以选择用java中的set解题，在往set中添加元素的时候，添加成功返回true，说明不重复，反之说明重复。</p>
<p>第二遍做的时候，第一个想法是用哈希。代码也写上。4-11</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序超时</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.add(nums[i]) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duplicate</span> <span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[numbers.length+<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//java中的数组默认都是0，所以哈希不用再考虑初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">        hash[numbers[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(hash[numbers[i]]&gt;<span class="number">1</span>)<span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<blockquote>
<p>示例1：</p>
<p>输入：head= [1,2,3]</p>
<p>输出：[2,3,1]</p>
</blockquote>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题可以先获取链表的长度，然后处理，这里为了熟悉栈的使用，使用压栈和出栈的方式解题。</p>
<p>利用栈的FILO特性</p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] print = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            print[i] = stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-替换空格"><a href="#4-替换空格" class="headerlink" title="4.替换空格"></a>4.替换空格</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<blockquote>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接调用s.replaceAlll()即可</p>
<h2 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><figcaption><span>java</span></figcaption><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">        public String replaceSpace(String s) &#123;</span><br><span class="line">        String newStr &#x3D; s.replaceAll(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">        return newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-两个栈实现队列"><a href="#5-两个栈实现队列" class="headerlink" title="5.两个栈实现队列"></a>5.两个栈实现队列</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>stack1作为push队列，pop时，如果stack2是空，将stack1复制到2，然后出栈顶，stack2不空时直接出栈。</p>
<h2 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2不空，直接出栈，空的时候复制再出栈</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//复制出栈</span></span><br><span class="line">                <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                    stack2.push(stack1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>求Fibonacci数列的第n项</p>
<blockquote>
<p>F(0)=0,F(1) =1</p>
<p>F(N) = F(N-1)+F(N-2)</p>
</blockquote>
<p>答案取模1e9+7。</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接递归超时，变成加法，存储前两个的状态。</p>
<h2 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (a+b)%<span class="number">1000000007</span>;</span><br><span class="line">            a=b;</span><br><span class="line">            b=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-青蛙跳台阶问题"><a href="#6-青蛙跳台阶问题" class="headerlink" title="6.青蛙跳台阶问题"></a>6.青蛙跳台阶问题</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>快乐的一只小青蛙，瓜瓜呱呱呱呱呱。一次可以跳一次台阶，也可以跳两层，问这个小青蛙跳n层台阶有多少种跳法。</p>
<blockquote>
<p>0&lt;=n&lt;=100</p>
</blockquote>
<p>对照上一题，是两种解决斐波那契的方法。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划问题。假设n级台阶的跳法为f(n)，则：</p>
<ul>
<li>第一次跳1级，还有f(n-1)种跳法</li>
<li>第一次跳2级，还有f(n-2)种跳法</li>
</ul>
<p>所以$f(n) = f(n-1)+f(n-2)$</p>
<h2 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || i==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-变态青蛙跳台阶"><a href="#7-变态青蛙跳台阶" class="headerlink" title="7.变态青蛙跳台阶"></a>7.变态青蛙跳台阶</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设跳到n有f(n)种跳法，则:</p>
<p>$f(n) = f(n-1)+f(n-2)+…+f(1)$</p>
<p>$f(n-1) = f(n-2)+f(n-3)+…+f(1)$</p>
<p>两个式子相减得到：$f(n) = 2f(n-1)$，然后就可以dp了。</p>
<h2 id="code-7"><a href="#code-7" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//通过递推可以得到f(n) = 2f(n-1)</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">2</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="8-旋转数组中的最小数字"><a href="#8-旋转数组中的最小数字" class="headerlink" title="8.旋转数组中的最小数字"></a>8.旋转数组中的最小数字</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组开始的几个元素搬到末尾，称为数组旋转，给出一个递增的数组的旋转，输出旋转数组中的最小元素。</p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题本质上是二分查找，实际上，暴力查找也过了的。</p>
<h2 id="code-8"><a href="#code-8" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&lt;min)&#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-合并两个排序的链表"><a href="#9-合并两个排序的链表" class="headerlink" title="9.合并两个排序的链表"></a>9.合并两个排序的链表</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，合并之后满足单调不递减。</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是基本得链表操作。</p>
<h2 id="code-9"><a href="#code-9" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode current = newHead;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                current.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="keyword">null</span>) current.next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="keyword">null</span>) current.next = list2;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-数组中出现次数超过一半的数字"><a href="#10-数组中出现次数超过一半的数字" class="headerlink" title="10.数组中出现次数超过一半的数字"></a>10.数组中出现次数超过一半的数字</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>话不多说，就是hash</p>
<h2 id="code-10"><a href="#code-10" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> all = array.length;</span><br><span class="line">        <span class="keyword">int</span> half = all/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> test = Arrays.stream(array).max().getAsInt();</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[test+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;hash.length;i++)&#123;</span><br><span class="line">            hash[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[array[i]]==-<span class="number">1</span>)&#123;</span><br><span class="line">                hash[array[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hash[array[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[array[i]]&gt;=half)&#123;</span><br><span class="line">                <span class="keyword">return</span> array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-连续子数组的最大和"><a href="#11-连续子数组的最大和" class="headerlink" title="11.连续子数组的最大和"></a>11.连续子数组的最大和</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入的数组为&#123;1,-2,3,10,—4,7,2,一5&#125;，和最大的子数组为&#123;3,10,一4,7,2&#125;，因此输出为该子数组的和 18。 </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>看题目意思，再看时间复杂度，这题一定是DP没跑了。</p>
<p>状态转义方程是$dp[n] = max{dp[n-1]+arr[n],arr[n]}$</p>
<p>$dp[0] = arr[0]$</p>
<h2 id="code-11"><a href="#code-11" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(FindGreatestSumOfSubArray(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>]+array[i],array[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max)max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-第一个只出现一次的字符"><a href="#12-第一个只出现一次的字符" class="headerlink" title="12.第一个只出现一次的字符"></a>12.第一个只出现一次的字符</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>本质上也是哈希，我这里用map统计，然后再遍历一遍就好了。</p>
<h2 id="code-12"><a href="#code-12" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">char</span>[] st = str.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//统计每个字符出现的次数。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;st.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(st[i])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(st[i],<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = map.get(st[i]);</span><br><span class="line">                map.put(st[i],++index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;st.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(st[i])==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-二叉树的深度"><a href="#13-二叉树的深度" class="headerlink" title="13.二叉树的深度"></a>13.二叉树的深度</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入二叉树，求树的深度。从根节点到叶节点经过的节点（含根，叶节点）形成树的路径，最长路径的长度为树的深度。</p>
<h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><p>关于树的题目，基本都是套用遍历的模板。或者是层次遍历。</p>
<h2 id="code-13"><a href="#code-13" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> lh,rh;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            lh = TreeDepth(root.left);</span><br><span class="line">            rh = TreeDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+(lh&gt;rh?lh:rh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-平衡二叉树"><a href="#14-平衡二叉树" class="headerlink" title="14.平衡二叉树"></a>14.平衡二叉树</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个二叉树，判断二叉树是不是平衡二叉树</p>
<h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><p>分别求左子树和右子树的高度，然后求差。树的递归思想</p>
<h2 id="code-14"><a href="#code-14" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = depth(root);</span><br><span class="line">        <span class="keyword">if</span>(res==-<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//返回-1表示不是平二二叉树；</span></span><br><span class="line">        <span class="keyword">if</span>(left-right&lt;-<span class="number">1</span> || left-right&gt;<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+(left&gt;right?left:right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-不用加减乘除做加法"><a href="#15-不用加减乘除做加法" class="headerlink" title="15.不用加减乘除做加法"></a>15.不用加减乘除做加法</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，函数内不能使用四则运算</p>
<h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><p>没有加减乘除，那就只能位运算了啊。位运算一般是有规律的，那先找一下规律啊，来计算$2+3$</p>
<blockquote>
<p>0010</p>
<p>0011</p>
<p><strong>0101</strong></p>
</blockquote>
<p>不考虑进位的加法可以直接采用异或操作，进位可以用与运算表示。进位用移位表示。</p>
<ul>
<li>x^y：执行加法</li>
<li>(x&amp;y)&lt;&lt;1：执行进位操作。</li>
</ul>
<h2 id="code-15"><a href="#code-15" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num2!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//不进位的加法</span></span><br><span class="line">            <span class="keyword">int</span> temp = num1^num2;</span><br><span class="line">            <span class="comment">//进位</span></span><br><span class="line">            num2 = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-构造乘积数组"><a href="#16-构造乘积数组" class="headerlink" title="16.构造乘积数组"></a>16.构造乘积数组</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p>
<p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<blockquote>
<p>输入：[1,2,3,4,5]</p>
<p>输出：[120,60,40,30,24]</p>
</blockquote>
<h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><p>不能用除法，那我直接模拟了。</p>
<h2 id="code-16"><a href="#code-16" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="comment">//问题在于不能用除法，复杂性会比较高</span></span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            B[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i)<span class="keyword">continue</span>;</span><br><span class="line">                B[i]*=A[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-二叉搜索树的第K个节点"><a href="#17-二叉搜索树的第K个节点" class="headerlink" title="17.二叉搜索树的第K个节点"></a>17.二叉搜索树的第K个节点</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的TreeNode结点。</p>
<h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><p>二叉搜索树，中序遍历是递增的。</p>
<h2 id="code-17"><a href="#code-17" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//既然是二叉搜索树了，那终须遍历就是递增的序列。那就先终须遍历，存数组</span></span><br><span class="line">        List&lt;TreeNode&gt; val = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        val = Z(pRoot);</span><br><span class="line">        <span class="comment">//得到的val数组是递增序列</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;=<span class="number">1</span> &amp;&amp; val.size()&gt;=k)&#123;</span><br><span class="line">            <span class="keyword">return</span> val.get(k-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">Z</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Z(pRoot.left);</span><br><span class="line">            <span class="comment">//村数组</span></span><br><span class="line">            res.add(pRoot);</span><br><span class="line">            Z(pRoot.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="—-下面是中等难度的题目—"><a href="#—-下面是中等难度的题目—" class="headerlink" title="—-下面是中等难度的题目—-"></a>—-下面是中等难度的题目—-</h1><hr>
<h1 id="18-二进制中1的个数"><a href="#18-二进制中1的个数" class="headerlink" title="18.二进制中1的个数"></a>18.二进制中1的个数</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2><p>就移位运算呗。当然也可以更简单。</p>
<p>String s = Integer.toBinaryString(n);会将整数编程一个二进制的字符串</p>
<h2 id="code-18"><a href="#code-18" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = Integer.toBinaryString(n);</span><br><span class="line">        String[] split = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;split.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(split[i].endsWith(<span class="string">&quot;1&quot;</span>))a+;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="19-链表中倒数第K个节点"><a href="#19-链表中倒数第K个节点" class="headerlink" title="19.链表中倒数第K个节点"></a>19.链表中倒数第K个节点</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>如果该链表长度小于k，请返回空。</p>
<h2 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h2><p>看题解都是用的双指针，我这里用的是栈的方法。</p>
<h2 id="code-19"><a href="#code-19" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">            ListNode tmp = pHead;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(tmp);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.size()&lt;k)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        tmp = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="20-反转链表"><a href="#20-反转链表" class="headerlink" title="20.反转链表"></a>20.反转链表</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入链表，反转链表后，输出新链表的表头。</p>
<h2 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里借用leetcode中的视频</p>
<h2 id="code-20"><a href="#code-20" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>,cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="21-矩形覆盖"><a href="#21-矩形覆盖" class="headerlink" title="21.矩形覆盖"></a>21.矩形覆盖</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。用n个2*1的小巨星无重叠的覆盖一个2*n的大矩形，有多少种方法。</p>
<h2 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划。</p>
<h2 id="code-21"><a href="#code-21" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">if</span>(targer == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">2</span>]+dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="22-数值的整数次方"><a href="#22-数值的整数次方" class="headerlink" title="22.数值的整数次方"></a>22.数值的整数次方</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和ex不同时为0，不使用函数库，不考虑大数问题。、</p>
<h2 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是一个简单的数学题吧</p>
<h2 id="code-22"><a href="#code-22" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> res = base;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Math.abs(exponent)-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        res = res*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) <span class="number">1.0000</span>/res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="23-栈的压入、弹出序列"><a href="#23-栈的压入、弹出序列" class="headerlink" title="23.栈的压入、弹出序列"></a>23.栈的压入、弹出序列</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，判断第二个序列是否可能是弹出序列。假设入栈的数字不相等。</p>
<h2 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里是模拟的。代码及其垃圾。</p>
<h2 id="code-23"><a href="#code-23" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Arrays.stream(pushA).sum()!= Arrays.stream(popA).sum())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//记录当前进栈的元素下标</span></span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;popA.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> out = popA[i];</span><br><span class="line">        <span class="comment">//元素在栈中，出栈。这里的逻辑没毛病。</span></span><br><span class="line">        <span class="keyword">if</span>(stack1.contains(out))&#123;</span><br><span class="line">            <span class="keyword">int</span> index = stack1.pop();</span><br><span class="line">            <span class="keyword">if</span>(index!=out)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//进栈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = test;j&lt;pushA.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pushA[j]!=out)&#123;</span><br><span class="line">                    stack1.push(pushA[j]);</span><br><span class="line">                    test++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    test++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="24-二叉搜索树与双向链表"><a href="#24-二叉搜索树与双向链表" class="headerlink" title="24.二叉搜索树与双向链表"></a>24.二叉搜索树与双向链表</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h2 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="code-24"><a href="#code-24" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/03/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、线程和进程"><a href="#一、线程和进程" class="headerlink" title="一、线程和进程"></a>一、线程和进程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h2><p>程序的一次执行过程，是系统运行运行程序的基本单位。系统运行一个程序从一个进程创建，运行到消亡的过程。在java中，启动main函数就启动了一个JVM进程，main函数所在的线程是进程中的一个线程，也称为主线程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h2><p>与进程相似，但是比进程更小。一个进程多个线程。多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器，虚拟机栈与本地方法栈。线程之间切换负担比较小，因此线程被称为轻量级进程。</p>
<p>一个Java程序的运行是main线程和多个其他线程同时运行。</p>
<h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a><strong>线程和进程的关系</strong></h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%202%20%E9%A1%B5.png" alt="java虚拟机-第 2 页"></p>
<p>再把JVM的这张图拿出来， 一个进程中有多个线程，线程之间共享进程的堆和方法区，但是对于每个线程，都有自己的虚拟机栈，程序计数器，本地方法栈。</p>
<ul>
<li><p>程序计数器为什么私有？</p>
<p>程序计数器的作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来以此读取指令，从而实现代码的流程控制。</li>
<li>多线程时，程序计数器记录当前线程的执行位置，从而当线程被切换回来的时候知道线程上次运行到哪里了。</li>
</ul>
<p>如果执行的是native方法， 程序计数器记录的是undefined地址，执行java代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以程序计数器是私有是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
</li>
<li><p>虚拟机栈和本地方法栈为什么私有？</p>
<ul>
<li>stack：JVM启动时，分配独立的运行时栈，保存方法调用，每次调用入栈。栈保存了三个引用：本地变量表，操作数帧和当前方法所属类的运行时常量池。</li>
<li>native method stack：本地方法栈和虚拟机栈的作用相似，虚拟机执行的是字节码，本地方法栈执行的是native方法。本地方法栈使用传统的栈来支持native方法。</li>
</ul>
<p>所以为了保存内存中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>
</li>
</ul>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<blockquote>
<p>并发和并行？</p>
<ul>
<li>并发：同一时段内，多个任务都在执行。</li>
<li>并行：单位时间内，多个任务同时执行。</li>
</ul>
</blockquote>
<h2 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h2><ul>
<li>计算机底层：轻量级的进程，切换的调度的成本远远低于进程。另外多核CPU时代意味着多个线程可以同时运行，减少了线程上下文切换的开销。</li>
<li>趋势：百万级别的并发量，高并发系统的基础。</li>
</ul>
<p><strong>多线程可能带来的问题：</strong></p>
<p>但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏</strong>、<strong>上下文切换</strong>、<strong>死锁</strong> 。</p>
<h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p>6种状态：</p>
<ul>
<li>NEW：初始状态，线程被构建，但是还没有调用start方法</li>
<li>RUNNABLE：运行状态，java线程将被OS的就绪和运行两种状态笼统的称为“运行中”。</li>
<li>BLOCKED：阻塞状态</li>
<li>WAITING：等待状态，当前线程需要等待其他线程做出一些动作，如通知或者中断。</li>
<li>TIME_WAITING：超时等待状态，不同于上一个，可以在指定时间自行返回。</li>
<li>TERMINATED：终止状态，线程执行完毕。</li>
</ul>
<p>OS隐藏JVM中的RUNNABLE和RUNING状态，只看到RUNNABLE状态，将两个状态统称为RUNNABLE运行中。</p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>当前任务在执行完CPU时间片切换到另一个任务之前先保存自己的状态。任务从保存到加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。需要可观的处理器时间，在每秒上百次的切换中，每次都需要纳秒级别的时间。消耗大量的CPU时间，可能是OS时间消耗最大的操作。</p>
<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>A有资源1，B有资源2。同时想申请对方的资源，相互等待进入死锁状态。</p>
<p><strong>死锁产生的四个条件：</strong></p>
<ul>
<li>1互斥条件：资源任意时刻只能由一个线程占用。</li>
<li>2请求与保持：一个进程因请求资源阻塞时，对已获得的资源保持不放。</li>
<li>3不剥夺条件：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>4循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p><strong>如何避免线程死锁？</strong></p>
<p>破坏四个条件中的一个条件即可。</p>
<ul>
<li>破坏1：没办法，锁本来就是让他们互斥。</li>
<li>破坏2：一次申请所有资源</li>
<li>3：占用资源的线程进一步申请资源时，申请不到可以主动释放自己的资源。</li>
<li>4：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ul>
<h2 id="Sleep和wait区别"><a href="#Sleep和wait区别" class="headerlink" title="Sleep和wait区别"></a>Sleep和wait区别</h2><ul>
<li>sleep方法没有释放锁，wait方法释放了锁</li>
<li>都可以暂停线程的执行</li>
<li>wait通常被用于线程间交互，sleep用于暂停执行。</li>
<li>wait不会自动苏醒，需要被其他激活。sleep会自动苏醒，wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<p><strong>start会执行run方法，为什么不直接调用run？</strong></p>
<p>new一个thread，调用start方法， 会启动一个线程并使线程进入就绪状态，分配到时间片就可以开始运行。start会执行线程的响应准备工作，然后自动执行run方法的内容，这是真正的多线程工作。直接执行run，会当成一个main线程下的普通方法执行，并不会在某个线程中执行，所以并不是多线程工作。</p>
<h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><p>目前锁有四种状态：无锁，偏向锁，轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<ul>
<li><p>偏向锁</p>
<p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁是为了在只有一个线程执行同步块式提高性能。</p>
<p><img src="https://hadyang.github.io/interview/docs/java/concurrent/synchronized/assists/biased_lock.svg"></p>
</li>
<li><p>轻量级锁</p>
<p><img src="https://hadyang.github.io/interview/docs/java/concurrent/synchronized/assists/light_lock.svg"></p>
<p>几个重要步骤：</p>
<ul>
<li>复制 Mark Word 到锁记录：拷贝对象头中的 Mark Word 到锁记录中。</li>
<li>更新 Mark Word 指针：拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。</li>
</ul>
</li>
<li><p>重量级锁</p>
<p>在重量级锁的状态下， JVM 基于进入和退出 <code>Monitor</code> 对象来实现方法同步和代码块同步，<code>Monitor</code> 的引用存储在对象头中。</p>
<p><code>Monitor</code> 本身是依赖与操作系统的互斥锁（mutex lock）实现的。由于 JVM 线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一条线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此这种转换需要耗费很多的 CPU 时间。</p>
<p><img src="https://hadyang.github.io/interview/docs/java/concurrent/synchronized/assists/monitor_lock.svg"></p>
</li>
</ul>
<h1 id="二、Synchronized"><a href="#二、Synchronized" class="headerlink" title="二、Synchronized"></a>二、Synchronized</h1><p>该关键字解决的是多个线程之间访问资源的同步性，可以保证被他修饰的方法或者代码块在任意时刻只有一个线程执行。在java的早期版本，属于重量级锁，效率低下。为啥呢？</p>
<p>因为监视器锁是依赖底层的OS的Mutex Lock实现，java的线程是映射到OS的原生线程之上的。挂起或者唤醒一个线程需要OS帮忙，OS实现线程之间的切换时需要从用户态转化为内核态，转换时间长，时间成本高。在之后对S关键字进行优化，比如自旋锁，适应性锁等等。效率已经很不错了。</p>
<h2 id="如何使用该关键字"><a href="#如何使用该关键字" class="headerlink" title="如何使用该关键字"></a>如何使用该关键字</h2><ul>
<li><p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized void methos()&#123;</span><br><span class="line">&#x2F;&#x2F;业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰静态类方法：给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得当前class的锁。静态成员不属于任何一个实例，是类成员，所以如果一个线程A调用一个实例对象的非静态S方法，线程B需要调用这个实例对象所属类的静态S方法是不允许的，不会发生互斥现象。<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized void static method()&#123;</span><br><span class="line">&#x2F;&#x2F;业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰代码块：</p>
<p>指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized(this) &#123;</span><br><span class="line">  &#x2F;&#x2F;业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结如下：</p>
<ul>
<li>S关键字加到static静态方法和S代码块上都是给class类上锁。</li>
<li>S关键字加到实例方法上是给独对象实例上锁。</li>
<li>尽量不使用S(String a)，因为在JVM中，字符串常量池具有缓存功能。</li>
</ul>
<p><strong>双重校验锁实现对象单例（线程安全）</strong>–单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Victor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/29 18:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断对象有没有实例化，没有实例化才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uniqueInstance采用volatile关键字修饰也很必要。uniqueInstance = new Singleton();是分三步执行的：</p>
<ul>
<li>为u分配内存空间</li>
<li>初始化u</li>
<li>将u指向分配的内存地址。</li>
</ul>
<p>但是由于JVM具有指令重排的特性，执行顺序可能是1-&gt;3-&gt;2。在单线程不会有问题，但是多线程会导致一个线程获得还没初始化的实例。使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h2 id="构造方法可以使用S关键字修饰吗"><a href="#构造方法可以使用S关键字修饰吗" class="headerlink" title="构造方法可以使用S关键字修饰吗"></a>构造方法可以使用S关键字修饰吗</h2><p>不可。构造方法本身就线程安全，不存在同步的构造方法一说。</p>
<h2 id="S关键字的底层原理"><a href="#S关键字的底层原理" class="headerlink" title="S关键字的底层原理"></a>S关键字的底层原理</h2><p>JVM层面。</p>
<ul>
<li><p>S同步语句块的情况</p>
<p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>执行monitorenter时，线程试图获取对象监视器monitor的持有权（锁）。如果锁的计数器是0表示可以被获取，获取后+1</p>
<p>执行monitorexit之后，锁计数器清0，释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另一个线程释放为止。</p>
</li>
<li><p>S修饰方法</p>
<p>实现的是ACC_SYNCHRONIZED标识，该表示指明该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
</li>
</ul>
<h2 id="S和volatile的区别"><a href="#S和volatile的区别" class="headerlink" title="S和volatile的区别"></a>S和volatile的区别</h2><p>互补而不是对立。</p>
<ul>
<li>V是线程同步的轻量级实现，性能比S好。V用于变量，S修饰方法以及代码块。</li>
<li>V保证数据的可见性，不保证数据的原子性。S都能保证。</li>
<li>V主要用于解决变量在多个线程之间的可见性，S解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h1 id="三、ThreadLocal"><a href="#三、ThreadLocal" class="headerlink" title="三、ThreadLocal"></a>三、ThreadLocal</h1><p><a href="https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B?id=_2318-threadlocal-%e4%ba%86%e8%a7%a3%e4%b9%88%ef%bc%9f">参考阅读</a></p>
<p>使用T维护变量时，T为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。</p>
<p>每个线程中都保存一个<code>ThreadLocalMap</code>的成员变量，<strong>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，value就是threadlocal 调用set方法设置的值。</strong></p>
<p><strong>内存泄露：</strong></p>
<p><code>ThreadLocalMap</code> 使用 <code>ThreadLocal</code> 的弱引用作为 key ，value是强引用。如果一个 <code>ThreadLocal</code> 没有外部强引用来引用它，那么系统 GC 的时候，这个 <code>ThreadLocal</code> 的key清理，value不会清理，这样一来，<code>ThreadLocalMap</code> 中就会出现 <code>key</code> 为 <code>null</code> 的 <code>Entry</code> ，假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p>
<p>其实，<code>ThreadLocalMap</code> 的设计中已经考虑到这种情况，也加上了一些防护措施：在 <code>ThreadLocal</code> 的 <code>get(),set(),remove()</code>的时候都会清除线程 <code>ThreadLocalMap</code> 里所有 <code>key</code> 为 <code>null</code> 的 <code>value</code></p>
<h1 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h1><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<blockquote>
<p>线程池，数据库连接池，http连接池的思想都是为了减少每次获取资源的消耗，提高资源的利用率。</p>
</blockquote>
<p>使用线程池的好处：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性：对线程进行统一的分配，调优和监控。</li>
</ul>
<p><strong>如何创建线程池</strong></p>
<p>线程池不允许使用Executors创建，通过ThreadPoolExecutor的方式。因为E有以下弊端：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<p>通过构造方法实现框架的工具类Executor来实现我们可以创建三种类型的ThreadPoolExecutor。</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<h2 id="实现Runnable接口和Callable接口的区别。"><a href="#实现Runnable接口和Callable接口的区别。" class="headerlink" title="实现Runnable接口和Callable接口的区别。"></a>实现Runnable接口和Callable接口的区别。</h2><p>R从1.0一直存在，callback在1.5引入，来处理R不支持的用例。R接口不会返回异常，C可以。所以如果任务不需要返回结果或者抛出异常推荐使用R接口，代码简洁。工具类<code>Executors</code>可以实现R和C对象之间的相互转换。</p>
<p>工具类<code>Executors</code>可以实现<code>Runnable</code>对象和<code>callable</code>对象之间的转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 被线程执行，没有返回值也无法抛出异常</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算结果，或在无法这样做时抛出异常。</span><br><span class="line">     * @return 计算得出的结果</span><br><span class="line">     * @throws 如果无法计算结果，则抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行execute和submit方法的区别是什么？"><a href="#执行execute和submit方法的区别是什么？" class="headerlink" title="执行execute和submit方法的区别是什么？"></a>执行execute和submit方法的区别是什么？</h2><ul>
<li>E提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</li>
<li>S用于提交需要返回值的任务。线程池返回一个Feature类型类型，可以通过对象判断线程执行成功与否。并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<ul>
<li><p>通过构造方法实现</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="ThreadPoolExecutor构造方法"></p>
</li>
<li><p>通过Executor框架的工具类Executors来实现</p>
<ul>
<li>FixedThreadPool：返回一个固定数量的线程池，线程池的数量始终不变。有新任务检查是否空闲，是则执行，否则等待。</li>
<li>SingleThreadPool：返回只有一个线程的线程池。任务保存到队列，按照FIFO的方式执行。</li>
<li>CacheThreadPool：返回一个可根据实际情况调整的线程池，线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
</li>
</ul>
<h2 id="ThreadPoolExecutor类分析"><a href="#ThreadPoolExecutor类分析" class="headerlink" title="ThreadPoolExecutor类分析"></a>ThreadPoolExecutor类分析</h2><p>ThreadPoolExecutor类提供了四个构造方法。看最长的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个最重要的参数：</p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p>其他常见参数：</p>
<ul>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。</li>
</ul>
<p><strong>饱和策略</strong></p>
<p>饱和：当前同时运行的线程数量达到最大线程数量并且队列也已经被放满任务时。</p>
<ul>
<li>AbortPolicy：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li>CallerRunsPolicy：调用执行自己的线程运行任务。</li>
<li>**<code>DiscardPolicy</code>**：直接丢弃新任务</li>
<li>**<code>DiscardOldestPolicy</code>**：直接丢弃最早的未处理的请求。</li>
</ul>
<h1 id="五、Automic"><a href="#五、Automic" class="headerlink" title="五、Automic"></a>五、Automic</h1><p>基本类型，数组类型，引用类型，对象的属性修改类型。</p>
<p>在这里指的是一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，原子类就是指具有原子或者原子操作特征的类。并发包<code>java.util.concurrent</code>的原子类都存放在<code>java.util.concurrent.atomic</code>。</p>
<p>AtomicInteger是java钟常见的原子类，每种基础类型对应。AI中最重要的就是原子更新操作。</p>
<h1 id="六、AQS"><a href="#六、AQS" class="headerlink" title="六、AQS"></a>六、AQS</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器。</p>
<p>AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置成有效的工作线程，并将资源设置成锁定状态。如果资源占用，就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH队列是一个虚拟的双向队列。AQS将每条请求共享资源的线程封装成一个CLH锁队列的一个结点来实现锁的分配。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<p>使用int成员变量来实现同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作来实现值的修改。</p>
<h2 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h2><ul>
<li>独占：<ul>
<li>公平锁：排队顺序</li>
<li>非公平锁：抢锁，谁抢到谁用。</li>
</ul>
</li>
<li>共享：多个线程同时执行。</li>
</ul>
<h2 id="AQS组件总结"><a href="#AQS组件总结" class="headerlink" title="AQS组件总结"></a>AQS组件总结</h2><ul>
<li>Semaphore：信号量，允许多个线程同时访问，<code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li>CountDownLatch：倒计时器，同步工具类，用来控制线程等待。他可以让某个线程等待直到倒计时结束，再开始执行。</li>
<li>CyclicBarrier：循环栅栏。让一组线程到达一个同步点时被阻塞，直到最后一个线程到达屏障，屏障才会开门，所有被屏障拦截的线程才会继续工作。</li>
</ul>
<p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>
<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一、OS基础"><a href="#一、OS基础" class="headerlink" title="一、OS基础"></a>一、OS基础</h2><h3 id="1-什么是操作系统？"><a href="#1-什么是操作系统？" class="headerlink" title="1.什么是操作系统？"></a>1.什么是操作系统？</h3><ul>
<li>OS是管理计算机硬件与软件资源的程序，是计算机的基石。</li>
<li>本质是一个运行在计算机上的软件程序，用来管理计算机硬件和软件资源。</li>
<li>OS屏蔽了硬件层的复杂性。</li>
<li>内核是核心部分，负责系统的内存管理，硬件设备的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ul>
<h3 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="2.系统调用"></a>2.系统调用</h3><p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态：用户态运行的程序可以直接读取用户程序的数据。</li>
<li>系统态：系统态运行的进程或者程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>那什么是系统调用？</p>
<p>我们运行的程序运行在用户态，调用操作系统提供的系统态级别的子功能需要用到系统调用。这些系统调用可以分为：</p>
<ul>
<li>设备管理：完成设备的请求或者释放，以及设备启动等功能。</li>
<li>文件管理：完成文件的读、写、创建和删除。</li>
<li>进程控制：完成进程的创建，撤销，阻塞和唤醒等功能。</li>
<li>进程通信：完成进程间的消息传递或信号传递等功能。</li>
<li>内存管理：完成内存的分配，回收以及获取作业占用牛才能大小及地址等等。</li>
</ul>
<h2 id="二、进程和线程"><a href="#二、进程和线程" class="headerlink" title="二、进程和线程"></a>二、进程和线程</h2><h3 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1.进程和线程的区别"></a>1.进程和线程的区别</h3><p>一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<blockquote>
<p>线程是进程划分成更小的运行单位，一个进程在其执行的过程可以产生多个线程。最大的不同在于各进程基本上是独立的，而线程不一定，因为同一进程的线程可能互相影响。线程执行开销更小，但不利于资源的管理和保护，进程刚好相反。</p>
</blockquote>
<h3 id="2-进程有哪几种状态"><a href="#2-进程有哪几种状态" class="headerlink" title="2.进程有哪几种状态"></a>2.进程有哪几种状态</h3><ul>
<li>创建状态：被创建中，未就绪。</li>
<li>就绪状态：准备运行，获得除处理器之外的一切所需资源，once得到处理器资源就开始运行。</li>
<li>运行状态：进程在处理器上运行。</li>
<li>阻塞状态：等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li>结束状态：进程从系统中消失。可能是进程正常结束或者意外退出。</li>
</ul>
<h3 id="3-进程间的通信方式"><a href="#3-进程间的通信方式" class="headerlink" title="3.进程间的通信方式"></a>3.进程间的通信方式</h3><ul>
<li>匿名管道：具有亲缘关系的父子进程或者兄弟进程之间通信。</li>
<li>有名管道：遵循“FIFO”。以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li>信号：复杂，用于通知进程某个事件已经发生。</li>
<li>消息队列：消息的链表，存放在内存中由消息队列标识符标识。管道和消息队列都是先进先出。与管道不同，MQ存在于内核中，只有重启内核（操作系统重启）或者显示删除一个消息队列，才会真正的被删除。MQ可以实现消息的随机查询，不一定要FIFO的次序取出。MQ克服了信号承载量少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷。</li>
<li>信号量：计数器，用于多进程共享数据的访问，目的是进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li>共享内存：多进程访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存数据的更新。依靠同步操作，如互斥锁和信号量等。是最有效的进程间的通信方式。</li>
<li>套接字：客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元。可以看做是不同主机之间的进程间进行双向通信的端点。通信的双方的一种约定，用套接字的相关函数来完成通信。</li>
</ul>
<h3 id="4-线程间的同步方式"><a href="#4-线程间的同步方式" class="headerlink" title="4.线程间的同步方式"></a>4.线程间的同步方式</h3><ul>
<li><strong>互斥量：</strong>互斥对象机制，拥有互斥对象的线程才能访问公共资源。因为互斥对象只有一个，保证资源不会被多个线程同时访问。比如java中的synchronized和各种lock就是这种机制。</li>
<li><strong>信号量：</strong>允许同一时刻多个线程访问同一个资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件：</strong>通过通知操作的方式来保护多线程同步，还可以方便的实现多线程优先级比较操作。</li>
</ul>
<h3 id="5-进程的调度算法"><a href="#5-进程的调度算法" class="headerlink" title="5.进程的调度算法"></a>5.进程的调度算法</h3><ul>
<li><strong>先来先服务（FCFS）：</strong>从就绪队列选择一个最先进入到该队列的进程分配资源，一直执行到完成或者发生事件阻塞放弃占用CPU时在重新调度。</li>
<li><strong>短作业优先（SJF）：</strong>选择一个估计运行时间最短的进程分配资源。</li>
<li><strong>时间片轮转：</strong>最古老最简单的算法，又称为RR算法。每个进程分配一个时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法：</strong>前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度：</strong>为每个流程分配优先级。相同优先级的按照FCFS。</li>
</ul>
<h2 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h2><h3 id="1、操作系统的内存管理主要做什么？"><a href="#1、操作系统的内存管理主要做什么？" class="headerlink" title="1、操作系统的内存管理主要做什么？"></a><strong>1、操作系统的内存管理主要做什么？</strong></h3><p>负责内存的分配与回收（malloc:申请内存，free：释放内存），另外地址转换也就是将逻辑地址转化为相应的物理地址。</p>
<h3 id="2、常见的内存管理机制？"><a href="#2、常见的内存管理机制？" class="headerlink" title="2、常见的内存管理机制？"></a><strong>2、常见的内存管理机制？</strong></h3><p>连续分配管理方式和非连续分配管理方式。连续指的是为一个用户分配一个连续的内存空间。如<strong>块式管理</strong>。非连续方式允许一个程序使用的内存在离散或者不相邻的内存中，常见的比如<strong>页式管理</strong>和<strong>段式管理</strong>。</p>
<ul>
<li>块式管理：内存分成固定大小的块，一个块运行一个进程，如果进程需要的内存很小，则剩下的浪费。未利用的块成为碎片。</li>
<li>页式管理：主存分为大小相等且固定的页，页较小，比块的划分力度大，提高内存占用率，减少碎片。通过页表对应逻辑地址和物理地址。</li>
<li>段式管理：页提高利用率，但是页没意义。段式管理把主存分为一段一段的，比页小的多。段有意义，定义了一组逻辑信息。例如：主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
<li>段页式管理：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</li>
</ul>
<blockquote>
<h3 id="分页机制和分段机制的共同点和区别"><a href="#分页机制和分段机制的共同点和区别" class="headerlink" title="分页机制和分段机制的共同点和区别"></a><strong>分页机制和分段机制的共同点和区别</strong></h3><p>共同点：</p>
<ul>
<li>都是为了提高内存利用率，减少内存碎片化</li>
<li>离散存储，两者都是离散分配内存的方式，但是，每个页和段中的内存是连续的。</li>
</ul>
<p>区别：</p>
<ul>
<li>页大小固定，由OS决定，段大小不固定，取决于当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</blockquote>
<h3 id="3、快表和多级页表"><a href="#3、快表和多级页表" class="headerlink" title="3、快表和多级页表"></a><strong>3、快表和多级页表</strong></h3><blockquote>
<p>在操作系统中存在一个虚拟内存的概念，它用于内存的管理，使得应用程序认为它有一段连续的内存，大大地简化了程序员码代码的难度。程序员只用关注在这个连续的虚拟内存段中怎么使用内存，不用关心在物理内存中到底用那一段内存，进程运行的时候操作系统会自动进行映射。操作系统是怎么做到的呢？实际上操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫<strong>页表</strong>，页表的内容就是该进程的虚拟地址到物理地址的一个映射。</p>
</blockquote>
<p>在分页内存管理中，很重要的两点是：虚拟地址到物理地址的转换要快以及解决虚拟地址空间大，页表也会很大的问题。</p>
<ul>
<li><p>快表：特殊的高速缓冲器，内容是页表的一部分或者全部。作用和页表相似，但是提高了访问速度。由于采用页表做地址转换，读写内存数据CPU要访问主频两次，有了快表，有时候只访问一次高速缓冲存储器，一次主存，可以加快寻找并提高指令执行速度。使用快表之后的转换流程是这样的：</p>
<ul>
<li>根据虚拟地址中的页号查找地址</li>
<li>在快表，读取相应的物理地址</li>
<li>不在，访问内存中的页表，同时添加到快表</li>
<li>块表填满，按照一定的策略淘汰一个页。</li>
</ul>
</li>
<li><p>多级页表：避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表保存在内存中。属于时间换空间的典型场景。</p>
<p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了<strong>程序的局部性原理</strong>，局部性原理在后面的虚拟内存这部分会介绍到。</p>
</li>
</ul>
<h3 id="4、逻辑地址和物理地址"><a href="#4、逻辑地址和物理地址" class="headerlink" title="4、逻辑地址和物理地址"></a><strong>4、逻辑地址和物理地址</strong></h3><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h3 id="5、CPU寻址，为什么需要虚拟地址空间？"><a href="#5、CPU寻址，为什么需要虚拟地址空间？" class="headerlink" title="5、CPU寻址，为什么需要虚拟地址空间？"></a><strong>5、CPU寻址，为什么需要虚拟地址空间？</strong></h3><p>现代处理器使用虚拟寻址的方式，需要内存管理单元来完成。</p>
<ul>
<li><p>为什么要虚拟地址空间呢？</p>
<p>如果没有，程序直接访问操作物理内存，可能有的后果：</p>
<ul>
<li>程序访问任意内存，容易有意或无意破坏OS，造成崩溃。</li>
<li>同时运行多个程序比较困难，比如，微信给内存地址1xxx赋值后，QQ也同样给1XXX赋值，那就覆盖了，然后微信程序崩溃。</li>
</ul>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
</li>
</ul>
<h2 id="四、虚拟内存"><a href="#四、虚拟内存" class="headerlink" title="四、虚拟内存"></a>四、虚拟内存</h2><p>虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置电脑的虚拟内存。虚拟内存的重要意义是他定义了一个连续的寻你地址空间，并且把内存拓展到硬盘空间。</p>
<blockquote>
<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">https://zh.wikipedia.org/wiki/虚拟内存</a></p>
</blockquote>
<h3 id="1-局部性原理"><a href="#1-局部性原理" class="headerlink" title="1.局部性原理"></a>1.局部性原理</h3><p>是虚拟内存的基础，正是因为局部性原理，才可以只装入部分程序到内存就可以开始运行。</p>
<p>局部性原理表现在以下方面：</p>
<ul>
<li>时间局限性：程序中的某条指令一旦执行，不久以后可能再次执行；如果数据在某个较短的时间被访问过，可能再次访问，原因是程序中存在大量的循环操作。</li>
<li>空间局限性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ul>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2.虚拟内存"></a>2.虚拟内存</h3><p>基于局部性原理，程序装入时，先将一部分装入内存，其他部分留在外存。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>
<p>是一种时间换空间的策略，利用cup计算时间，页的调入调出时间来换更大的空间支持程序运行。程序的世界，不是时间换空间就是空间换时间。</p>
<h3 id="3-虚拟内存的技术实现"><a href="#3-虚拟内存的技术实现" class="headerlink" title="3.虚拟内存的技术实现"></a>3.虚拟内存的技术实现</h3><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</p>
<ul>
<li><strong>请求分页存储管理</strong>：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong>：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ul>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管哪种实现方式，都需要：</p>
<ul>
<li>一定容量的内存和外存。</li>
<li>缺页中断：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li>虚拟地址空间：逻辑地址到物理地址的转换。</li>
</ul>
<h3 id="4-页面置换算法"><a href="#4-页面置换算法" class="headerlink" title="4.页面置换算法"></a>4.页面置换算法</h3><p>地址映射的过程中，若在页面中发现需要访问的页面不在内存中，则发生缺页中断。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>缺页中断时，若当前没存没有空闲的页面，淘汰一页，称为页面置换算法。</p>
<ul>
<li><strong>OPT页面置换算法（最佳页面置换算法）：</strong>所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。</li>
<li><strong>FIFO：</strong>淘汰最先进入内存的页面。</li>
<li><strong>LRU（最近最久未使用）：</strong>访问字段记录页面上次被访问以来的时间T，淘汰T值最大的。</li>
<li><strong>LFU（最少使用页面）：</strong>之前时期使用最少的页面淘汰。</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h3><p>全称是Portable Exexutable，可移植的可执行文件，常见的如EXE，DLL，OCX，SYS，是windows操作系统上的程序文件。</p>
<h2 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h2><p>活：任务或执行者没有被阻塞，但由于某些条件没有满足，导致一直重复尝试，失败。区别在于处于活锁的实体是在不断的改变状态，处于死锁的实体表现为等待；活锁可以自行解开，死锁不可。</p>
<p>活锁是一系列进程在轮训的等待某个不可能为真的条件为真。进程不会blocked，这会导致CPU资源耗尽。</p>
<p>解决活锁可以引进一些随机性，检测到冲突就暂停一定时间进行重试。大大减少碰撞的可能性。</p>
<h2 id="直接寻址和间接寻址"><a href="#直接寻址和间接寻址" class="headerlink" title="直接寻址和间接寻址"></a>直接寻址和间接寻址</h2><p>寻址就是处理器根据指令中给出的地址信息来寻找物理地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址的方法。</p>
<ul>
<li>指令寻址:在内存中查找指令<ul>
<li>顺序：采用PC计数器来计数指令的顺序。</li>
<li>跳跃：下条程序的地址码不是程序计数器给出，而是本条指令给出。</li>
</ul>
</li>
<li>操作数寻址：形成操作数的有效地址<ul>
<li>立即寻址：操作数作为指令的一部分直接写在指令中。</li>
<li>直接寻址：基本的寻址方法，<strong>在指令格式的地址的字段中直接指出操作数在内存的地址。由于操作数的地址直接给出而不需要经过某种变换</strong>，所以称这种寻址方式为直接寻址方式。</li>
<li>间接寻址：间接寻址是相对直接寻址而言的，在间接寻址的情况下，<strong>指令地址字段中的形式地址不是操作数的真正地址，而是操作数地址的指示器，或者说此形式地址单元的内容才是操作数的有效地址</strong>。</li>
</ul>
</li>
</ul>
<h2 id="实时操作系统和分时操作系统"><a href="#实时操作系统和分时操作系统" class="headerlink" title="实时操作系统和分时操作系统"></a>实时操作系统和分时操作系统</h2><ul>
<li>分时：<strong>多个联机用户同时适用一个计算机系统在各自终端上进行交互式会话，程序、数据和命令均在会话过程中提供，以问答方式控制程序运行</strong>。系统把处理器的时间划分为时间片轮流分配给各个连接终端。</li>
<li>实时：当外部时间或数据产生时，能够对其予以接受并以足够快的速度进行处理，所得结果能够在规定时间内控制生产过程或对控制对象作出快速响应，并控制所有实时任务协调的操作系统。因而，<strong>提供及时响应和高可靠性是其主要特点</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构</title>
    <url>/2021/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h1><p><a href="https://krains.gitee.io/blogs/Algorithm&Data%20Structure/Data%20Structure/%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89">二叉树的遍历</a></p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ul>
<li><code>性质1</code>：在二叉树第i层的节点数最多为$2^{i-1}(i&gt;=1)$</li>
<li><code>性质2</code>：高度为k的二叉树节点总数为$2^k-1(k&gt;=1)$</li>
<li><code>性质3</code>：对于任意的非空二叉树，如果叶子节点的个数为$n_0$，而其度为2的节点数为$n_2$，则：$n_0=n_2+1$</li>
</ul>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>深度为k，且有$2^k-1$个节点称为满二叉树。</p>
<ul>
<li><code>性质4</code>：第i层的节点数为$2^{i-1}$</li>
</ul>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>最后一层从右左缺，成为完全二叉树。</p>
<ul>
<li><code>性质5</code>：有n个节点的完全二叉树的高度是$log_2^n+1$</li>
</ul>
<h2 id="二叉树的构造和遍历"><a href="#二叉树的构造和遍历" class="headerlink" title="二叉树的构造和遍历"></a>二叉树的构造和遍历</h2><ul>
<li><p>节点构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>建树与遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinTreeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;TreeNode&gt; nodeList = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BinTreeMain().createBinTree();</span><br><span class="line">        TreeNode root = nodeList.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;递归先序：&quot;</span>);</span><br><span class="line">        preOrder(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;非递归先序：&quot;</span>);</span><br><span class="line">        PreOrder(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;递归中序：&quot;</span>);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;非递归中序：&quot;</span>);</span><br><span class="line">        InOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        postOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        levelOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(Height(root));</span><br><span class="line">        <span class="keyword">new</span> BinTreeMain().Mirror(root);</span><br><span class="line">        levelOrder(root);</span><br><span class="line">        System.out.println(isSymmetrical(root));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nodeList = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">            nodeList.add(<span class="keyword">new</span> TreeNode(array[i]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> parentIndex = <span class="number">0</span>; parentIndex &lt; array.length / <span class="number">2</span> - <span class="number">1</span>; parentIndex++) &#123;</span><br><span class="line">            <span class="comment">// 左孩子</span></span><br><span class="line">            nodeList.get(parentIndex).left = nodeList.get(parentIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            nodeList.get(parentIndex).right = nodeList.get(parentIndex * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastparentIndex = array.length / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        nodeList.get(lastparentIndex).left = nodeList</span><br><span class="line">                .get(lastparentIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (array.length % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            nodeList.get(lastparentIndex).right = nodeList</span><br><span class="line">                    .get(lastparentIndex * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历输出-递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            preOrder(node.left);</span><br><span class="line">            preOrder(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历输出-非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode p = node;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.print(p.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    stack.push(p);</span><br><span class="line">                    p = p.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//在刚才那个p的左子树为空，或者p为叶子节点时执行。</span></span><br><span class="line">                    p = stack.pop();</span><br><span class="line">                    p = p.right;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(node.left);</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            inOrder(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历-非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode p = node; </span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(p);</span><br><span class="line">                    p = p.left;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    p = stack.pop();</span><br><span class="line">                    System.out.print(p.val+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    p = p.right;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序递归遍历输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(node.left);</span><br><span class="line">            postOrder(node.right);</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据先序序列和中序序列唯一建造一棵二叉树，返回二叉树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">preAndinCreateTree</span><span class="params">(<span class="keyword">char</span>[] pre,<span class="keyword">char</span>[] in,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//数组pre存储先序序列，i,j分别表示pre的上标和下标</span></span><br><span class="line">        <span class="comment">//in：中序序列，m，n分别表示in的上标和下标</span></span><br><span class="line">        <span class="comment">//函数返回先序序列和中序序列构成的树的根</span></span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        TreeNode p=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        p = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">        k = m;</span><br><span class="line">        <span class="comment">//在中序中找根</span></span><br><span class="line">        <span class="keyword">while</span>((k&lt;=n)&amp;&amp;in[k]!=pre[i])</span><br><span class="line">            k++;</span><br><span class="line">        p.left = preAndinCreateTree(pre,in,i+<span class="number">1</span>,i+k-m,m,k-<span class="number">1</span>);</span><br><span class="line">        p.right = preAndinCreateTree(pre,in,i+k-m+<span class="number">1</span>,j,k+<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层次遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                TreeNode nnode = queue.poll();</span><br><span class="line">                System.out.print(nnode.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (nnode.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(nnode.left);</span><br><span class="line">                <span class="keyword">if</span> (nnode.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(nnode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求二叉树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Height</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lh, rh;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lh = Height(node.left);</span><br><span class="line">            rh = Height(node.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (lh &gt; rh ? lh : rh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作给定的二叉树，将其变换为源二叉树的镜像。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode temp = root.left;</span><br><span class="line">            root.left = root.right;</span><br><span class="line">            root.right = temp;</span><br><span class="line">            Mirror(root.left);</span><br><span class="line">            Mirror(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 二叉树的下一个结点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。</span></span><br><span class="line"><span class="comment">     * 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对称的二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lrSym(pRoot.left, pRoot.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lrSym</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> left.val == right.val &amp;&amp; lrSym(left.left, right.right)</span><br><span class="line">                    &amp;&amp; lrSym(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>通常可以看做一棵树的数组对象。实际上为二叉树的一种。通常通过一维数组实现的，在数组起始位置为1时：</p>
<ul>
<li>父节点i的左子节点的位置为$2*i$</li>
<li>父节点i的右子节点所在位置为$2*i+1$</li>
<li>子节点i的父节点位置是$i/2$</li>
</ul>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>又称为最优二叉树，是一种带权路径长度最短的二叉树，数的路径长度是树根到每一个节点的长度之和，记作：$WPL=W_1<em>L_1+W_2</em>L_2+…+W_n*L_n$</p>
<p><strong>构造：</strong></p>
<ul>
<li>根据给定的n个权值<code>(W1,W2...Wn)</code>，使对应节点构成n个二叉树的森林<code>T=(T1,T2...Tn)</code>，其中每个二叉树<code>Ti(1 &lt;= i &lt;= n)</code>中都有一个带权值为Wi的根节点，其左、右子树均为空。</li>
<li>在森林T中选取两个节点权值最小的子树，分别作为左、右子树构造一个新的二叉树，且置新的二叉树的根节点的权值为其左右子树上根节点权值之和。</li>
<li>在森林T中，用新得到的二叉树替代选取的两个二叉树。</li>
<li>重复2和3，直到T只包含一个树为止。这个树就是霍夫曼树。</li>
</ul>
<p><strong>霍夫曼编码：</strong></p>
<p>对于哈夫曼树，左链取0，右链取1，从树根到叶子的所有编码，常被用作一种压缩算法。</p>
<p><strong>带权路径：</strong></p>
<ul>
<li>节点的权：节点有值</li>
<li>节点的带权路径：根节点到该节点的路径长度与节点权的乘积</li>
<li>树的带权路径：所有叶子节点的带权路径长度之和，记作WPL</li>
</ul>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>空数或具备下列性质：</p>
<ul>
<li>节点左不空，左子树上的节点值均小于根节点</li>
<li>右不空，则根节点小于右</li>
<li>节点的左右子树都是排序树</li>
<li>没有键值相等的节点。</li>
</ul>
<p>二分查找的时间复杂度是：$O(log(n))$，最坏是$O(n)$，相当于顺序查找</p>
<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><p>一种改进的二叉查找树，二叉查找树的查询复杂度和深度有关，因此当深度比较大的时候，查找复杂度会上升。平衡树诞生了。<strong>平衡指叶子的深度趋于平衡，广义的指树的可能查找的均摊复杂度偏低。</strong></p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>最先发明的平衡二叉查找树，在AVL 树中，任意两个子树的高度差别为1，也称为高度平衡树。</p>
<ul>
<li>左右子树都是平衡二叉树</li>
<li>左右子树的深度差小于1</li>
</ul>
<p>增加删除需要一次或多次树旋来重新平衡。</p>
<ul>
<li>右旋：左节点转到根节点位置</li>
<li>左旋：有节点转到根节点位置</li>
</ul>
<p>高度为k的AVL树，节点数最多$2^k-1$，即满二叉树。</p>
<p><strong>平衡因子：</strong>节点的左子树与右子树的深度差，只能是0，-1,1。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210312171507987.png" alt="image-20210312171507987" style="zoom:50%;" />

<p>是一种自平衡二叉查找树，每个节点都是红色或者黑色，优于AVL树，牺牲了部分平衡性来换取插入/删除操作时少量的旋转，有效的红黑树有如下要求：</p>
<ul>
<li>节点红黑</li>
<li>根是黑色</li>
<li>叶子都是黑色</li>
<li>红节点必须有两个黑色的子节点</li>
<li>任一节点到其每个叶子的所有简单路径都包含相同的黑色节点。</li>
</ul>
<p>如果一条路径上的顶点除了起点和终点可以相同外，其他顶点均不相同，则称此路径为一条简单路径；起点和重点相同的简单路径成为回路（环）。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>又称为前缀树，字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定的，一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，一般般情况下，不是所有的节点都有对应的值，只有叶子结点和部分内容节点所对应的键才会有对应的值。</p>
<p>查询和插入的时间复杂度都是O(n)，是一种空间换时间的方法。当节点树较多的时候，占用的内存比较大。</p>
<p>常用于搜索提示。当输入一个网址，可以自动搜索出可能出现的选择，当没有完全匹配的搜索结果，返回前缀最相似的可能。</p>
<h1 id="二、Hash"><a href="#二、Hash" class="headerlink" title="二、Hash"></a>二、Hash</h1><p>也叫作散列表，映射关系，主要解决两个问题，哈希冲突和冲突解决。</p>
<p><strong>哈希函数：</strong></p>
<p>也称为散列函数，对不同的输入值得到一个固定长度的消息摘要，理想的哈希函数应该是对不同的输入值产生不同的结构，同时散列结果应该具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值发生巨大的输出变化）。</p>
<p><strong>冲突解决：</strong></p>
<ul>
<li>开放链地址法：以发生冲突的地址为输入，通过某种哈希冲突得到一个新的空闲的哈希地址：<ul>
<li>线性探查：以发生冲突的地址开始，一次探查下一个地址。</li>
<li>平方探查：假设冲突地址为d0，查探查序列为$d0+1^2,d0-1^2,d0+2^2,,,$</li>
</ul>
</li>
<li>拉链法：把所有的同义词用单链表连接起来，在这种情况下，哈希表的每个单元存放的不再是元素本身，而是相应同义词单链表的头指针。HashMap就是用这种方法解决冲突的。</li>
</ul>
<h1 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h1><p>这里图的比较重要的算法有：深度优先，广度优先，最短路径算法，拓扑排序，并查集。</p>
<p><code>queue.offer()</code>是出队，<code>queue.poll()</code>是进队</p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzE1LzE3MTdjM2VmM2M4M2I4OTk?x-oss-process=image/format,png" alt="深度优先搜索和广度优先搜索，超详细图文解析_Viper的程序员修炼手册-CSDN博客_深度优先广度优先图解"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> vexNum,<span class="keyword">int</span>[][]matrix)</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[vexNum];</span><br><span class="line">        <span class="comment">//从0节点开始遍历</span></span><br><span class="line">        visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//队列不空的时候循环</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">            <span class="comment">//加入到结果序列</span></span><br><span class="line">            resList.add(index);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;vexNum;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[index][i]==<span class="number">1</span> &amp;&amp; visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                    visited[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p><img src="https://img-blog.csdnimg.cn/20200530055742298.gif" alt="深度优先遍历(DFS)、广度优先遍历(BFS)、随机游走(Random Walk)_Moer_hou的博客-CSDN博客"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> vexNum, <span class="keyword">int</span>[][]matrix)</span></span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[vexNum];</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从0节点开始遍历</span></span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;vexNum;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(matrix[index][i]==<span class="number">1</span> &amp;&amp; visited[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例题</strong>—矩阵中的最长递增路径</p>
<blockquote>
<p>给定一个整数矩阵，找出最长递增路径的长度，对于每个单元格，可以上下左右四个方向移动。不能往对角线移动。</p>
</blockquote>
<p>思路是在两个循环里，调用dfs，值得注意的是，本题不需要visited数组，因为要求递增，所以要求访问的下一个节点比上一个大，所以不会出现死循环。、</p>
<p>对于给定的定点nums[i][j]，在调用dfs的时候，需要向上下左右四个方向访问，四个防线，每个方向都需要判断边界是否溢出，不溢出的情况下判断下一个节点是否大于当前节点，因此需要进行四次递归，写出来的DFS是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span>[][]matrix,Map&lt;String,Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">0</span>,down = <span class="number">0</span>,left = <span class="number">0</span>,right =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(row-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; col&lt;matrix[<span class="number">0</span>].length &amp;&amp; col&gt;=<span class="number">0</span> &amp;&amp; col&lt;matrix[<span class="number">0</span>].length &amp;&amp; matrix[row][col]&lt;matrix[row+<span class="number">1</span>][col])&#123;</span><br><span class="line">        down = find(row-<span class="number">1</span>,col,matrix,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//***</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(Math.max(up,down),left),right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="https://lh3.googleusercontent.com/proxy/mq5ar8w4z-HOb1Wde9VfV6UoC7fQkhSgiy8qUzxxUX3o6wZ8FhrjYEnh-3BpJ0J3NUjJGHZvSgrWkqFTO9HMF3F76SKX1eXxB-i6JfaDJO2wqS1HlTRyQn8vJ4ml13DzNBPxQ9HUDwJ383gvxpAJAVsZFbQ"></p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>构造一个队列Q和拓扑排序的结果队列T</li>
<li>把所有没有依赖顶点的节点放入Q</li>
<li>当Q还有顶点的时候，执行以下步骤：<ul>
<li>从Q中取出一个顶点n，放入T</li>
<li>对n每一个临接点m<ul>
<li>去掉边&lt;n,m&gt;</li>
<li>如果m没有依赖顶点，把m放入Q</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses,<span class="keyword">int</span>[][]preOrders)&#123;</span><br><span class="line">    Queue&lt;Integer&gt; resQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="comment">//统计每个节点的入度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] entry:preOrders)&#123;</span><br><span class="line">        countArr[entry[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//没有入度的定点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(countArr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">            numCourses--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始广度优先遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">        resQueue.offer(index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] entry:preOrders)&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry[<span class="number">1</span>]==index)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--countArr[entry[<span class="number">0</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                    numCourses--;</span><br><span class="line">                    queue.offer(entry[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numCourses==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            res[i] = resQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><img src="https://songwell1024.github.io/2018/06/16/UnionFind/3.gif" alt="并查集详解及底层实现| 记路心晴"></p>
<p>并查集主要用于描述集合，如可以将一对相关点划分成几个独立的集合以及某个元素是否属于某个集合，两个元素是否在一个集合中。</p>
<ul>
<li><p>基本并查集</p>
<p>基于数组实现的并查集，最基本的思想是，<strong>数组下标为当前元素标号，元素值是下标所在的集合</strong>，当两个严肃合并的时候，以较大元素为大哥，将另一组元素的值全部更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//下标为元素，值为所在集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Union</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找某个元素属于哪一个集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[element];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两个严肃是否属于同一个集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(first)==find(second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> firstEle,<span class="keyword">int</span> secondEle)</span></span>&#123;</span><br><span class="line">        <span class="comment">//本来就是一个集合，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(find(firstEle)==find(secondEle))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> firRoot = find(firstEle);</span><br><span class="line">            <span class="keyword">int</span> secRoot = find(secondEle);</span><br><span class="line">            <span class="keyword">if</span>(firRoot&lt;secRoot)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(id[i]==firRoot)id[i] = secRoot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(id[i] == secRoot)id[i] = firRoot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法在查找元素的时候很快，但是union很慢。因为每次union都需要遍历整个数组。</p>
</li>
<li><p>快Union，慢find</p>
<p>在上面的例子中，每次merge都需要遍历整个数组，我们现在每次只更新一个数据，形成一个链，但是这样查找就比较慢了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找某个元素属于哪一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id[element]!=element)&#123;</span><br><span class="line">        element = id[element];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id[element];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//合并两个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> firstEle,<span class="keyword">int</span> secondEle)</span></span>&#123;</span><br><span class="line">    <span class="comment">//本来就是一个集合，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(find(firstEle)==find(secondEle))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> firRoot = find(firstEle);</span><br><span class="line">        <span class="keyword">int</span> secRoot = find(secondEle);</span><br><span class="line">        <span class="keyword">if</span>(firRoot&lt;secRoot)&#123;</span><br><span class="line">            id[firRoot] = secRoot;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            id[secRoot] = firRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p><img src="https://img-blog.csdnimg.cn/20201128093946374.gif" alt="迪杰斯特拉(Dijkstra)算法_xiaoxi_hahaha的博客-CSDN博客"></p>
<p>求解单源点最短路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] d(<span class="keyword">int</span>[][]weight,<span class="keyword">int</span> start)&#123;</span><br><span class="line">    <span class="comment">//求解的是source到各个顶点的最短路径</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[weight.length];</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[weight.length];</span><br><span class="line">    <span class="comment">//初始化结果矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;weight.length;i++)&#123;</span><br><span class="line">        res[i] = weight[start][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找n-1次，每次确定一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt; weight.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找出一个未标记并且离出发点最近的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt; weight.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=start &amp;&amp; !visited[j] &amp;&amp; res[j]&lt;min)&#123;</span><br><span class="line">                min = res[j];</span><br><span class="line">                p = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记节点已经访问过</span></span><br><span class="line">        visited[p] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;weight.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==p || weight[p][j]==Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="comment">//P点不能到达</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res[p]+weight[p][j]&lt;res[j])&#123;</span><br><span class="line">                res[j] = res[p]+weight[p][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h2><p>采用动态规划的思想对路径距离进行N此更新，N是顶点数，其中顶点(i,j)之间的以K更新的条件是：dis[i][j]&gt;dis[i][k]+dis[k][j]，更新完成之后，我们得到的是图上任意两点之间的最短距离。如何通过path矩阵得到最短路径呢？需要初始化一个记录两点之间的路径的矩阵path[][]，在path矩阵更新的时候，将该对应成功更新两点间距离的点记录在path矩阵对应的位置上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void floyd(int[][]arr,int[][]path)&#123;</span><br><span class="line">        int num &#x3D; arr.length;</span><br><span class="line">        &#x2F;&#x2F;节点轮流坐庄</span><br><span class="line">        for(int k &#x3D; 0;k&lt;num;k++)&#123;</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                for(int j &#x3D; 0; j&lt;num;j++ )&#123;</span><br><span class="line">                    int tmp &#x3D; arr[i][k]+arr[k][j];</span><br><span class="line">                    if(tmp&lt;arr[i][j])&#123;</span><br><span class="line">                        arr[i][j] &#x3D; tmp;</span><br><span class="line">                        path[i][j] &#x3D; k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过递归的方式寻找路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span>[][] path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;点&quot;</span>+start+<span class="string">&quot;到点&quot;</span>+end+<span class="string">&quot;的路径是：&quot;</span>+start+<span class="string">&quot;-&gt;&quot;</span>+findPath(start,end,path)+end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">find</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span>[][] path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = path[start][end];</span><br><span class="line">        <span class="keyword">if</span>(mid==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find(start,mid,path)+<span class="string">&quot;&quot;</span>+mid+<span class="string">&quot;-&gt;&quot;</span>+find(mid,end,path);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、查找算法"><a href="#五、查找算法" class="headerlink" title="五、查找算法"></a>五、查找算法</h1><h2 id="1、ASL"><a href="#1、ASL" class="headerlink" title="1、ASL"></a>1、ASL</h2><p>平均查找长度，$\mathrm{ASL}=\sum(\mathrm{n}, \mathrm{i}=1) \mathrm{Pi} * \mathrm{Ci}$，其中n为元素个数，Pi是查找第I个元素的概率，一般为$P_i=1/n$，Ci是找到第I个元素所需要的比较次数。</p>
<h2 id="2、顺序查找"><a href="#2、顺序查找" class="headerlink" title="2、顺序查找"></a>2、顺序查找</h2><p>让关键字与队列中的数从最后一个开始逐个比较，直到找出与给定关键字相同的数为止，它的缺点是效率低下。**时间复杂度o(n)**。</p>
<h2 id="3、折半查找"><a href="#3、折半查找" class="headerlink" title="3、折半查找"></a>3、折半查找</h2><p>折半查找要求线性表示有序表。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<strong>折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。</strong></p>
<ul>
<li><strong>可以借助二叉判定树求得折半查找的平均查找长度</strong>：<code>log2(n+1)-1</code>。</li>
<li>折半查找在失败时所需比较的关键字个数不超过判定树的深度，n个元素的判定树的深度和n个元素的完全二叉树的深度相同<code>log2(n)+1</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchStandard</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = num.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end)&#123; <span class="comment">//注意1</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &gt; target)&#123;</span><br><span class="line">            end = mid - <span class="number">1</span>; <span class="comment">//注意2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start = mid + <span class="number">1</span>; <span class="comment">//注意3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、分块查找"><a href="#4、分块查找" class="headerlink" title="4、分块查找"></a>4、分块查找</h2><p>分块查找又称索引顺序查找，它是一种性能介于顺序查找和折半查找之间的查找方法。<strong>分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况</strong>。</p>
<h1 id="六、排序算法"><a href="#六、排序算法" class="headerlink" title="六、排序算法"></a>六、排序算法</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>插入类：直接插入，折半插入，希尔排序</li>
<li>选择类：简单选择，堆排序，</li>
<li>交换类：冒泡，快排</li>
<li>归并排序，基数排序，外部排序</li>
<li>$o(nlog_2n)$：快些归队(堆)，快排在有序的情况下最坏是$o(n^2)$</li>
<li>不稳定：快些(希)选一堆</li>
</ul>
<p><strong>从小到大</strong></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>每次两两比较，把剩余最大或者最小的移动到一端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j-<span class="number">1</span>]&gt;nums[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                nums[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E5%86%92%E6%B3%A1.gif" alt="冒泡"></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        <span class="keyword">while</span> (nums[j]&lt;nums[j-<span class="number">1</span>] &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Krains/FigureBed/raw/master/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
<h2 id="简单选择"><a href="#简单选择" class="headerlink" title="简单选择"></a>简单选择</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//每次找到最小的元素和前面进行交换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[index])index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[index];</span><br><span class="line">        nums[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[high];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; nums[j]&lt;=temp) j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; nums[i]&gt;temp) i++;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        quick_sort(nums,low,i-<span class="number">1</span>);</span><br><span class="line">        quick_sort(nums,i+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20200201113100677.gif&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1620200001&t=51df3d47a2f3df6571a94afef3468d67" alt="img"></p>
<h1 id="七、跳跃表"><a href="#七、跳跃表" class="headerlink" title="七、跳跃表"></a>七、跳跃表</h1><p>一种数据结构，用于快速查询一个有序连续元素的数据链表。平均查找和插入的时间复杂度是$O(log_n)$。</p>
<p>维护了一个多层次的链表，每一层链表的元素是上一层链表元素的子集。开始算法在最稀疏的层次搜索，直到需要查找的元素在该层两个元素之间，算法跳跃到下一个层次，重复刚刚的搜索，直到找到需要查找的元素。跳过的元素的方法可以是 <strong>随机性选择</strong> 或 <strong>确定性选择</strong>，其中前者更为常见。</p>
<p>在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾。如果该元素等于目标元素，则表明该元素已被找到；如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/1.gif" alt="1"></p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、五层协议"><a href="#一、五层协议" class="headerlink" title="一、五层协议"></a>一、五层协议</h1><p>一般折中OSI和TCP/IP，采用五层协议。（自上而下）</p>
<p><strong>5 应用层：</strong></p>
<p><a href="https://krains.gitee.io/blogs/Computer%20Network/%E5%BA%94%E7%94%A8%E5%B1%82.html#%E6%A6%82%E8%BF%B0">参考</a></p>
<p>应用层的任务是通过使用进程间的交互来完成特定网络应用。应用层定义的是应用进程（进程：主机中正在运行的程序）间的交互规则，对于不同的网络应用需要不同的应用协议。应用层协议很多，如DNS，HTTP协议，电子邮件SMTP协议，把应用层交互的数据称为<strong>报文</strong>。</p>
<ul>
<li><p>DNS</p>
<blockquote>
<p>域名系统，是因特网的一项核心服务，是一个将域名和IP地址映射的一个分布式数据库。</p>
</blockquote>
</li>
<li><p>HTTP协议</p>
<blockquote>
<p>超文本传输协议。所有的www文件都遵守这个标准。设计Http最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
</blockquote>
</li>
<li><p>websocket</p>
</li>
</ul>
<p><strong>4 运输层：</strong></p>
<p><a href="https://krains.gitee.io/blogs/Computer%20Network/%E4%BC%A0%E8%BE%93%E5%B1%82.html#%E6%A6%82%E8%BF%B0">参考</a></p>
<p>负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用报文。由于一台主机可以同时运行多个线程，因此传输层具有复用和分用的功能。复用就是指多个应用进程可以同时用下面传输层的服务，分用则是把运输层把收到的消息交付到上面应用层中的相应进程。</p>
<p>运输层主要负责以下两种协议：</p>
<ul>
<li>传输控制协议TCP：提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议UDP：无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ul>
<p><strong>3 网络层：</strong></p>
<p><a href="https://krains.gitee.io/blogs/Computer%20Network/%E7%BD%91%E7%BB%9C%E5%B1%82.html#%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE-ip">参考</a></p>
<p>在计算机网络中进行通信的两个计算机可能会讲过很多个数据链路，也可能还要经过很多通信子网。网络层的作用就是选择合适的网间路由和交换节点，确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称<strong>数据报</strong>。</p>
<blockquote>
<p>运输层的数据报UDP和网络层的IP数据报不一样，另外，无论是哪一层的数据单元，都可以笼统的用“分组”来表示。</p>
</blockquote>
<p>互联网是大型的异构网络通过路由器连接起来的。互联网使用的网络层协议是无连接的网际协议和许多路由选择协议，因此互联网的网络层也叫作<strong>网际层</strong>、<strong>IP层</strong>。</p>
<p><strong>2 数据链路层：</strong></p>
<p>简称为链路层。两台主机传输数据，是在一段一段的数据链路上传送的，需要专门的链路层协议。在两个相邻的节点传输数据时，链路层将网络层交下来的IP数据报组装成帧，在两个相邻的节点传送帧。每一帧包括数据和必要的信息（同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使得接收端能够知道一个帧从哪个比特开始到哪个比特结束。这样链路层在收到一个帧后就可以从中提取数据部分。控制信息还使得接收端能够检测到所收到的帧中有错误差。发现差错，链路层简单的丢弃这个帧，避免浪费资源。如果需要改正差错，就要采用可靠性传输协议来纠正差错。</p>
<p><strong>1 物理层：</strong></p>
<p>在物理层上传送的数据是比特。物理层的作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。使得其上面的链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.png" alt="计算机网络复习"></p>
<h1 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h1><h2 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/tcp_head.png" alt="tcp_head"></p>
<ul>
<li>32位序列号：<ul>
<li>含有同步标识SYN，则为最初的序列号；第一个数据比特的序列码为本序列号加一</li>
<li>如果没有同步标识（SYN），则此为第一个数据比特的序列码</li>
</ul>
</li>
<li>32位确认号：希望收到的下一个数据报的序列号，表明到序列号 <code>N-1</code> 为止的所有数据已经正确收到。</li>
<li>TCP协议数据报头长：4位长。表明TCP头中包含多少个 4字节</li>
<li>保留：置0</li>
<li><strong>ACK</strong>：期望收到的数据的开始序列号。也即已经收到的数据的字节长度加1</li>
<li>PSH：表示是带有PUSH标志的数据。接收方因此请求数据报一到便可送往应用程序而不必等到缓冲区装满时才传送。</li>
<li><strong>RST</strong>：用于复位由于主机崩溃或其它原因而出现的错误的连接。还可以用于拒绝非法的数据报或拒绝连接请求。</li>
<li><strong>SYN</strong>：用于建立连接。</li>
<li><strong>FIN</strong>：用于释放连接。</li>
<li><strong>窗口大小（WIN）</strong>：16位长。表示从确认号开始，本报文的发送方（数据发送端 or 数据接收端）可以接收的字节数，即接收窗口大小。用于流量控制。</li>
<li><strong>校验和（Checksum）</strong>：16位长。是为了确保高可靠性而设置的。它校验头部、数据和伪TCP头部之和。</li>
<li>紧急指针：<code>URG=1</code>时才有意义。</li>
</ul>
<blockquote>
<p>TCP最小长度是20字节。</p>
</blockquote>
<h2 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h2><p>为了准确的把数据传送到目标，TCP协议采用了三次握手策略。</p>
<ul>
<li>客户端：发送带有SYN标志的数据报——一次握手（服务端）</li>
<li>服务端：发送带有SYN/ACK标志的数据报——二次握手（客户端）</li>
<li>客户端：发送带有ACK标志的数据包——三次握手（服务端）</li>
</ul>
<p><strong>为什么三次握手？</strong></p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%202%20%E9%A1%B5.png" alt="计算机网络复习-第 2 页"></p>
<ul>
<li>建立可靠的通信信道，通讯简单来说就是数据的发送和接收，三次握手的主要目的是双方确认自己与对方的发送与接受是正常的。</li>
<li>第一次握手：客户端什么都不能确认，服务端确认对方发送正常，自己接收正常。</li>
<li>第二次握手：客户端确认：自己发送接收正常，对方发送接收正常。服务端确定：对方发送正常，自己接收正常。</li>
<li>第三次握手：客户端确认：自己发送接收，对方发送接收正常。服务端确认：自己发送接收、对方发送接收正常。</li>
</ul>
<p><strong>为什么传回SYN？</strong></p>
<p>传回SYN的目的是为了告诉发送端，我接收到的信息确实就是你发送的信号。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<p><strong>传SYN，为啥还要传ACK？</strong></p>
<p>两者互相通信无误才行。传了SYN，证明发送方到接收方的通道没问题，接收方到发送方的通道还需要ACK信号来验证。</p>
<p>断开一个TCP连接需要<strong>四次挥手：</strong></p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%203%20%E9%A1%B5.png" alt="计算机网络复习-第 3 页"></p>
<ul>
<li>客户端：发送一个FIN，用来关闭客户端到服务器的数据传输。</li>
<li>服务端：收到FIN，它发回一个ACK，确认信号为收到的需要+1,。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务端：关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端：发回ACK报文确认，并将确认序号设置为收到序号+1.</li>
</ul>
<p><strong>为什么需要四次挥手？</strong></p>
<p>任何一方都可以发送连接释放的通知，对方确认后进入办关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。更具体一点：AB两人通话，A：我说完了。B：我知道了（但我可能还有话说）。B：我也说完了。A：知道了（挂断）。</p>
<h2 id="TCP，UDP协议的区别"><a href="#TCP，UDP协议的区别" class="headerlink" title="TCP，UDP协议的区别"></a>TCP，UDP协议的区别</h2><p>UDP在传送数据之前不需要建立连接，远程主机收到UDP报文后，不需要给出任何确认。虽然UDP不提供可交付，但是比较有效。比如：QQ语音，视屏，直播。</p>
<p>TCP提供面向连接的服务。传送前建立连接，传送后断开连接。不提供广播或者多播服务。（可靠性体现在三次握手，在数据传输时，还有确认，窗口，重传等等，在数据传输之后，还会断开连接来释放资源）。增加很多开销，使得协议数据单元的首部增大很多。一般用于文件传输，发送和接受邮件，远程登陆。</p>
<p><strong>TCP如何保证可靠传输？</strong></p>
<p>分块，编号，校验和，流量控制，拥塞机制，ARQ，超时重传。</p>
<ul>
<li>数据被分割成TCP认为最适合传输的数据块</li>
<li>给发送的每一个包进行编号，接收方对数据报进行排序，把有序数据传给应用层。</li>
<li><strong>校验和：</strong>TCP将保持他首部和数据的校验和。这是一个端到端的检验和，目的是检验数据在传输的过程中的任何变化，有变化则丢弃并不确认收到此报文。</li>
<li>TCP接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong>连接双方有缓冲空间，只允许发送缓冲区能接纳的数据，接收端来不及处理的时候提示发送方降低发送速率，防止丢包。缓冲区是可改变大小的滑动窗口协议。</li>
<li><strong>拥塞控制：</strong>网络阻塞时，减少数据的发送</li>
<li><strong>ARQ协议：</strong>每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ul>
<h2 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h2><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>为了进行控制，TCP维持一个<strong>拥塞窗口</strong>的状态变量。窗口的大小取决于网络的拥塞程度，动态变化，发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p>
<p>采用了四种算法：慢开始、拥塞避免、快重传、快恢复。</p>
<ul>
<li><strong>慢开始：</strong>因为不知道情况，小到大增加发送窗口，cwnd(拥塞窗口)初始1，每次加倍。</li>
<li><strong>拥塞避免：</strong>让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT（网络时延）就把发送放的cwnd加1.</li>
<li><strong>快重传与恢复：</strong>FRR（快速重传与恢复）能快速恢复丢失的数据包，没有FRR，丢失后，TCP使用定时器要求传输暂停。有了FRR，接收方收到一个不按照顺序的数据段，立即发送于一个重复确认。如果发送方接到三个重复确认，会假定指出的数据丢失，立即重传丢失的数据。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p><strong>自动重传请求</strong>是OSI模型汇总数据链路层和传输层的错误纠正协议之一。使用确认和超时连个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送一段时间没有收到确认帧，通常重新发送。ARQ通常包括：停止等待ARQ和连续ARQ协议。</p>
<p><strong>停止等待ARQ：</strong></p>
<ul>
<li>为了实现可靠传输，原理是：发送完停止，等待对方确认（回复ACK），超时没有收到ACK，则重新发送。</li>
<li>若接收方收到重复分组，丢弃，但需要发送确认。</li>
</ul>
<p>优点：简单</p>
<p>缺点：信道利用率低，等待时间长。</p>
<ol>
<li><p>无差错情况：</p>
<p>收到ACK，再次发送。</p>
</li>
<li><p>出现差错（超时重传）、</p>
<p>发送完一个分组需要一个超时计时器。这种重传方式通常称为：自动重传请求ARQ。</p>
</li>
<li><p>确认丢失和确认迟到</p>
<ul>
<li>确认丢失：确认消息丢失，客户端再次发送，服务端收到消息采取以下搓手：丢弃消息，不向上层交付。再次发送确认消息。</li>
<li>确认迟到：A发，B确认，但消息迟到。A再发，B第二次确认到达。传输别的。A收到第一次确认到达。处理方式：A收到重复确认直接丢弃，B收到重复的数据直接丢弃。</li>
</ul>
</li>
</ol>
<p><strong>连续ARQ</strong></p>
<p>可以提高信道利用率。发送方位置控制一个发送窗口，窗口内的分组连续发送，无需ACK，接收方累计确认，对顺序到达的最后一个分组发送ACK，表明到这个分组为止的所有分组都正确收到。</p>
<p>有点：信道利用率高，容易实现，即使确认丢失，也不不必重传。</p>
<p>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h1 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h1><h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><h3 id="请求报文头部"><a href="#请求报文头部" class="headerlink" title="请求报文头部"></a>请求报文头部</h3><ul>
<li><code>User-Agent</code>：产生请求的浏览器类型。</li>
<li><code>Accept</code>：客户端可识别的响应内容类型列表;</li>
<li><code>Accept-Language</code>：客户端可接受的自然语言;</li>
<li><code>Accept-Encoding</code>：客户端可接受的编码压缩格式;</li>
<li><code>Accept-Charset</code>：可接受的应答的字符集;</li>
<li><code>Host</code>：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;（必选）</li>
<li><code>Connection</code>：连接方式(close 或 <code>keep-alive</code>);</li>
<li><code>Cookie</code>：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;</li>
<li><code>请求包体</code>：在<code>POST</code>方法中使用。</li>
<li><code>Referer</code>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</li>
<li><code>If-Modified-Since</code>：文档的最后改动时间</li>
</ul>
<h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><ul>
<li><code>Allow</code> 服务器支持哪些请求方法（如GET、POST等）。</li>
<li><code>Content-Encoding</code> 文档的编码（Encode）方法。</li>
<li><code>Content-Length</code> 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。</li>
<li><code>Content-Type</code> 表示后面的文档属于什么MIME类型。</li>
<li><code>Date</code> 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>
<li><code>Expires</code> 应该在什么时候认为文档已经过期，从而不再缓存它。</li>
<li><code>Last-Modified</code> 文档的最后改动时间。</li>
<li><code>Refresh</code> 表示浏览器应该在多少时间之后刷新文档，以秒计。</li>
<li><code>Server</code> 服务器名字。</li>
<li><code>Set-Cookie</code> 设置和页面关联的Cookie。</li>
<li><code>ETag</code>：被请求变量的实体值。ETag是一个可以与Web资源关联的记号（MD5值）。</li>
<li><code>Cache-Control</code>：这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。</li>
</ul>
<h2 id="Q：输入URL地址，显示主页的过程"><a href="#Q：输入URL地址，显示主页的过程" class="headerlink" title="Q：输入URL地址，显示主页的过程"></a>Q：输入URL地址，显示主页的过程</h2><p><a href="https://mp.weixin.qq.com/s/haA2icMB7NzZnkwT88Pw4g">更详细的参考这里</a></p>
<p>主要会使用到哪些协议。</p>
<p>过程：</p>
<ul>
<li>1、浏览器查找域名的IP地址（浏览器缓存，路由器缓存,DNS缓存）</li>
<li>2、浏览器向WEB服务器发送http请求（cookies会随着请求发送给服务器）</li>
<li>3、服务器处理请求</li>
<li>4、服务器发回一个HTML响应。</li>
<li>5、浏览器开始显示HTML</li>
</ul>
<p>协议：</p>
<ul>
<li>DNS</li>
<li>TCP：与服务器建立TCP连接</li>
<li>IP：建立TCP协议，需要发送数据，发送数据再网络层使用IP协议</li>
<li>OPSF：IP数据包在路由器期间，路由选择使用此协议。</li>
<li>ARP：路由器与服务器通信，将IP转化为mac地址</li>
<li>HTTP：TCP建立后，通过HTTP访问网页。</li>
</ul>
<h2 id="Q-状态码"><a href="#Q-状态码" class="headerlink" title="Q-状态码"></a>Q-状态码</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类别</th>
<th align="center">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1..</td>
<td align="center">信息性状态码</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="center">2..</td>
<td align="center">成功状态码</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3..</td>
<td align="center">重定向状态码</td>
<td align="center">需要进行附加操作完成请求</td>
</tr>
<tr>
<td align="center">4..</td>
<td align="center">客户端错误状态码</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5..</td>
<td align="center">服务器错误状态码</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<ul>
<li><p>3</p>
<p>重定向，需要进一步的操作以完成请求</p>
<ul>
<li><code>301 Moved Permanently</code>。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
</ul>
</li>
<li><p><code>302 Moved Temporarily</code>。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>
<ul>
<li><code>304 Not Modified</code>。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。<strong>客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</strong>。</li>
</ul>
</li>
<li><p>4</p>
<p>客户端错误，请求包含语法错误或无法完成请求</p>
<ul>
<li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li>
</ul>
</li>
<li><p><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<ul>
<li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li>
</ul>
</li>
<li><p>5</p>
<p>服务器错误，服务器在处理请求的过程中发生了错误</p>
<ul>
<li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>
</ul>
</li>
<li><p><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</p>
</li>
</ul>
<h2 id="Q-各种协议与HTTP协议的关系"><a href="#Q-各种协议与HTTP协议的关系" class="headerlink" title="Q-各种协议与HTTP协议的关系"></a>Q-各种协议与HTTP协议的关系</h2><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210320222328026.png" alt="image-20210320222328026"></p>
<h2 id="Q-HTTP长连接、短连接"><a href="#Q-HTTP长连接、短连接" class="headerlink" title="Q-HTTP长连接、短连接"></a>Q-HTTP长连接、短连接</h2><p><strong>HTTP/1.0默认短连接</strong>，客户端每次访问某个html或者其他类型的web中包含其他的web资源（JS文件，图像，CSS），每次遇到这样一个web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>从HTTP/1.1默认使用长连接，会在响应头加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection：keep-alive</span><br></pre></td></tr></table></figure>

<p>长连接，每次一个网页打开，客户端和服务器之间用于传输HTTP数据的TCP连接不关闭。不会持久保持，有保持时间，可以在不同的服务器软件设定。实现长连接的客户端和服务器都需要支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接短连接。</p>
<h2 id="Q-HTTP如何保存用户状态"><a href="#Q-HTTP如何保存用户状态" class="headerlink" title="Q-HTTP如何保存用户状态"></a>Q-HTTP如何保存用户状态</h2><p>HTTP是<strong>无状态</strong>协议，自身不对请求体和响应体之间的通信状态进行保存。Session机制，通过服务端记录用户状态。典型的场景是购物车，当你添加商品到购物车时，系统不知道是哪个用户，服务器给特定的用户创建特定的Session来标识这个用户并跟踪。（过期销毁）。</p>
<p>在服务端保存session方法：内存和数据库（redis），既然session在服务端，那如何实现session跟踪呢？通过在cookie中添加一个session ID 的方式来实现追踪。</p>
<p><strong>cookie被禁用了怎么办？</strong></p>
<p>URL重写，直接把Session ID附加在URL路径的后面。</p>
<h2 id="Q-Cookie"><a href="#Q-Cookie" class="headerlink" title="Q-Cookie"></a>Q-Cookie</h2><p>Cookie和Session都用来跟踪浏览器用户身份的会话方式，但是场景不太一样。</p>
<p>Cookie一般保存用户信息：</p>
<ul>
<li>在cookie中保存已经登录过的用户信息，下次访问网站可以自动填写基本信息。</li>
<li>保持登录，在cookie中存放了token。</li>
<li>登录一次网站后访问网站其他页面不需要登陆。</li>
</ul>
<p>Cookie数据保存在客户端，Session保存在服务器端。</p>
<p>Session安全性更高。</p>
<h2 id="Q-HTTP-1-0和HTTP-1-1"><a href="#Q-HTTP-1-0和HTTP-1-1" class="headerlink" title="Q-HTTP/1.0和HTTP/1.1"></a>Q-HTTP/1.0和HTTP/1.1</h2><ul>
<li>1.0默认长连接。1.1的持续连接有流水线和非流水线方式。流水线是客户端收到HTTP的响应报文之前能接着发送新的请求报文。非流水线是客户端在收到前一个响应后才能发送下一个请求。</li>
<li>错误状态响应码：新增了24个状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化以及网络连接的使用：1.0存在浪费带宽，例如客户端要对象的一部分，但是服务端把整个对象都穿过来，不支持断点续传。1.1在请求头引入range头域，允许只请求资源的某个部分，返回206。</li>
</ul>
<h2 id="Q-URL和URI"><a href="#Q-URL和URI" class="headerlink" title="Q-URL和URI"></a>Q-URL和URI</h2><p>URI：统一资源标志符，唯一表示一个资源</p>
<p>URL：统一资源定位符，可以提供资源的路径。是具体的URI。</p>
<p>URI像身份证，URL像家庭住址。不仅标识资源，还提供定位资源的信息。</p>
<h2 id="Q-HTTP和HTTPS"><a href="#Q-HTTP和HTTPS" class="headerlink" title="Q-HTTP和HTTPS"></a>Q-HTTP和HTTPS</h2><p><a href="https://hadyang.github.io/interview/docs/basic/net/https/">HTTPS补充</a></p>
<ul>
<li>端口：HTTP默认80，HTTPS默认443</li>
<li>安全性和资源消耗：HTTP基于TCP，传输明文，客户端和服务器都无法验证对方身份。HTTPS运行在SSL/TLS上面的HTTP协议，运行在TCP之上，对称加密，安全性高但是消耗更多服务器资源。<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ul>
<h1 id="五、websocket"><a href="#五、websocket" class="headerlink" title="五、websocket"></a>五、websocket</h1><p>一种与HTTP不同的协议。两者都位于OSI模型的应用层，依赖TCP协议。虽然不同，但是RFC规定：WebSocket设计为通过80和443端口工作，支持HTTP代理和中介，从而和HTTP兼容，为了实现兼容，W握手使用HTTP ，Upgrade头从HTTP协议更改为W协议。</p>
<p>与H不同，W提供权全双工通信。此外，W还可以在TCP之上启用消息流。TCP单独处理字节流，没有固定的消息概念。</p>
<p>WebSocket协议规范将 <code>ws</code>（WebSocket）和 <code>wss</code> （WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>较小的控制开销：</strong></li>
<li><strong>更强的实时性：</strong>由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；</li>
<li><strong>保持连接状态：</strong>与 HTTP 不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li><strong>更好的二进制支持：</strong>Websocket 定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li><strong>可以支持拓展：</strong>Websocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
<li><strong>更好的压缩效果：</strong>相对于HTTP压缩，Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
<p><strong>连接过程：</strong></p>
<p>W是独立的、创建在TCP上的协议，W通过HTTP/1.1协议的101状态码进行握手。为了创建W连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为握手。</p>
<ul>
<li><p>客户端请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP&#x2F;n9NdMgdcy2VJFQ&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></li>
<li><p>服务器回应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s&#x3D;</span><br><span class="line">Sec-WebSocket-Location: ws:&#x2F;&#x2F;example.com&#x2F;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、补充"><a href="#六、补充" class="headerlink" title="六、补充"></a>六、补充</h1><p><a href="https://hadyang.github.io/interview/docs/basic/net/tcp/">参考资料</a></p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实践</title>
    <url>/2021/04/10/CICD/</url>
    <content><![CDATA[<h1 id="1、DevOps"><a href="#1、DevOps" class="headerlink" title="1、DevOps"></a>1、DevOps</h1><p>所谓云原生，可以概括为四个点：<strong>DevOps+持续交付+微服务+容器</strong></p>
<p>朴素的说，<code>DevOps = Dev(开发人员)+Ops(运维人员)</code>。实际上涵盖的角色范围会更广泛：除了开发，测试，运维，还涉及项目经理，产品经理等等跨职能部门相互合作，完成某一项目或者任务。</p>
<p>实际上DevOps从需求设计到开发、测试到运维，甚至是线上的运行反馈是整个全生命周期的，所以他是一个大桶多个部门协调的平台。至于工具和自动化只是实现的一种手段。或者说，DevOps是通过工具，自动化来达到通过工具链与持续集成、交付、反馈、优化进行端到端的整合，完成无缝的跨团队、跨系统协作。总结为三点：</p>
<ul>
<li>DevOps理念：以客户、业务需求为导向，向着同一个目标前进，强调多个部门紧密沟通与协作的软件交付过程。它包括产品管理，软件开发及运营等各个方面。</li>
<li>DevOps核心实践：人员协作文化+持续交付能力支撑</li>
<li>DevOps目标：建立一种精诚合作的文化和环境，通过工具链与持续集成、交付、反馈、优化来实现跨团队、跨系统协作方式。</li>
</ul>
<p>DevOps最佳实践手段就是CICD，这是绕不开的话题，<strong>DevOps是CICD思想的延伸，CICD是DevOps的技术核心</strong>，没有CICD和自动化测试，DevOps是没有意义的。</p>
<h2 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h2><p>持续集成。</p>
<p>是一种开发实践，倡导团队需要频繁的集成工作，每次集成都通过自动化构建（编译，构建，自动化测试）来验证，从而快速发现集成中的错误。让正在开发的软件始终处于可工作状态，让产品可以快速迭代，同时保持高质量。</p>
<h2 id="CD"><a href="#CD" class="headerlink" title="CD"></a>CD</h2><p>CD包含了两层内容，持续交付和持续部署。这两者是不相等的。</p>
<ul>
<li>持续交付：持续集成的延伸，他将集成后的代码部署到生产环境，确保可以以可持续的方式快速向客户发布新的更改。如果代码没有问题，可以继续手工部署到生产环境中。她强调的是，不管怎么更新，软件是随时随地可以交付的。</li>
<li>持续部署：持续部署是持续交付的下一步，在持续交付的基础上，由开发人员或运维人员自助式的定期向生产环境部署稳定的构建版本，持续部署的目标是代码在任何时刻都是可部署的，并可自动进入到生产环境。</li>
</ul>
<p><strong>持续交付是指团队确保每个变更可以部署至生产环境，但也许并不需要实际部署</strong>，这通常可能是出于业务方面的原因。而<strong>持续部署是指每个变更可以自动部署到生产环境</strong>。只有成功实现持续交付的前提下，才能进行持续部署。</p>
<h1 id="2、CICD实践"><a href="#2、CICD实践" class="headerlink" title="2、CICD实践"></a>2、CICD实践</h1><p>这部分总结我们实验室在CICD的实践。</p>
<p>实验室最开始的软件开发过程是这样的：后端同学按照文档写API，前端同学前期用mock模拟数据保证开发进度不受影响，在前后端联调的阶段，后端同学把自己的jar包手动运行在服务器上，供前端同学调用。现在前端同学反映API有问题，后端同学在debug之后重新打包放在服务器运行，这是一个非常繁琐且无趣的过程。于是我们开始探索CICD的实现。</p>
<p>没有使用厂商的集成工具，用的是gitlab+docker技术实现CICD。</p>
<h2 id="1-相关概念介绍"><a href="#1-相关概念介绍" class="headerlink" title="1.相关概念介绍"></a>1.相关概念介绍</h2><ul>
<li><p>CICD </p>
<p>前面介绍过了</p>
</li>
<li><p>Docker</p>
<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
</li>
<li><p>Docker-compose</p>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。这非常适用于我们的微服务场景，每个微服务一般部署若干实例，每个实例手动启停的开销过大，可以借助docker-compose管理。</p>
</li>
<li><p>container/image</p>
<p>镜像类似于虚拟机的镜像。是一个只读模板，一个独立的文件系统，包含运行容器需要的所有数据。</p>
<p>dcoker利用容器来创建应用：docker容器是由docker镜像创建的运行实例。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210324204204902.png" alt="image-20210324204204902"></p>
</li>
<li><p>.gitlab-ci.yml、Dockerfile、gitlab-runner</p>
<ul>
<li>.gitlab-ci.yml：定义流水线阶段分级与每个阶段具体逻辑的文件</li>
<li>Dockerfile：用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</li>
<li>gitlab-runner：执行软件集成脚本的机器。</li>
</ul>
</li>
</ul>
<h2 id="2-机器"><a href="#2-机器" class="headerlink" title="2.机器"></a>2.机器</h2><ul>
<li>CI机：安装docker和gitlab-runner</li>
<li>服务机：安装docker和docker-compose</li>
<li>gitlab：代码仓库，在项目中设置环境变量和gitlab-runner</li>
<li>阿里云镜像服务：需要使用云商提供的容器镜像服务来构建 <code>远程镜像仓库</code>，本文以阿里云为例。</li>
</ul>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/CICD.png" alt="CICD"></p>
<h2 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3.步骤"></a>3.步骤</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>CI机：<code>2核8G/100Mbps</code></li>
<li>服务机：<code>4core16G/100Mbps</code></li>
<li>阿里云镜像容器服务：<ul>
<li>容器镜像服务ACR</li>
<li>个人版</li>
<li>创建命名空间</li>
<li>创建镜像仓库</li>
<li>代码源：本地代码</li>
</ul>
</li>
</ul>
<h3 id="CI机器"><a href="#CI机器" class="headerlink" title="CI机器"></a>CI机器</h3><ul>
<li><p>安装docker并设置自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>配置SSH key密钥对与服务机通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@服务机IP</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里配置是因为CICD的deploy阶段需要CIdergitlab-runner通过ssh连接来执行服务机命令。</p>
</blockquote>
</li>
<li><p>安装gitlab-runner并运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">-v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v /root/.ssh:/root/.ssh \</span><br></pre></td></tr></table></figure>

<p>命令挂载了三个东西，分别是：</p>
<ul>
<li>gitlab-runner的配置文件</li>
<li>让runner里面可以执行宿主机的docker</li>
<li>让CI机器能够免密访问服务机</li>
</ul>
</li>
<li><p>将runner注册到gitlab中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab-runner gitlab-ci-multi-runner register</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：输入gitlab URL(你们自己的gitlab地址)</li>
<li>第二步：输入gitlab-ci token，去gitlab的CICD的配置里去copy</li>
<li>第三步：输入runner的description、tags，其中tags会在后续的.gitlab-ci.yml中用到</li>
<li>第四步：输入runner的执行器，选择docker</li>
<li>第五步：选择默认的 docker 镜像</li>
</ul>
</li>
<li><p>编辑gitlab-runner配置文件</p>
<p>配置文件挂载到宿主机了，编辑宿主机的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;srv&#x2F;gitlab-runner&#x2F;config&#x2F;config.toml</span><br></pre></td></tr></table></figure>

<p>配置样例：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">concurrent</span> = <span class="number">10</span></span><br><span class="line"><span class="section">[[runners]]</span></span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;s****an&quot;</span></span><br><span class="line">  <span class="attr">url</span> = <span class="string">&quot;https://co*******m/&quot;</span></span><br><span class="line">  <span class="attr">token</span> = <span class="string">&quot;m********JFMHxD&quot;</span></span><br><span class="line">  <span class="attr">executor</span> = <span class="string">&quot;docker&quot;</span></span><br><span class="line">  <span class="section">[runners.custom_build_dir]</span></span><br><span class="line">  <span class="section">[runners.cache]</span></span><br><span class="line">    <span class="section">[runners.cache.s3]</span></span><br><span class="line">    <span class="section">[runners.cache.gcs]</span></span><br><span class="line">  <span class="section">[runners.docker]</span></span><br><span class="line">    <span class="attr">tls_verify</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">image</span> = <span class="string">&quot;ccchieh/centos-common&quot;</span></span><br><span class="line">    <span class="attr">privileged</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable_entrypoint_overwrite</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">oom_kill_disable</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable_cache</span> = <span class="literal">false</span></span><br><span class="line">    <span class="attr">volumes</span> = [<span class="string">&quot;/cache&quot;</span>, <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span>, <span class="string">&quot;/usr/bin/docker:/usr/bin/docker&quot;</span>, <span class="string">&quot;/data/.m2:/root/.m2&quot;</span>, <span class="string">&quot;/root/.ssh:/root/.ssh&quot;</span>, <span class="string">&quot;/root/.docker/:/root/.docker/&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这里修改的主要是<code>concurrent</code>、<code>volumes</code>、<code>pull_policy</code></p>
<ul>
<li><p>concurrent</p>
<p>表示这个runner可以并行执行多少任务，常见的就是，同时提交多次任务或者在一次流水线中任务可以并行完成，例如在buile阶段，会同时执行下载依赖构建的操作。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210324213059916.png" alt="image-20210324213059916"></p>
</li>
<li><p>volumes</p>
<p>挂载的目录，就是docker run 的时候用的 -v 挂载的目录，因为我们后面需要编译Dockerfile，所以将docker的相关目录文件挂载上去，然后挂载下maven仓库（这里是直接挂载了，实际使用的时候也可以利用gitlab-ci文件里面的cache进行缓存）避免每次打包编译java项目的时候都要下载一次依赖（这里是针对maven的，其他依赖管理软件视情况而定）。最后我这里直接把宿主机的.ssh也挂载上去了，是为了后面可以操作远程部署的服务器，因为我这里都是内网机器，所以安全性暂时不考虑，这里再实际应用中请注意下，避免不必要的风险。</p>
</li>
<li><p>pull_policy</p>
<p>表示只有当本地没镜像的时候才拉取镜像，避免每次都重新拉取镜像。</p>
</li>
</ul>
</li>
</ul>
<h3 id="项目文件编写与gitlab设置"><a href="#项目文件编写与gitlab设置" class="headerlink" title="项目文件编写与gitlab设置"></a>项目文件编写与gitlab设置</h3><ul>
<li><p>设置项目的gitlab-runner</p>
<p>在CI机器配置完成，确保之前注册的runner是available的。</p>
</li>
<li><p>编写Dockerfile</p>
<p>每个项目需要编写一个Dockerfile实现项目的编译打包，这里以后端微服务的项目为例，文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个基本的微服务打包环境,将公用模块install</span></span><br><span class="line">FROM ccchieh/maven3-openjdk-8-cn as prod</span><br><span class="line">ARG MY_HOME=/usr/src/app</span><br><span class="line">COPY . <span class="variable">$MY_HOME</span></span><br><span class="line">WORKDIR <span class="variable">$MY_HOME</span></span><br><span class="line">ENV TIME_ZONE=Asia/Shanghai</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/<span class="variable">$TIME_ZONE</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TIME_ZONE</span> &gt; /etc/timezone</span><br><span class="line">RUN /usr/<span class="built_in">local</span>/bin/mvn-entrypoint.sh mvn clean install</span><br></pre></td></tr></table></figure></li>
<li><p>设置项目的环境变量</p>
<p>.gitlab.yml支持环境变量，这样可以把一些敏感信息隐藏。</p>
<p><img src="https://leofang.cn/post/docker-ci/11.png"></p>
<p>这里设置了容器名称，进行私有仓库地址，部署服务器地址，服务器中的docker-compose的文件路径。</p>
<p>其中镜像仓库地址的前缀需要去阿里云的镜像仓库查看。</p>
</li>
<li><p>编写.gitlab-ci.yml</p>
<p>.gitlab-ci.yml文件定义了CI/CD pipeline的阶段与具体逻辑，这里我们分为四个阶段（pre-build、build、deploy、cleanup）来打包构建项目的镜像：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cleanup</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span> <span class="comment"># 编译阶段</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shuishan</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">--build-arg</span> <span class="string">MODULE_NAME=$CONT_NAME</span> <span class="string">--build-arg</span> <span class="string">PROFILE_NAME=dockerdev</span> <span class="string">-t</span> <span class="string">$IMAGE_MASTER</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">$IMAGE_MASTER</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">build-prod:</span> <span class="comment"># 编译阶段</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shuishan-aliyun-runner</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">      <span class="string">docker</span> <span class="string">build</span> <span class="string">--build-arg</span> <span class="string">MODULE_NAME=$CONT_NAME</span> <span class="string">--build-arg</span> <span class="string">PROFILE_NAME=docker</span> <span class="string">-t</span> <span class="string">$IMAGE_PROD</span> <span class="string">.</span></span><br><span class="line">      <span class="string">docker</span> <span class="string">push</span> <span class="string">$IMAGE_PROD</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span> <span class="comment"># 部署阶段</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shuishan</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$TEST_SERVER_ADDR</span> <span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">$&#123;TEST_SERVER_PATH&#125;/docker-compose.yml</span> <span class="string">stop</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$TEST_SERVER_ADDR</span> <span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">$&#123;TEST_SERVER_PATH&#125;/docker-compose.yml</span> <span class="string">rm</span> <span class="string">-sf</span> <span class="string">$CONT_NAME</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$TEST_SERVER_ADDR</span> <span class="string">docker</span> <span class="string">rmi</span> <span class="string">$IMAGE_MASTER</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$TEST_SERVER_ADDR</span> <span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">$&#123;TEST_SERVER_PATH&#125;/docker-compose.yml</span> <span class="string">up</span> <span class="string">-d</span> <span class="string">--build</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-prod:</span> <span class="comment"># 部署阶段</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shuishan-aliyun-runner</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$SERVER_ADDR</span> <span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">$&#123;SERVER_PATH&#125;/docker-compose.yml</span> <span class="string">stop</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$SERVER_ADDR</span> <span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">$&#123;SERVER_PATH&#125;/docker-compose.yml</span> <span class="string">rm</span> <span class="string">-sf</span> <span class="string">$CONT_NAME</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$SERVER_ADDR</span> <span class="string">docker</span> <span class="string">rmi</span> <span class="string">$IMAGE_PROD</span></span><br><span class="line">      <span class="string">ssh</span> <span class="string">$SERVER_ADDR</span> <span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">$&#123;SERVER_PATH&#125;/docker-compose.yml</span> <span class="string">up</span> <span class="string">-d</span> <span class="string">--build</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">cleanup:</span> <span class="comment"># 清理作业</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">cleanup</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">prod</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">shuishan</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;回收垃圾&quot;</span></span><br><span class="line">  <span class="comment">#    - docker system prune -f # 删除docker中间无用镜像</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">always</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="服务机"><a href="#服务机" class="headerlink" title="服务机"></a>服务机</h3><ul>
<li><p>连接</p>
</li>
<li><p>安装docker自启</p>
</li>
<li><p>安装docker-compose</p>
</li>
<li><p>安装git</p>
</li>
<li><p>编写docker-compose.yml</p>
<p>Docker Compose默认的模板文件是<code>docker-compose.yml</code>，我们可以通过编在服务机上编写<code>docker-compose.yml</code>文件，将繁琐的docker命令整合成一个文件，最后通过一行命令来统一执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nacos:</span><br><span class="line">    container_name: nacos-standalone</span><br><span class="line">    image: nacos&#x2F;nacos-server:latest</span><br><span class="line">    environment:</span><br><span class="line">    - PREFER_HOST_MODE&#x3D;hostname</span><br><span class="line">    - MODE&#x3D;standalone</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;nacos&#x2F;standalone-logs&#x2F;:&#x2F;home&#x2F;nacos&#x2F;logs</span><br><span class="line">    - .&#x2F;nacos&#x2F;init.d&#x2F;custom.properties:&#x2F;home&#x2F;nacos&#x2F;init.d&#x2F;custom.properties</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;8848:8848&quot;</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        aliases:</span><br><span class="line">         - nacos</span><br><span class="line">  redis:</span><br><span class="line">    container_name: metasequoia-redis</span><br><span class="line">    restart: always</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        aliases:</span><br><span class="line">         - redis</span><br><span class="line"># 后端 </span><br><span class="line">  bx-gateway-zuul:</span><br><span class="line">    container_name: bx-gateway-zuul</span><br><span class="line">    image: registry.cn-shanghai.aliyuncs.com&#x2F;shuishan-data&#x2F;shuishan-gateway-server:master</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;bx-gateway-zuul-logs&#x2F;:&#x2F;logs&#x2F;</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;8080:8080&quot;</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        aliases:</span><br><span class="line">         - api # 设置api服务的别名</span><br><span class="line">    environment:</span><br><span class="line">    - NACOS_ADDR&#x3D;nacos</span><br><span class="line">    - NACOS_PORT&#x3D;8848</span><br><span class="line">  user-center:</span><br><span class="line">    container_name: user-center</span><br><span class="line">    image: registry.cn-shanghai.aliyuncs.com&#x2F;shuishan-data&#x2F;shuishan-usercenter-server:master</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;user-center-logs&#x2F;:&#x2F;logs&#x2F;</span><br><span class="line">    environment:</span><br><span class="line">    - NACOS_ADDR&#x3D;nacos</span><br><span class="line">    - NACOS_PORT&#x3D;8848</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        aliases:</span><br><span class="line">         - usercenter</span><br><span class="line">  shuishan-datav-server:</span><br><span class="line">    container_name: shuishan-datav-server</span><br><span class="line">    image: registry.cn-shanghai.aliyuncs.com&#x2F;shuishan-data&#x2F;shuishan-datav-server:master</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">    - .&#x2F;shuishan-datav-server-logs&#x2F;:&#x2F;logs&#x2F;</span><br><span class="line">    - .&#x2F;data&#x2F;:&#x2F;root&#x2F;data&#x2F;</span><br><span class="line">    environment:</span><br><span class="line">    - NACOS_ADDR&#x3D;nacos</span><br><span class="line">    - NACOS_PORT&#x3D;8848</span><br></pre></td></tr></table></figure>

<p>这里我们需要打包构建的服务镜像包括：nacos服务发现镜像、redis服务镜像、网关服务镜像、用户鉴权服务镜像、子服务镜像(shuishan-datav-server)。</p>
</li>
<li><p>构建项目的容器镜像</p>
<p>进入到包含docker-compose.yml的目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose -f ./docker-compose.yml up -d --build</span><br></pre></td></tr></table></figure>

<p>该命令可以自动完成包括构建镜像，(重新)创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
</li>
</ul>
<h1 id="3-Dockerfile-docker-compose"><a href="#3-Dockerfile-docker-compose" class="headerlink" title="3.Dockerfile+docker compose"></a>3.Dockerfile+docker compose</h1><h2 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h2><p>项目本身前后端分工比较明确，前端同学前期通过mock模拟数据进行页面开发，可以做到和后端完全解耦。但是最后总是要把mock的数据换到remote，这不得不进行一些前后端联调的测试。作为后端管理人员，每次需要在发现问题后，将项目重新打包部署在服务器，是一件比较繁琐的事情，这时候CICD(持续交付持续集成)的需求就应运而生。</p>
<p>OK，思路是先把后端打包成docker镜像，然后去写配置。项目一开始是把nacos也打成一个jar包去运行，但是放到服务器就各种各样的问题。第一个想到的仍然是docker，官网查阅，果然有，运行也是如丝般顺滑。强烈安利Docker啊啊啊啊，一定要去用！！！</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200812092926.png" alt="image-20200812092918803" style="zoom:50%;" />

<blockquote>
<p>以下内容来自<a href="https://www.runoob.com/docker/docker-dockerfile.html">菜鸟教程</a></p>
<p>我也不知道为啥要跟着敲一遍，可能印象更深刻</p>
</blockquote>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile是一个用来构建镜像的文本文件，文本文件包含了构建镜像需要的指令和说明。</p>
<h3 id="使用dockerfile定制镜像"><a href="#使用dockerfile定制镜像" class="headerlink" title="使用dockerfile定制镜像"></a>使用dockerfile定制镜像</h3><ul>
<li><p>定制一个nginx镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;这是一个本地构建的nginx镜像&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>

<p><img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200812094233.png" alt="image-20200812094233894"></p>
</li>
<li><p>from和run指令的作用</p>
<ul>
<li><p>FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
</li>
<li><p>RUN：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<ul>
<li><p>shell格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></pre></td></tr></table></figure></li>
<li><p>exec格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;，&quot;参数1&quot;，&quot;参数2&quot;]</span><br><span class="line"># RUN [&quot;java&quot;, &quot;-jar&quot;, &quot;-Xmx1024m&quot;, &quot;&#x2F;usr&#x2F;src&#x2F;kfcoding-gateway.jar&quot;, &quot;--spring.profiles.active&#x3D;prod&quot;]</span><br><span class="line">等价于 RUN java -jar -Xmx1024m &#x2F;user&#x2F;src&#x2F;kfcoding-gateway.jar --spring.profiles.active&#x3D;prod</span><br></pre></td></tr></table></figure></li>
<li><p>attention</p>
<p>dockerfile的指令每执行一次都会在docker上新建一层，过多无意义的层会造成镜像膨胀，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xvf redis.tar.gz</span></span><br><span class="line">以上执行会创建 <span class="number">3</span> 层镜像。可简化为以下格式：</span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install wget \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xvf redis.tar.gz</span></span><br><span class="line">使用&amp;&amp;只会创建一层镜像</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h3><p>  在dockerfile文件存放的目录下，执行构建一个nginx:test(镜像名称：镜像标签)，最后的<code>.</code>表示上下文路径</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:<span class="built_in">test</span> .</span><br></pre></td></tr></table></figure>

<p>  通过docker images查看镜像</p>
<h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><p>  上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包</p>
<p>  <strong>解析：</strong>由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p>
<p>  如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p>
<p>  <strong>注意：</strong>上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
<h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><ul>
<li><p><strong>COPY</strong></p>
<p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>**[–chown=<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>
<p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure>

<p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p>
</li>
<li><p><strong>ADD</strong></p>
<p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
</li>
<li><p><strong>CMD</strong></p>
<p>类似于RUN指令，运行的时间点不同</p>
<ul>
<li>CMD在docker run 时候运行</li>
<li>RUN在docker build</li>
</ul>
<p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span><br></pre></td></tr></table></figure>

<p>推荐第二种格式，执行过程比较明确、第一种的可执行文件是sh。</p>
</li>
<li><p><strong>ENTRYPOINT</strong></p>
<p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>
<p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure>

<p>可以搭配CMD使用：一般变参使用CMD，这里的CMD等于是给ENTRYPOINT 传参，示例：</p>
<p>假设构建了nginx:test镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参</span><br><span class="line">CMD [&quot;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;] # 变参 </span><br></pre></td></tr></table></figure>

<ul>
<li><p>不传参运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run nginx:<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>容器默认运行一下命令，启动主进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure></li>
<li><p>传参运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run  nginx:<span class="built_in">test</span> -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>

<p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>ENV</strong></p>
<p>设置环境变量，后续指令可以使用，格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;&#x3D;&lt;value&gt; &lt;key2&gt;&#x3D;&lt;value2&gt;...</span><br></pre></td></tr></table></figure>

<p>设置NODE_VERSION=7.2.0，之后通过$NODE_VERSION引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>**ARG **</p>
<p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG &lt;参数名&gt;[&#x3D;&lt;默认值&gt;]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>VOLUME</strong></p>
<p>定义匿名数据卷。启动容器忘记挂载数据卷，会自动挂载到匿名数据卷</p>
<p><strong>作用</strong>：</p>
<ul>
<li>避免重要的数据，因为容器重启而丢失</li>
<li>避免容器不断变大</li>
</ul>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>

<p>zai docker run的时候，可以通过-v参数修改挂载点</p>
</li>
<li><p><strong>EXPOSE</strong></p>
<p>声明端口</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>WORKDIR</strong></p>
<p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>
<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>USER</strong></p>
<p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>HEALTHEHECK</strong></p>
<p>用于指定某个程序或者指令来监控docker容器服务的运行状态</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line"></span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br></pre></td></tr></table></figure></li>
<li><p><strong>ONBUILD</strong></p>
<p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Docker-Componse"><a href="#Docker-Componse" class="headerlink" title="Docker Componse"></a>Docker Componse</h2></li>
</ul>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Componse使用的三个步骤：</p>
<ul>
<li>使用dockerfile定义应用程序的环境</li>
<li>使用docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<p>docker-componse.yml的配置案例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>准备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir composetest</span><br><span class="line"><span class="built_in">cd</span> composetest</span><br><span class="line">vi ap.py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span>():</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure>

<p>在示例中，redis是应用程序网络上的redis容器的主机名，port = 6379。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi requirements.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建Dockerfile文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>内容解释：</strong></p>
<ul>
<li>FROM python:3.7-alpine：从Python 3.7 映像开始构建镜像。</li>
<li>WORKDIR /code：将工作目录设置为 /code。</li>
<li>ENV：设置flask使用的环境变量</li>
<li>5：安装gcc</li>
<li>6、7：复制requirements.txt并安装依赖</li>
<li>8： 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</li>
<li>9：容器提供默认的执行命令为：flask run。</li>
</ul>
</li>
<li><p><strong>创建docker-compose.yml</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi docker-compose.yml</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yaml 配置</span><br><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;5000:5000&quot;</span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br></pre></td></tr></table></figure>

<p>定义了两个服务：web和redis</p>
<ul>
<li>web：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</li>
<li>redis：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</li>
</ul>
</li>
<li><p><strong>使用compose命令构建和运行应用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="yml配置指令参考"><a href="#yml配置指令参考" class="headerlink" title="yml配置指令参考"></a>yml配置指令参考</h3><ul>
<li><p><strong>version</strong></p>
<p>指定本 yml 依从的 compose 哪个版本制定的。</p>
</li>
<li><p><strong>build</strong></p>
<p>指定构建镜像上下文路径：</p>
<p>例如webapp服务，指定为上下文路径./dir/Dockerfile所构建的镜像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">version:&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="attr">webapp:</span></span><br><span class="line">		<span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure>

<p>或者，作为具有在上下文指定的路径的对象，以及可选的Dockerfile和args</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;com.example.description=Accounting webapp&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;com.example.department=Finance&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;com.example.label-with-empty-value&quot;</span></span><br><span class="line">      <span class="attr">target:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<ul>
<li>content：上下文路径</li>
<li>dockerfile：添加构建镜像的dockerfile文件名</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
</li>
<li><p><strong>cap_add，cap_drop</strong></p>
<p>添加或删除容器拥有的宿主机的内核功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ALL</span> <span class="comment"># 开启全部权限</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SYS_PTRACE</span> <span class="comment"># 关闭 ptrace权限</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>cgroup_parent</strong></p>
<p>为容器指定父cgroup组，继承该组的资源限制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">m-executor-abcd</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>command</strong></p>
<p>覆盖容器启动的默认命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span>: [<span class="string">&quot;bundle&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;thin&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;3000&quot;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>container_name</strong></p>
<p>指定自定义容器名称，而不是生成的默认名称</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">my-web-container</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>depends_on</strong></p>
<p>设置依赖关系</p>
<ul>
<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li>
<li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li>
<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>

<p>web服务不会等redis db完全启动之后才启动</p>
</li>
<li><p><strong>deploy</strong></p>
<p>指定与服务的部署和运行有关的配置。只在swarm模式下生效</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="string">mode：replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">6</span></span><br><span class="line">      <span class="attr">endpoint_mode:</span> <span class="string">dnsrr</span></span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">description:</span> <span class="string">&quot;This redis service label&quot;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.50&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">50M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.25&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">20M</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">120s</span></span><br></pre></td></tr></table></figure>

<p>可选参数：</p>
<ul>
<li><p>endpoint_mode:vip：访问集群服务的方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">endpoint_mode:</span> <span class="string">vip</span> </span><br><span class="line"><span class="comment"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span></span><br><span class="line"><span class="attr">endpoint_mode:</span> <span class="string">dnsrr</span></span><br><span class="line"><span class="comment"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span></span><br></pre></td></tr></table></figure></li>
<li><p>labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p>
</li>
<li><p>model：指定服务提供的模式</p>
<ul>
<li><p>replicated：复制服务。复制制定服务到集群的机器上。</p>
</li>
<li><p>global：全局服务，服务将部署到集群的每个节点上。</p>
</li>
<li><p>下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。</p>
<img src="https://picgo06.oss-cn-zhangjiakou.aliyuncs.com/img/20200812203843.png" alt="image-20200812203843354" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>replicas：mode是replicated时，需要此参数配置具体运行的节点数量</p>
</li>
<li><p>resources：配置服务器资源使用的限制</p>
</li>
<li><p>restart_policy：配置如何在退出容器时重新启动容器。</p>
</li>
<li><p><strong>rollback_config</strong>：配置在更新失败的情况下应如何回滚服务。</p>
</li>
<li><p><strong>update_config</strong>：配置应如何更新服务，对于配置滚动更新很有用。</p>
</li>
</ul>
</li>
<li><p><strong>devices</strong>：指定设备映射列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devices:</span><br><span class="line">	- &quot;&#x2F;dev&#x2F;ttyUSB:&#x2F;dev&#x2F;ttyUSB0&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>dns</strong>：自定义DNS服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure></li>
<li><p><strong>dns_search</strong>：自定义 DNS 搜索域。可以是单个值或列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure></li>
<li><p><strong>entrypoint</strong>：覆盖默认容器的entrypoint</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entrypoint:&#x2F;code&#x2F;entrypoint.sh</span><br></pre></td></tr></table></figure>

<p>也可以是以下格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20100525&#x2F;xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit&#x3D;-1</span><br><span class="line">    - vendor&#x2F;bin&#x2F;phpunit</span><br></pre></td></tr></table></figure></li>
<li><p><strong>env_file</strong>：从文件添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env_file: .env</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - .&#x2F;common.env</span><br><span class="line">  - .&#x2F;apps&#x2F;web.env</span><br><span class="line">  - &#x2F;opt&#x2F;secrets.env</span><br></pre></td></tr></table></figure></li>
<li><p><strong>environment</strong>：添加环境变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#39;true&#39;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>expose</strong>：暴露端口，但不映射到宿主机，仅可以指定内部端口为参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>extra_hosts</strong>：添加映射名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure>

<p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure></li>
<li><p><strong>healthcheck</strong>：用于检测 docker 服务是否健康运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure></li>
<li><p><strong>image</strong>：指定容器运行的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum&#x2F;influxdb</span><br><span class="line">image: example-registry.com:4000&#x2F;postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure></li>
<li><p><strong>logging</strong>：服务的日志记录</p>
<p>driver:指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>

<p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure>

<p>当达到文件限制上限，会自动删除旧得文件。</p>
<p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>network_mode</strong>：设置网络模式</p>
</li>
<li><p><strong>restart</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure></li>
<li><p><strong>secrets</strong>：存储敏感数据，例如密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: .&#x2F;my_secret.txt</span><br></pre></td></tr></table></figure></li>
<li><p><strong>security_opt</strong>：修改容器默认的schema标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure></li>
<li><p><strong>stop_grace_period</strong>：指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒 </span><br></pre></td></tr></table></figure>

<p>默认10s</p>
</li>
<li><p><strong>stop_signal</strong></p>
</li>
<li><p><strong>sysctls</strong></p>
</li>
<li><p><strong>tmpfs</strong></p>
</li>
<li><p><strong>ulimits</strong></p>
</li>
<li><p><strong>volumes</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机</title>
    <url>/2021/03/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="1、JVM架构"><a href="#1、JVM架构" class="headerlink" title="1、JVM架构"></a>1、JVM架构</h1><p>java源码通过javac编译为java字节码，java字节码是java虚拟机执行的一套代码格式，抽象了计算机的基本操作。大多数指令只有一个字节，有些操作符需要参数，导致多使用了一些字节。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="java虚拟机"></p>
<p>JVM的基础架构如上图所示：主要包含三大块：</p>
<ul>
<li>类加载器：负责动态加载JAVA类到JAVA虚拟机的内存空间。</li>
<li>运行时数据区：存储JVM运行时的所有数据。</li>
<li>执行引擎：提供JVM在不同平台的运行能力。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在JVM中运行着很多线程，一部分是程序创建来执行代码逻辑的<strong>应用线程</strong>，剩下的是JVM创建来执行后台任务的<strong>系统线程</strong>。</p>
<p>主要的系统线程：</p>
<ul>
<li>Compile：运行时将字节码编译为本地代码使用的线程。</li>
<li>GC：包含所有和GC有关的操作。</li>
<li>Period Task：JVM周期性任务调度的线程，主要包含JVM内部的采样分析。</li>
<li>Singal Dispatcher：处理OS发来的信号。</li>
<li>VM：某些操作需要等待 JVM 到达 <strong>安全点（Safe Point）</strong>，即堆区没有变化。比如：GC 操作、线程 Dump、线程挂起 这些操作都在 VM Thread 中进行。</li>
</ul>
<p>类型来分，JVM内部有两种线程：</p>
<ul>
<li>守护线程：JVM自己使用，程序也可以把自己的线程标记为守护线程<code>（public final void setDaemon(boolean on)</code>，必须在start()方法之前调用。</li>
<li>非守护线程：main方法执行的线程，也称为用户线程。</li>
</ul>
<p>只要有非守护进程运行，java程序就会继续运行，非守护都终止时，虚拟机也会自动退出。</p>
<p>守护进程不适合进行IO，计算等操作，因为守护进程在非守护进程结束自动释放，不能判断该守护进程是否完成了操作。</p>
<h1 id="2、类加载器"><a href="#2、类加载器" class="headerlink" title="2、类加载器"></a>2、类加载器</h1><p>负责动态加载类到虚拟机的内存空间。通常是按需加载，类第一次使用才加载。有了类加载器，java在运行时系统不需要知道文件与文件系统。每个java类都要由类加载器装入到内存。</p>
<p>除了定位和导入二进制文件，还验证类的正确性，为变量分配初始化内存，帮助解析符号引用。按照以下顺序完成：</p>
<ul>
<li><strong>装载：</strong>查找并装载二进制数据。</li>
<li><strong>链接：</strong>执行验证、准备、解析。<ul>
<li>验证：确保被导入类型的正确性。</li>
<li>准备：为类变量分配内存，并将其初始化为默认值。</li>
<li>解析：把类型中的符号引用转化为直接引用。</li>
</ul>
</li>
<li><strong>初始化：</strong>把类变量初始化为正确的初始值。</li>
</ul>
<h2 id="1-装载"><a href="#1-装载" class="headerlink" title="1.装载"></a>1.装载</h2><p>多个类装载器，应用程序可以使用两种类装载器：</p>
<ul>
<li><strong>Bootstrap ClassLoader</strong>：原生C编写，不继承自java.lang.ClassLoder。加载核心类库，启动类加载器通常使用某种默认的方式从本地磁盘中加载，包括java API。</li>
<li><strong>Extention Classloader</strong>：用来在<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code> ,或 <code>java.ext.dirs</code> 中指明的目录中加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。</li>
<li><strong>Application Classloader</strong>：根据应用程序的类路径java.class.path或者CLASSPATH加载类。一般来说，java应用的类它加载。可以通过<code>ClassLoader.getSystemClassLoader()</code> 来获取它。</li>
<li><strong>自定义类加载器</strong>：继承java.lang.ClassLoder来实现自己的类加载器。</li>
</ul>
<p><strong>全盘负责双亲委托机制：</strong></p>
<p>一个JVM系统至少3种类加载器，如何平配合工作？通过全盘负责双亲委托机制来协调类加载器。</p>
<ul>
<li>全盘负责：当一个ClassLoder装载一个类时，除非显示的使用另一个，该类及其所依赖的类都用这个装载。</li>
<li>双亲委托机制：指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。</li>
</ul>
<p>全盘负责双亲委托是java推荐的机制，不是强制。实现自己的类加载器，保持机制，重写findClass(name)方法；破坏此机制，重写loadClass(name)方法。</p>
<p><strong>装载入口：</strong></p>
<p>所有java虚拟机实现必须在每个类或者接口首次主动使用时初始化。以下情况符合主动使用的要求：</p>
<ul>
<li>创建某个类的新实例（new、反射、克隆、序列化）</li>
<li>调用某个类的静态方法</li>
<li>使用类或者接口的静态字段，或对该字段赋值。final</li>
<li>调用java API 的某些反射方法时。</li>
<li>初始化某个类的子类时、</li>
<li>当虚拟机启动时被表明为自动类的类。</li>
</ul>
<p>除了以上全是被动，不会导致java类型的初始化。</p>
<p>对于接口来说，只有在此接口声明的非常量字段被使用，才会初始化，不会因为事先这个接口的子接口或者类要初始化而被初始化。</p>
<p>父类需要在子类之前初始化。当实现了接口的类被初始化时，不需要初始化父接口。然而，当实现了父接口的子类（或者拓展了父接口的子接口）被装载时，父接口也要被装载（装载但不实例化）。</p>
<h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保装载后的类型符合java语言的语义，并且不会危害整个虚拟机的完整性。</p>
<ul>
<li>装载时验证：检查二进制数据保证是预期格式。确保除object外的每个类都有父类，确保该类的父类已经被装载。</li>
<li>正式验证阶段：检查final类不能有子类，确保 final 方法不被覆盖、确保在类型和超类型之间没有不兼容的方法声明(比如拥有两个名字相同的方法，参数在数量、顺序、类型上都相同，但返回类型不同)。</li>
<li>符号引用的验证：当虚拟机搜寻一个被符号引用的元素(类型、字段或方法)时，必须首先确认该元素存在。如果虚拟机发现元素存在，则必须进一步检查引用类型有访问该元素的权限。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>虚拟机为类变量分配内存，设置默认初始值。初始化阶段之前，类变量都没有被初始化为真正的初始值。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
</tr>
<tr>
<td align="center">blooean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>直白一点就是，将符号引用转化为直接引用，比如，将package com.source….转化为物理地址。</p>
<p>在类型的常量池中寻找类、接口、字段和方法的符号占用，把这些符号引用替换成直接引用的过程。</p>
<ul>
<li>类、接口的解析：判断所要转化成的直接引用是数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li>
<li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</li>
</ul>
<h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h2><p>所有类变量（静态量）初始化语句和类型的静态初始化器都被java编译器收集在一起，放到一个特殊的方法。对于类来说，方法叫初始化方法；对于接口来说，称为接口初始化方法。在类和接口的class文件中，称为&lt;clinit&gt;</p>
<ol>
<li>存在直接父类且父类没被初始化，先初始化直接父类。</li>
<li>类存在一个类初始化方法， 执行此方法。</li>
</ol>
<p>递归执行，所以第一个初始化的类一定是object。</p>
<p>虚拟机须确保初始化过程正确同步。如果多个县城需要初始化一个类，仅仅允许一个，其余的等待。</p>
<h3 id="Clinit方法"><a href="#Clinit方法" class="headerlink" title="Clinit方法"></a>Clinit方法</h3><ul>
<li>对于静态变量和静态初始化语句来说：执行的顺序和它们在类或接口中出现的顺序有关。</li>
<li><strong>并非所有的类都需要在它们的<code>class</code>文件中拥有<code>&lt;clinit&gt;()</code>方法，</strong> 如果类没有声明任何类变量，也没有静态初始化语句，那么它就不会有<code>&lt;clinit&gt;()</code>方法。如果类声明了类变量，但没有明确的使用类变量初始化语句或者静态代码块来初始化它们，也不会有<code>&lt;clinit&gt;()</code>方法。如果类仅包含静态<code>final</code>常量的类变量初始化语句，而且这些类变量初始化语句采用编译时常量表达式，类也不会有<code>&lt;clinit&gt;()</code>方法。**只有那些需要执行Java代码来赋值的类才会有<code>&lt;clinit&gt;()</code>**’</li>
<li><code>final</code>常量：Java虚拟机在使用它们的任何类的常量池或字节码中直接存放的是它们表示的常量值。</li>
</ul>
<h1 id="3、内存模型"><a href="#3、内存模型" class="headerlink" title="3、内存模型"></a>3、内存模型</h1><p>运行时数据区保存JVM在运行过程中产生的数据。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%202%20%E9%A1%B5.png" alt="java虚拟机-第 2 页"></p>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>各线程共享的内存区域，是虚拟机管理内存区域最大的一块。几乎所有的对象实例和数组实例都是在堆上分配，但是对着JIT编译器以及逃逸分析技术的发展，也可能被优化为在栈上分配。</p>
<p>还包含字符串字面量常量池。包含一个新生代，一个老年代。</p>
<p>新生代三个区，大部分对象在Eden去生成，survivor总有一个是空的。</p>
<p>老年代保存一些生命周期比较长的对象，当一个对象经过对此GC还没被回收，将移动到老年代。</p>
<h2 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h2><p>方法区的数据所有线程共享，为安全使用方法区的数据，需要注意线程安全问题。</p>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>主要保存类级别的数据，包括：</p>
<ul>
<li>ClassLoader Reference</li>
<li>Runtime Constant Pool<ul>
<li>数字常量</li>
<li>类属性引用</li>
<li>方法引用</li>
</ul>
</li>
</ul>
<p>在JVM1.8之前，方法区的实现为永久代。经常内存溢出。在JVM1.8方法区的实现改为<strong>元空间</strong>，元空间是在Native的一块内存空间。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>JVM线程启动时，分配独立的运行时栈，来保存方法调用。每个方法调用，都会入栈一个栈帧。</p>
<p>栈帧保存三个引用：<strong>本地变量表</strong>，<strong>操作数帧</strong>和当前方法<strong>所属类的运行时常量池</strong>。由于本地变量表和操作数栈的大小都在编译时确定，所以栈帧的大小是固定的。</p>
<p>被调用的方法返回或抛出异常，栈帧弹出。栈帧内的数据是线程安全的。</p>
<p>栈大小可以动态拓展，但是如果一个线程需要栈的大小超出允许的大小，抛出<code>StackOverflowError</code>。</p>
<h2 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h2><p>对于每个JVM线程，线程启动时有一个独立的PC计数器，保存当前执行的代码地址。如果是Native方法， PC的值是NULL。一旦执行完成，PC计数器会被更新为下一个需要执行代码的地址。</p>
<h2 id="Native-Method-Stack"><a href="#Native-Method-Stack" class="headerlink" title="Native Method Stack"></a>Native Method Stack</h2><p>本地方法栈执行的是native方法。native方法就是C++写的方法。</p>
<h2 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h2><p>可以直接调用的内存。堆外内存。D可以使用堆外内存。</p>
<p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为 <strong>避免了在 Java 堆和 Native 堆中来回复制数据</strong>。</p>
<h1 id="4、垃圾收集"><a href="#4、垃圾收集" class="headerlink" title="4、垃圾收集"></a>4、垃圾收集</h1><h2 id="对象存活检测"><a href="#对象存活检测" class="headerlink" title="对象存活检测"></a>对象存活检测</h2><p>垃圾回收器回收内存之前，先要确定哪些对象是活的，哪些对象可以回收。</p>
<ul>
<li><p>引用计数算法</p>
<p>对象添加引用计数器，引用时+1,引用失效-1。致命缺陷就是两个对象相互引用导致两个都无法回收。</p>
</li>
<li><p>根搜索算法</p>
<p>实际上是追踪从根节点开始的引用图。通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为<strong>引用链</strong>，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p>在根搜索算法追踪的过程，起点是GC Root，根据JVM的实现不同而不同，但是总会包含以下几个方面（堆外引用）：</p>
<ul>
<li>虚拟机栈中引用的对象 </li>
<li>方法区中的类静态属性引用的变量</li>
<li>方法区中的常量引用的变量</li>
<li>本地方法JNI的引用对象</li>
</ul>
<p>从GC Root开始的引用图，有向图，节点时对象，边是引用类型。JVM分为四种引用类型：<strong>强引用，软引用，弱引用，虚引用。</strong></p>
<p>一个对象的引用类型有多个，如何确定回收策略：</p>
<ul>
<li>单条引用链以链上最弱的一个引用类型来决定；</li>
<li>多条引用链以多个单条引用链中最强的一个引用类型来决定；</li>
</ul>
<p>在引用图，如果一个节点没有任何路径可达，确定回收。</p>
<p><strong>强引用：</strong></p>
<p>在java中普遍存在，类似于<code>Object o = new Object;</code>和其他引用的区别是：强引用禁止引用目标被GC收集，其他引用不禁止。</p>
<p><strong>软引用：</strong></p>
<p><strong>JVM 的实现需要在抛出 OutOfMemoryError 之前清除 SoftReference</strong>，但在其他的情况下可以选择清理的时间或者是否清除它们。</p>
<p>有用但不是必须，使用<code>java.lang.red.SoftReferencr</code>类表示，这个特性很适合做缓存，比如：网页缓存，图片缓存。</p>
<p><strong>弱引用：</strong></p>
<p>垃圾收集器在GC的时候会回收所有的弱引用，如果该弱引用和引用队列相关联，他会把该弱引用加入到队列。</p>
<p><strong>虚引用：</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1、复制回收"><a href="#1、复制回收" class="headerlink" title="1、复制回收"></a>1、复制回收</h3><p>可用内存等分两份，同一时刻值使用其中一份。用完后将还存活的对象赋值到另一份，然后将这一份清空。能够有效避免内存碎片，但是减低了内存使用率。</p>
<p>解决了标记清除回收可能会产生大量不连续内存的问题。</p>
<h3 id="2、标记清除算法"><a href="#2、标记清除算法" class="headerlink" title="2、标记清除算法"></a>2、标记清除算法</h3><p>先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后恢复运行线程。标记清除后会产生大量不连续的内存碎片，造成空间浪费。</p>
<h3 id="3、标记整理算法"><a href="#3、标记整理算法" class="headerlink" title="3、标记整理算法"></a>3、标记整理算法</h3><p>和标记清除相似，不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而集成空闲时间。</p>
<h3 id="4、增量回收"><a href="#4、增量回收" class="headerlink" title="4、增量回收"></a>4、增量回收</h3><p>将程序拥有的内存空间分成若干区。程序的存储对象会分布在分区中，每次只对其中一个分区进行回收，从而避免程序全部运行线程暂停来进行回收，允许部分线程在不影响回收行为的情况下保持运行，降低回收时间，增加线程响应速度。</p>
<h3 id="5、分代回收"><a href="#5、分代回收" class="headerlink" title="5、分代回收"></a>5、分代回收</h3><p>对象拥有不同的生命周期，不同生命周期的对象采用不同的回收算法，以提高效率。</p>
<p><strong>记忆集：</strong></p>
<p>对象C在新生代，只被一个在老年代的D引用。如果运行新生代GC，要确定C是否被堆外引用，需要遍历老年代，代价比较大。JVM在对象引用的时候，会有个记忆集，记录从老年代到新生代的引用关系，并把记忆集中的老年代作为GC ROOT构建索引图，这样在新生代GC的时候就不需要遍历老年代。</p>
<p>但是记忆集有缺点：C &amp; D 其实都可以进行回收，但是由于记忆集的存在，不会将 C 回收。这里其实有一点 <strong>空间换时间</strong> 的意思。不过无论如何，它依然确保了垃圾回收所遵循的原则：<strong>垃圾回收确保回收的对象必然是不可达对象，但是不确保所有的不可达对象都会被回收</strong>。</p>
<h2 id="垃圾回收触发条件"><a href="#垃圾回收触发条件" class="headerlink" title="垃圾回收触发条件"></a>垃圾回收触发条件</h2><h3 id="1、堆内内存"><a href="#1、堆内内存" class="headerlink" title="1、堆内内存"></a>1、堆内内存</h3><p>对于HotSpot VM实现，GC只有两大种：</p>
<ol>
<li>Partial GC：并不收集整个GC堆<ul>
<li>Young GC：只收集新生代的GC</li>
<li>Old GC：只收集老年代的GC。只有 CMS的 Concurrent Collection 是这个模式</li>
<li>Mixed GC：收集整个 Young Gen 以及部分 Old Gen 的 GC。只有 G1 有这个模式</li>
</ul>
</li>
<li>Full GC：收集整个堆，包括 Young Gen、Old Gen、Perm Gen（如果存在的话）等所有部分的 GC 模式。</li>
</ol>
<p>最简单的分代式GC策略，按照HotSpot的serial GC的实现看，触发条件是：</p>
<ul>
<li>Young GC：新生代的eden区分配满的时候触发，把eden区存货的对象复制到一个Survivor区，当这个Survivor区满时，存活的对象被复制到另一个survivor区。</li>
<li>Full GC<ul>
<li>当准备要触发一次 Young GC 时，如果发现之前 Young GC 的平均晋升大小比目前 Old Gen剩余的空间大，则不会触发 Young GC 而是转为触发 Full GC</li>
<li>如果有 Perm Gen 的话，要在 Perm Gen分配空间但已经没有足够空间时</li>
<li><code>System.gc()</code></li>
<li>Heap dump</li>
</ul>
</li>
</ul>
<p>并发 GC 的触发条件就不太一样。以 CMS GC 为例，它主要是定时去检查 Old Gen 的使用量，当使用量超过了触发比例就会启动一次 GC，对 Old Gen做并发收集。</p>
<h3 id="2、堆外内存"><a href="#2、堆外内存" class="headerlink" title="2、堆外内存"></a>2、堆外内存</h3><p>DirectByteBuffer的引用是直接分配在堆的old区，回收时机是在FULLGC，因此需要避免频繁的分配directByteBuffer，这样就很容易导致Native Memory溢出。</p>
<p>DirectByteBuffer申请的直接内存，不在G范围内，无法自动回收。JDK提供一种机制，可以为堆内存对象注册一个钩子函数(其实就是实现 <code>Runnable</code> 接口的子类)，当堆内存对象被GC回收的时候，会回调run方法，我们可以在这个方法中执行释放 <code>DirectByteBuffer</code> 引用的直接内存，即在run方法中调用 <code>Unsafe</code> 的 <code>freeMemory</code> 方法。注册是通过<code>sun.misc.Cleaner</code> 类来实现的。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>内存回收的具体实现，以下为7种不同分代的收集器，有连线表示可以搭配使用。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%203%20%E9%A1%B5.png" alt="java虚拟机-第 3 页"></p>
<h3 id="1、Serial-收集器"><a href="#1、Serial-收集器" class="headerlink" title="1、Serial 收集器"></a>1、Serial 收集器</h3><p>最基本的收集器，单线程。是JVM在client模式下的默认新生代收集器。优点是：简单高效。此收集器没有线程交互的开销，效率高。在用户桌面的场景下，分配给JVM的内存不会太多，停顿时间在几十到一百多毫秒之间，只要不频繁收集，完全可以接受。</p>
<h3 id="2、Serial-Old收集器"><a href="#2、Serial-Old收集器" class="headerlink" title="2、Serial Old收集器"></a>2、Serial Old收集器</h3><p>Serial的老年代版本，单线程，采用“标记-整理算法”进行垃圾回收。</p>
<h3 id="3、ParNew-收集器"><a href="#3、ParNew-收集器" class="headerlink" title="3、ParNew 收集器"></a>3、ParNew 收集器</h3><p>Serial的多线程版本，是许多运行在Server模式下的默认新生代GC，主要与CMS收集器配合工作。</p>
<h3 id="4、Parallel-Scavenge-收集器"><a href="#4、Parallel-Scavenge-收集器" class="headerlink" title="4、Parallel Scavenge 收集器"></a>4、Parallel Scavenge 收集器</h3><p>新生代GC，多线程收集器。更关注可控制的吞吐量，吞吐量等于运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）。</p>
<h3 id="5、Parallel-Old"><a href="#5、Parallel-Old" class="headerlink" title="5、Parallel Old"></a>5、Parallel Old</h3><p>是Parallel Scavenge的老年代版本，多线程，通常与Parallel Scavenge配合使用。</p>
<h3 id="6、CMS-收集器"><a href="#6、CMS-收集器" class="headerlink" title="6、CMS 收集器"></a>6、CMS 收集器</h3><p>目标是获取最短停顿时间，采用“标记-清除”算法，运行在老年代，包含以下步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>其中初始标记和重新标记仍然需要stop the world。初始标记仅仅标记GC ROOT能直接关联的对象，并发标记是为了记性GC ROOT Tracing过程，重新标记是为了修正并发标记期间，因为用户程序继续运行而导致标记变动的那部分对象的标记记录。</p>
<p>最耗时的是并发表标记和并发清除，收集线程和用户线程一起工作，总体来说，CMS GC回收和用户程序并行。优点是并发收集、低停顿，但是有三个缺点：</p>
<ul>
<li>对CPU资源很敏感：并发阶段不停用用户进程，但是占用线程导致程序变慢。</li>
<li>不能处理浮动垃圾：浮动垃圾就是在并发标记阶段，用户程序运行产生新的垃圾，这部分垃圾在标记后，CMS无法在当次集中处理，只能在下一次GC处理，这部分垃圾就称为浮动垃圾。</li>
</ul>
<p>正是由于在垃圾收集阶段程序还需要运行，即还需要预留足够的内存空间供用户使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎填满才进行收集，需要预留一部分空间提供并发收集时程序运作使用。要是 CMS 预留的内存空间不能满足程序的要求，这是 JVM 就会启动预备方案：<strong>临时启动 Serial Old 收集器来收集老年代</strong>，这样停顿的时间就会很长。</p>
<h3 id="6、G1收集器"><a href="#6、G1收集器" class="headerlink" title="6、G1收集器"></a>6、G1收集器</h3><p>比GMS有很大改进：</p>
<ul>
<li>标记整理算法：采用标记整理算法实现</li>
<li>增量回收模式：将Heap分割成多个Region，并在后台维护一个优先列表，每次根据允许的时间，优先回收垃圾最多的区域。</li>
</ul>
<p>因此G1收集器可以实现在基本不牺牲吞吐量的情况下完成低停顿的内存回收，这是正式由于他极力的避免全区域回收。</p>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th align="center">垃圾收集器</th>
<th align="center">特性</th>
<th align="center">算法</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">串行</td>
<td align="center">复制</td>
<td align="center">高效：无线程切换</td>
<td align="center">无法利用多核CPU</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">并行</td>
<td align="center">复制</td>
<td align="center">可利用多核CPU、唯一能与CMS配合的并行收集器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">并行</td>
<td align="center">复制</td>
<td align="center">高吞吐量</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">串行</td>
<td align="center">标记整理</td>
<td align="center">高效</td>
<td align="center">无法利用多核CPU</td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">并行</td>
<td align="center">标记整理</td>
<td align="center">高吞吐量</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">并行</td>
<td align="center">标记清除</td>
<td align="center">低停顿</td>
<td align="center">CPU敏感，浮动垃圾，内存碎片</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">并行</td>
<td align="center">增量回收</td>
<td align="center">低停顿。高吞吐量</td>
<td align="center">内存使用效率低：分区导致内存不能充分使用</td>
</tr>
</tbody></table>
<h1 id="5、Java分配机制"><a href="#5、Java分配机制" class="headerlink" title="5、Java分配机制"></a>5、Java分配机制</h1><p>java中符合“编译时可知，运行时不可变”要求的主要是静态方法和私有方法。因此适合在类加载时进行解析。</p>
<p>java虚拟机中有四种方法调用指令：</p>
<ul>
<li>invokestatic：调用静态方法。</li>
<li>invokespecial：调用实例构造方法，私有方法和super</li>
<li>invokeinterface：调用接口方法</li>
<li>invokevirtual：调用以上指令不能调用的方法（虚方法）。</li>
</ul>
<p>只要能被static和special指令调用的方法，都可以在解析阶段唯一确定调用版本，符合条件的有：静态方法，私有方法，实例构造器，父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法， 反之称为虚方法，（final除外）。</p>
<blockquote>
<p>虽然final方法是使用virtual指令来调用，但是无法被覆盖，多态的选择是唯一的，所以是一种虚方法。</p>
</blockquote>
<h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><blockquote>
<p>对于类字段的访问也采用静态分派</p>
</blockquote>
<p><code>People man =  new Man()</code></p>
<p>静态分派主要针对重载，方法调用时如何选择。在上面的代码，Peopel被称为变量的引用类型，Man称为变量的实际类型。静态类型在编译时可知，动态类型在运行时可知。</p>
<p>编译器在重载时候通过参数的静态类型而不是实际类型作为判断依据。并且静态类型咋编译时可知，所以编译器根据重载的参数的静态类型进行方法选择。</p>
<blockquote>
<p>在某些情况下有多个重载，那编译器如何选择呢？ 编译器会选择”最合适”的函数版本，那么怎么判断”最合适“呢？越接近传入参数的类型，越容易被调用。</p>
</blockquote>
<h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><p>主要针对重写，使用virtual指令调用，virtual指令多态查找过程：</p>
<ul>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果权限校验不通过，返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常。</li>
</ul>
<h2 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h2><p>动态分配很繁琐，而且动态分派的方法版本的选择需要考虑运行时咋类的方法数据中搜索合适的目标方法，因为在虚拟机的实现中基于性能的考虑，在方法区中建立一个虚方法表来提高性能。</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210324125440920.png" alt="image-20210324125440920"></p>
<p>虚方法表中存放各个方法的实际入口地址。如果某个方法在子类中没有重写，那么子类的虚方法表里的入口和父类入口一致，如果子类重写了这个方法，那么子类方法表中的地址会被替换成子类实现版本的入口地址。</p>
<h1 id="6、String常量池"><a href="#6、String常量池" class="headerlink" title="6、String常量池"></a>6、String常量池</h1><p>常量池类似于一个JAVA系统级别提供的缓存。</p>
<p>String类型的常量池比较特殊，使用方法：</p>
<ul>
<li>直接使用双引号声明的String对象会直接存储在常量池。</li>
<li>不是使用双引号，可以使用String提供的inter方法，该方法会从字符串常量池中查询当前字符串是否存在，不存在则放入常量池。</li>
</ul>
<h2 id="Intern"><a href="#Intern" class="headerlink" title="Intern"></a>Intern</h2><p>java使用Jni调用C++实现的StringTable的Intern方法，StringTable跟java中的HashMap实现差不多，但是不能扩容。默认大小是<code>1009</code></p>
<p>要注意的是， <code>String</code> 的 <code>String Pool</code> 是一个固定大小的 <code>Hashtable</code> ，默认值大小长度是 <code>1009</code> ，如果放进 <code>String Pool</code> 的 <code>String</code> 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 <code>String.intern</code> 时性能会大幅下降。</p>
<p>JDK6中StringTable固定，但是JDK7可以通过参数指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX：StringTableSize&#x3D;99991</span><br></pre></td></tr></table></figure>

<p>在6和以前的版本，字符串的常量池存放在Perm区，7的版本中，转移到正常的Heap区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s &#x3D; new String(&quot;1&quot;);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 &#x3D; &quot;1&quot;;</span><br><span class="line">    System.out.println(s &#x3D;&#x3D; s2);</span><br><span class="line"></span><br><span class="line">    String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 &#x3D; &quot;11&quot;;</span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>JDK6：false false</li>
<li>JDK7：fale true</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s &#x3D; new String(&quot;1&quot;);</span><br><span class="line">    String s2 &#x3D; &quot;1&quot;;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s &#x3D;&#x3D; s2);</span><br><span class="line"></span><br><span class="line">    String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">    String s4 &#x3D; &quot;11&quot;;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>6：false false</li>
<li>7：false false</li>
</ul>
<p>由于7将字符串常量池放到Heap中，导致差异。</p>
<h3 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h3><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/1.png" alt="1"></p>
<p>黑色线表示String对象的内容指向，红色代表地址指向。</p>
<p>在jdk6中所有打印都是false，因为常量池在Perm中，Perm和正常的Heap是分开的，引号声明的字符串直接在常量池生成，而new出来的String存放在Heap，地址肯定不同，及时调用String.intern()方法也是没有很合关系。</p>
<h3 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h3><p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%205%20%E9%A1%B5.png" alt="java虚拟机-第 5 页"></p>
<ul>
<li>第一段代码，<code>String s3 = new String(&quot;1&quot;)+new String(&quot;1&quot;);</code>，代码生成两个最终对象，是常量池中的“1”和Heap中S3引用指向的对象。此时S3引用的对象是“11”，但是常量池没有“11”对象。</li>
<li>接下来S3.intern()是讲S3中的“11”放入常量池。但是7中的常量池不在Perm区域了，常量池中不需要再存储一份对象，可以直接存储占中的引用。这份引用指向S3的对象。引用地址是相同的。</li>
<li>最后 <code>String s4 = &quot;11&quot;;</code> 这句代码中 <code>”11”</code> 是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 <code>s3</code> 引用对象的一个引用。所以 <code>s4</code> 引用就指向和 <code>s3</code> 一样了。因此最后的比较 <code>s3 == s4</code> 是 <code>true</code> 。</li>
<li>再看 <code>s</code> 和 <code>s2</code> 对象。 <code>String s = new String(&quot;1&quot;);</code> 第一句代码，生成了2个对象。常量池中的 <code>“1”</code> 和 <code>JAVA Heap</code> 中的字符串对象。<code>s.intern();</code> 这一句是 <code>s</code> 对象去常量池中寻找后发现 <code>“1”</code> 已经在常量池里了。</li>
<li>接下来 <code>String s2 = &quot;1&quot;;</code> 这句代码是生成一个 <code>s2</code> 的引用指向常量池中的 <code>“1”</code> 对象。 结果就是 <code>s</code> 和 <code>s2</code> 的引用地址明显不同。</li>
</ul>
<p>接下来是第二段代码：</p>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%206%20%E9%A1%B5.png" alt="java虚拟机-第 6 页"></p>
<ul>
<li>第一段代码和第二段代码的改变就是 <code>s3.intern();</code> 的顺序是放在 <code>String s4 = &quot;11&quot;;</code> 后了。这样，首先执行 <code>String s4 = &quot;11&quot;;</code> 声明 <code>s4</code> 的时候常量池中是不存在 <code>“11”</code> 对象的，执行完毕后， <code>“11“</code> 对象是 <code>s4</code> 声明产生的新对象。然后再执行 <code>s3.intern();</code> 时，常量池中 <code>“11”</code> 对象已经存在了，因此 <code>s3</code> 和 <code>s4</code> 的引用是不同的。</li>
<li>二段代码中的 <code>s</code> 和 <code>s2</code> 代码中，<code>s.intern();</code>，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码<code>String s = new String(&quot;1&quot;);</code> 的时候已经生成 <code>“1”</code> 对象了。下边的 <code>s2</code> 声明都是直接从常量池中取地址引用的。 <code>s</code> 和 <code>s2</code> 的引用地址是不会相等的。</li>
</ul>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>对intern和常量池都做了一定的修改，主要包括：</p>
<ul>
<li>将String常量池从Perm区移动到了Heap区</li>
<li>String.intern方法时，如果heap中存在对象，将会直接保存对象的引用，而不是重新创建对象。</li>
</ul>
<h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int MAX &#x3D; 1000 * 10000;</span><br><span class="line">static final String[] arr &#x3D; new String[MAX];</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Integer[] DB_DATA &#x3D; new Integer[10];</span><br><span class="line">    Random random &#x3D; new Random(10 * 10000);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; DB_DATA.length; i++) &#123;</span><br><span class="line">        DB_DATA[i] &#x3D; random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">	long t &#x3D; System.currentTimeMillis();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; MAX; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;arr[i] &#x3D; new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span><br><span class="line">         arr[i] &#x3D; new String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	System.out.println((System.currentTimeMillis() - t) + &quot;ms&quot;);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一条是使用 intern，一条是未使用 intern。</p>
<p>通过上述结果，我们发现不使用 <code>intern</code> 的代码生成了 <code>1000w</code> 个字符串，占用了大约 <code>640m</code> 空间。 使用了 <code>intern</code> 的代码生成了 <code>1345</code> 个字符串，占用总空间 <code>133k</code> 左右。其实通过观察程序中只是用到了 <code>10</code> 个字符串，所以准确计算后应该是正好相差 <code>100w</code> 倍。虽然例子有些极端，但确实能准确反应出 intern 使用后产生的巨大空间节省。</p>
<p> <code>intern</code> 方法后时间上有了一些增长。这是因为程序中每次都是用了 <code>new String</code> 后，然后又进行 <code>intern</code> 操作的耗时时间，这一点如果在内存空间充足的情况下确实是无法避免的，但我们平时使用时，内存空间肯定不是无限大的，不使用 <code>intern</code> 占用空间导致 <code>jvm</code> 垃圾回收的时间是要远远大于这点时间的。</p>
<h1 id="7、对象生命周期"><a href="#7、对象生命周期" class="headerlink" title="7、对象生命周期"></a>7、对象生命周期</h1><h2 id="类实例化"><a href="#类实例化" class="headerlink" title="类实例化"></a>类实例化</h2><p>实例化类的四个途径：</p>
<ul>
<li>new</li>
<li>调用class或者java.lang.reflect.Constructor对象的NewInstance</li>
<li>调用任何现有对象的clone</li>
<li>通过<code>java.io.ObjectInputStream.getObject()</code>反序列化。</li>
</ul>
<p>隐含的实例化：</p>
<ul>
<li>保存命令行参数的String对象</li>
<li>虚拟机装载的每个类，都会暗中实例化一个class对象来代表这个类型。</li>
<li>当Java虚拟机装载了在常量池中包含<code>CONSTANT_String_info</code>入口的类的时候，它会创建新的<code>String</code>对象来表示这些常量字符串。</li>
<li>执行包含字符串连接操作符的表达式会产生新的对象。</li>
</ul>
<h2 id="垃圾收集和对象的终结"><a href="#垃圾收集和对象的终结" class="headerlink" title="垃圾收集和对象的终结"></a>垃圾收集和对象的终结</h2><p>程序可以分配内存但不能释放内存，一个对象不再为程序引用，虚拟机必须回收那部分内存。</p>
<h2 id="卸载类"><a href="#卸载类" class="headerlink" title="卸载类"></a>卸载类</h2><p>虚拟机中类的生命周期和对象的生命周期相似。当程序不再使用某个类的时候，可以选择卸载他们。</p>
<p>虚拟机通过判断类是否在被引用来实现垃圾收集。判断动态装载类的Class实例在正常的垃圾收集过程中是否可触及有两种方式：</p>
<ul>
<li>如果实例非Class实例的明确引用。</li>
<li>如果在堆中还存在一个可触及对象，在方法区中它的类型数据指向一个Class实例。</li>
</ul>
<p><img src="https://nextlab.oss-cn-shanghai.aliyuncs.com/img/image-20210324173320715.png" alt="image-20210324173320715"></p>
]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列</title>
    <url>/2020/03/05/Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1、Spring"><a href="#1、Spring" class="headerlink" title="1、Spring"></a>1、Spring</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul>
<li>Spring：春天—-&gt;给软件行业带来了春天！</li>
<li>2002，首次推出了Spring框架的雏形：interface21框架！</li>
<li>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富内涵，于2004年3月24日，发布了1.0正式版。</li>
<li><strong>Rod Johnson</strong>，Spring Framework创始人，著名作者。很难想象其学历，真的让好多人大吃一惊，他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。</li>
<li>spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。</li>
<li><strong>SSH：Struct2+Spring+Hibernate!</strong></li>
<li><strong>SSM：SpringMVC+Spring+Mybatis!</strong></li>
</ul>
<p>​    </p>
<p>官网：<a href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>Github：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<p>Maven仓库：导入webmvc包会自动导入相关依赖；jdbc用于和Mybatis整合。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li><p>Spring是一个开源的免费的框架（容器）！</p>
</li>
<li><p>Spring是一个轻量级的、非入侵式的框架！</p>
</li>
<li><p>控制反转（IOC）、面向切面编程（AOP）！</p>
</li>
<li><p>支持事务的处理，对框架整合的支持！</p>
<p><strong>总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程的框架！</strong></p>
</li>
</ul>
<h3 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h3><p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185352.png" alt="image-20200102001447503"></p>
<h3 id="1-4-拓展"><a href="#1-4-拓展" class="headerlink" title="1.4 拓展"></a>1.4 拓展</h3><p>在Spring的官网有这个介绍：现代化的java开发！说白了就是基于Spring的开发！</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185356.png" alt="image-20200102001823229"></p>
<ul>
<li>Spring Boot<ul>
<li>一个快速开发的脚手架。</li>
<li>基于Spring Boot可以快速的开发单个微服务。</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>SpringCloud是基于SpringBoot实现的。</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring以及SpringMVC！承上启下的作用。</p>
<p><strong>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”。</strong></p>
<h2 id="2、-IOC理论推导"><a href="#2、-IOC理论推导" class="headerlink" title="2、 IOC理论推导"></a>2、 IOC理论推导</h2><p>1.UserDao接口</p>
<p>2.UserDaoImpl实现类</p>
<p>3.UserService业务接口</p>
<p>4.UserServiceImpl业务实现类</p>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码!如果程序代码量十分大，修改一次的成本代价十分昂贵！</p>
<p>我们使用一个Set接口实现，已经发生了革命性的变化！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用set进行动态实现值的注入！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！</li>
</ul>
<p>这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注在业务的实现上。这是IOC的原型！</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185402.png" alt="image-20200102111735712"></p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185410.png" alt="image-20200102111753076"></p>
<h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p><strong>控制反转IOC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IOC的一种方法，</strong>也有人认为DI是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入（Dependency Injection,DI）</strong>。</p>
<h2 id="3、-Hello-Spring"><a href="#3、-Hello-Spring" class="headerlink" title="3、 Hello Spring"></a>3、 Hello Spring</h2><p>beans.xml官网配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>bean对象添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoMysqlImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;oracleImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoOracleImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;UserServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ref：引用Spring容器中已经创建好的对象</span></span><br><span class="line"><span class="comment">        value：具体的值，基本数据类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mysqlImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析beans.xml文件，生成管理相应的Bean对象</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="comment">//getBean:参数即为spring配置文件中bean的id</span></span><br><span class="line">Hello hello = (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(hello.toString());</span><br></pre></td></tr></table></figure>

<h3 id="思考问题？"><a href="#思考问题？" class="headerlink" title="思考问题？"></a><strong>思考问题</strong>？</h3><ul>
<li><p>Hello对象是谁创建的？</p>
<p>hello对象是由Spring创建的。</p>
</li>
<li><p>Hello对象的属性是怎么设置的？</p>
<p>hello对象的属性是由Spring容器设置的。</p>
</li>
</ul>
<p>这个过程就叫做控制反转：</p>
<p>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。</p>
<p>反转：程序本身不创建对象，而变成被动的接收对象。</p>
<p>依赖注入：就是利用set方法来进行注入。</p>
<p>IoC是一种编程思想，由主动的编程编程被动的接收。</p>
<p>可以通过new ClassPathXmlApplicationContext去浏览一下底层源码。</p>
<p><strong>OK，到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IoC，一句话搞定：对象由Spring来创建，管理，装配！</strong></p>
<p>IDEA快捷创建beans.xml文件，自动导入spring配置信息：</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185416.png" alt="image-20200102152125077"></p>
<h2 id="4、-IoC创建对象的方式"><a href="#4、-IoC创建对象的方式" class="headerlink" title="4、 IoC创建对象的方式"></a>4、 IoC创建对象的方式</h2><ol>
<li><p>使用无参构造创建对象，默认方式！</p>
</li>
<li><p>假设我们要使用有参构造创建对象。</p>
<p>1.下标赋值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种，下标赋值！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.类型赋值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二种，通过类型创建，不建议使用，重复类型难以分辨--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大憨批&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.参数名赋值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种，直接通过参数名来设置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;臭憨批&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</p>
<h2 id="5、-Spring配置"><a href="#5、-Spring配置" class="headerlink" title="5、 Spring配置"></a>5、 Spring配置</h2><h3 id="5-1-别名"><a href="#5-1-别名" class="headerlink" title="5.1 别名"></a>5.1 别名</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--别名，如果添加了别名，我们也可以使用别名获取到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-Bean的配置"><a href="#5-2-Bean的配置" class="headerlink" title="5.2 Bean的配置"></a>5.2 Bean的配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id:bean的唯一标识符，相当于我们学的对象名；</span></span><br><span class="line"><span class="comment">    class：bean对象所对应的全限定名：包名+类名；</span></span><br><span class="line"><span class="comment">    name：也是别名，可以同时取多个别名，逗号分割</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2,u2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-import"><a href="#5-3-import" class="headerlink" title="5.3 import"></a>5.3 import</h3><p>这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个。</p>
<p>假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！</p>
<ul>
<li>张三</li>
<li>李四</li>
<li>王五</li>
<li>applicationContext.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans2.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans3.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用的时候，直接使用总的配置就可以了。</p>
<h2 id="6、-依赖注入"><a href="#6、-依赖注入" class="headerlink" title="6、 依赖注入"></a>6、 依赖注入</h2><h3 id="6-1-构造器注入"><a href="#6-1-构造器注入" class="headerlink" title="6.1 构造器注入"></a>6.1 构造器注入</h3><p>之前已经介绍过。</p>
<h3 id="6-2-Set方式注入【重点】"><a href="#6-2-Set方式注入【重点】" class="headerlink" title="6.2 Set方式注入【重点】"></a>6.2 Set方式注入【重点】</h3><ul>
<li>依赖注入：Set注入！<ul>
<li>依赖：bean对象的创建依赖于容器！</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<p>【环境搭建】</p>
<ol>
<li><p>复杂类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>真实测试对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一种，普通值注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    <strong>完善注入：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;address&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.Address&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;student&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span><br><span class="line">        &lt;!--第一种，普通值注入，value--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;憨批&quot;</span>/&gt;</span><br><span class="line">        &lt;!--第二种，Bean注入，ref--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;address&quot;</span> ref=<span class="string">&quot;address&quot;</span>/&gt;</span><br><span class="line">        &lt;!--数组注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;books&quot;</span>&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;红楼梦&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;西游记&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;水浒传&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;三国演义&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--List注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;hobbies&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;听歌&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;敲代码&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;看电影&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--Map--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;身份证&quot;</span> value=<span class="string">&quot;1555555555&quot;</span>/&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;银行卡&quot;</span> value=<span class="string">&quot;5555555555&quot;</span>/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--Set--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;games&quot;</span>&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;lol&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;wow&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--<span class="keyword">null</span>--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;wife&quot;</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">null</span>/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--Properties--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">&quot;url&quot;</span>&gt;jdbc:mysql:<span class="comment">//localhost:3306/news&lt;/prop&gt;</span></span><br><span class="line">                &lt;prop key=&quot;root&quot;&gt;root&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-3-拓展方式注入"><a href="#6-3-拓展方式注入" class="headerlink" title="6.3 拓展方式注入"></a>6.3 拓展方式注入</h3><p>我们可以使用c和p命令空间进行注入：</p>
<p>使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;憨批&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--c命名空间注入，通过构造器注入：construct-args--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;userBeans.xml&quot;</span>);</span><br><span class="line">    User user = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：p和c命名空间不能直接使用，需要导入xml约束！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-bean的作用域"><a href="#6-4-bean的作用域" class="headerlink" title="6.4 bean的作用域"></a>6.4 bean的作用域</h3><ol>
<li><p>代理模式（Spring默认机制）：get到的都是同一个对象！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;憨批&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>原型模式：每次从容器中get的时候，都会产生一个新的对象！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;憨批&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其余的request、session、application、这些个只能在web开发中使用。</p>
</li>
</ol>
<h2 id="7、-Bean的自动装配"><a href="#7、-Bean的自动装配" class="headerlink" title="7、 Bean的自动装配"></a>7、 Bean的自动装配</h2><ul>
<li>自动装配是Spring满足bean依赖的一种方式！</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性！</li>
</ul>
<p>在Spring中有三种装配的方式：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的自动装配bean</li>
</ol>
<h3 id="7-1-测试"><a href="#7-1-测试" class="headerlink" title="7.1 测试"></a>7.1 测试</h3><p>环境搭建：一个人有两个宠物！</p>
<h3 id="7-2-ByName自动装配"><a href="#7-2-ByName自动装配" class="headerlink" title="7.2 ByName自动装配"></a>7.2 ByName自动装配</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    byName:会自动在容器上下文中查找和自己对象set方法后面的值对应的beanid！</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-ByType自动装配"><a href="#7-3-ByType自动装配" class="headerlink" title="7.3 ByType自动装配"></a>7.3 ByType自动装配</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean！必须保证类型全局唯一。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨批&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！</li>
<li>byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！</li>
</ul>
<h3 id="7-4-使用注解实现自动装配"><a href="#7-4-使用注解实现自动装配" class="headerlink" title="7.4 使用注解实现自动装配"></a>7.4 使用注解实现自动装配</h3><p>jdk1.5支持注解，Spring2.5开始支持注解。</p>
<p>要使用注解须知：</p>
<ol>
<li><p>导入约束：context约束。</p>
</li>
<li><p>配置注解的支持：<a href="context:annot-config/">context:annot-config/</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>@Autowired</strong></p>
<p>直接在属性上使用即可！也可以在set方式上使用！</p>
<p>使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IoC（Spring）容器中存在，且符合名字byName！</p>
<p>科普：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span>	字段标记了这个注解，说明这个字段可以为<span class="keyword">null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(<span class="meta">@Nullable</span> String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果显式定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired完成的时候，我们可以使用@Qualifier(value=”xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;dog11&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier(value=&quot;cat11&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Resource注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;cat2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>@Resource和@Autowired的区别：</p>
<ul>
<li><p>都是用来自动装配的，都可以放在属性字段上；</p>
</li>
<li><p>@Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】</p>
</li>
<li><p>@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！</p>
</li>
<li><p>执行顺序不同：@Autowired通过byType的方式实现，@Resource默认通过byName的方式实现。</p>
</li>
</ul>
<h2 id="8、-使用注解开发"><a href="#8、-使用注解开发" class="headerlink" title="8、 使用注解开发"></a>8、 使用注解开发</h2><p>在spring4之后，要使用注解开发，必须要保证aop的包导入了。</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185433.png" alt="image-20200103105725321"></p>
<p>使用注解需要导入context约束，增加注解的支持！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定要扫描的包，这个包下的注解会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>bean</p>
</li>
<li><p>属性如何注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="comment">//@Component 组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于&lt;property name=&quot;name&quot; value=&quot;小憨批&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;小憨批&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>衍生的注解</p>
<p>@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！</p>
<ul>
<li>dao【@Repository】</li>
<li>service【@Service】</li>
<li>controller【@Controller】</li>
</ul>
<p>这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean！</p>
</li>
<li><p>自动装配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-@Autowired:自动装配通过类型，名字</span><br><span class="line">	如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value&#x3D;&quot;xxx&quot;)</span><br><span class="line">-@Nullable:字段标记了这个注解，说明这个字段可以为null</span><br><span class="line">-@Resource:自动装配通过名字，类型</span><br></pre></td></tr></table></figure></li>
<li><p>作用域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于&lt;property name=&quot;name&quot; value=&quot;小憨批&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;小憨批&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>小结</p>
<p>xml与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单方便。</li>
<li>注解，不是自己的类使用不了，维护相对复杂！</li>
</ul>
<p>xml与注解最佳实践：</p>
<ul>
<li>xml用来管理bean；</li>
<li>注解只负责完成属性的注入；</li>
<li>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--指定要扫描的包，这个包下的注解会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="9、-使用java的方式配置Spring"><a href="#9、-使用java的方式配置Spring" class="headerlink" title="9、 使用java的方式配置Spring"></a>9、 使用java的方式配置Spring</h2><p>我们现在要完全不适用Spring的xml配置了，全权交给java来做！</p>
<p>javaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能。</p>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;小笨蛋&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个也会被Spring容器托管，注册到容器中，因为本来就是一个@Component</span></span><br><span class="line"><span class="comment">//@Configuration代表这是一个配置类，就和我们之前看的beans.xml</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.kuang.pojo&quot;)</span></span><br><span class="line"><span class="meta">@Import(KuangConfig2.class )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KuangConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册一个bean，就相当于我们之前写的一个bean标签</span></span><br><span class="line">    <span class="comment">//这个方法的名字，就相当于bean标签中的id属性</span></span><br><span class="line">    <span class="comment">//这个方法的返回值，就相当于bean标签中的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();<span class="comment">//就是返回要注入到bean的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载！</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(KuangConfig.class);</span><br><span class="line">        User getUser = (User) context.getBean(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">        System.out.println(getUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种纯java的配置方式，在SpringBoot中随处可见！</p>
<h2 id="10、-代理模式"><a href="#10、-代理模式" class="headerlink" title="10、 代理模式"></a>10、 代理模式</h2><p>为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP 和 SpringMVC  面试必问】</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185442.png" alt="image-20200104125508118"></p>
<h3 id="10-1-静态代理"><a href="#10-1-静态代理" class="headerlink" title="10.1 静态代理"></a>10.1 静态代理</h3><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作。</li>
<li>客户：访问代理对象的人！</li>
</ul>
<p>代码步骤：</p>
<ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东要出租房子！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.rent();</span><br><span class="line">        hetong();</span><br><span class="line">        fee();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介带你看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//签合同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hetong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收取中介费用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//房东要租房子</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理，中介帮房东租房子，但是呢？代理角色一般会有一些附属操作！</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低</li>
</ul>
<h3 id="10-2-加深理解"><a href="#10-2-加深理解" class="headerlink" title="10.2 加深理解"></a>10.2 加深理解</h3><p>代码：对应08-demo02</p>
<p>聊聊AOP</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185513.png" alt="image-20200105210505898"></p>
<h3 id="10-3-动态代理"><a href="#10-3-动态代理" class="headerlink" title="10.3 动态代理"></a>10.3 动态代理</h3><ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的。</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul>
<li>基于接口——JDK动态代理</li>
<li>基于类：cglib</li>
<li>java字节码实现：javasisit</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序</p>
<p>动态代理的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
<li>一个动态代理类代理类代理的是一个接口，一般就是对应的一类业务</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可！</li>
</ul>
<h2 id="11、-AOP"><a href="#11、-AOP" class="headerlink" title="11、 AOP"></a>11、 AOP</h2><h3 id="11-1-什么是AOP"><a href="#11-1-什么是AOP" class="headerlink" title="11.1 什么是AOP"></a>11.1 什么是AOP</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的频率。</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185518.png" alt="image-20200106085441897"></p>
<h3 id="11-2-AOP在Spring中的作用"><a href="#11-2-AOP在Spring中的作用" class="headerlink" title="11.2 AOP在Spring中的作用"></a>11.2 AOP在Spring中的作用</h3><p>==提供声明式事务；允许用户自定义切面==</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点，如日志、安全、缓存、事务等等……</li>
<li>切面（ASPECT）：横切关注点被模块化的特殊对象，即是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作，即是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知执行的“地点”的定义。</li>
<li>连接点（jointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185523.png" alt="image-20200106090325307"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：</p>
<p><img src="https://gitee.com/victor-huihui/picgo/raw/master/img/20200325185528.png" alt="image-20200106090428369"></p>
<p>即AOP在不改变原有代码的情况下，去增加新的功能。</p>
<h3 id="11-3-使用Spring实现AOP"><a href="#11-3-使用Spring实现AOP" class="headerlink" title="11.3 使用Spring实现AOP"></a>11.3 使用Spring实现AOP</h3><p>【重点】使用AOP织入，需要导入一个依赖包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>方式一：使用Spring的API接口【主要SpringAPI接口实现】</p>
<p>方式二：自定义来实现AOP【主要是切面定义】</p>
<p>方式三：使用注解实现</p>
<h2 id="12、-整合Mybatis"><a href="#12、-整合Mybatis" class="headerlink" title="12、 整合Mybatis"></a>12、 整合Mybatis</h2><p>步骤：</p>
<ol>
<li>导入相关jar包<ul>
<li>junit</li>
<li>Mybatis</li>
<li>mysql数据库</li>
<li>spring相关的</li>
<li>aop织入</li>
<li>mybatis-spring【new知识点】</li>
</ul>
</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h3 id="12-1-回忆mybatis"><a href="#12-1-回忆mybatis" class="headerlink" title="12.1 回忆mybatis"></a>12.1 回忆mybatis</h3><ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写Mapper.xml</li>
<li>测试</li>
</ol>
<h3 id="12-2-Mybatis-Spring"><a href="#12-2-Mybatis-Spring" class="headerlink" title="12.2 Mybatis-Spring"></a>12.2 Mybatis-Spring</h3><ol>
<li>编写数据源配置</li>
<li>sqlSessionFactory</li>
<li>sqlSessionTemplate</li>
<li>需要给接口加实现类</li>
<li>将自己写的实现类，注入到Spring中</li>
<li>测试</li>
</ol>
<h2 id="13、-声明式事务"><a href="#13、-声明式事务" class="headerlink" title="13、 声明式事务"></a>13、 声明式事务</h2><h3 id="13-1-回顾事务"><a href="#13-1-回顾事务" class="headerlink" title="13.1 回顾事务"></a>13.1 回顾事务</h3><ul>
<li>把一组业务当成一个业务来做：要么都成功，要么都失败。</li>
<li>事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎。</li>
<li>确保完整性和一致性。</li>
</ul>
<p>事务ADID原则：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性<ul>
<li>多个业务可能操作同一个资源，防止数据损坏</li>
</ul>
</li>
<li>持久性<ul>
<li>事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中。</li>
</ul>
</li>
</ul>
<p>13.2 Spring中的事务管理</p>
<ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要在代码中，进行事务的管理</li>
</ul>
<p>思考：</p>
<p>为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况</li>
<li>如果我们不在Spring中去配置声明式事务，我们就需要在代码中手动配置事务</li>
<li>事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">参考自javaGuide</a></p>
<h3 id="什么是Spring框架"><a href="#什么是Spring框架" class="headerlink" title="什么是Spring框架"></a>什么是Spring框架</h3><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<h3 id="列举一些重要的Spring模块"><a href="#列举一些重要的Spring模块" class="headerlink" title="列举一些重要的Spring模块"></a>列举一些重要的Spring模块</h3><ul>
<li>core：基础，主要提供IOC依赖注入功能。</li>
<li>AOP：面向切面编程的实现</li>
<li>JDBC ：java数据库连接</li>
<li>JMS：消息服务</li>
<li>WEB：创建web应用程序提供支持</li>
<li>Test：提供了对JUnit和TestNG测试的支持。</li>
</ul>
<h3 id="RestController和-Controller"><a href="#RestController和-Controller" class="headerlink" title="@RestController和@Controller"></a>@RestController和@Controller</h3><p>restcontroller在spring4之后才有，之前必须使用controller+responsebody</p>
<h3 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h3><ul>
<li><p>对IOC和AOP的理解</p>
<p>IOC容器实际上就是一个Map(key,value)，存放的是各种对象。spring时代通过xml配置bean，在boot时代通过注解配置bean。</p>
<p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。基于动态代理的。如果代理的对象，实现了某个接口，使用JDK，没有实现的使用CGLAB代理。</p>
</li>
</ul>
<h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><ul>
<li><p>作用域</p>
<ul>
<li>singleton：唯一bean实例，默认是单例。</li>
<li>protype：每次请求都会创建一个新的bean实例</li>
<li>request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session ：每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。</li>
</ul>
</li>
<li><p>单例bean的线程安全</p>
<p>一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p>常见的两种解决办法：</p>
<ul>
<li>在类中定义threadLocal成员变量。</li>
<li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li>
</ul>
</li>
<li><p>@Compnen和@Bean的区别</p>
</li>
<li><p>将一个类声明为Sprng的bean的注解</p>
<p>一般使用<code>@Autowired</code>注解自动装配bean，想把类标识成可用于autowired自动装配的类，可以使用以下注解：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
</li>
<li><p>bean的生命周期</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><ul>
<li><p>对MVC的理解</p>
<p>是一种设计模式。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg" alt="img"></p>
<ul>
<li>Model1时代JSP</li>
<li>Model2时代Bean（model）+JSP（View）+Servlet（controller）</li>
</ul>
</li>
<li><p>MVC的工作原理</p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
</li>
</ul>
<h3 id="Spring框架中用到的设计模式"><a href="#Spring框架中用到的设计模式" class="headerlink" title="Spring框架中用到的设计模式"></a>Spring框架中用到的设计模式</h3><ul>
<li>工厂模式：创建Bean</li>
<li>代理模式：AOP</li>
<li>单例模式：Bean单例模式</li>
<li>包装器设计模式：Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li>观察者模式：事件驱动</li>
</ul>
<h3 id="Spring管理事务"><a href="#Spring管理事务" class="headerlink" title="Spring管理事务"></a>Spring管理事务</h3><ul>
<li><p>管理事务的方式</p>
<ul>
<li><p>编程式，不推荐。</p>
</li>
<li><p>声明式事务</p>
<ul>
<li>基于XML</li>
<li>基于注解</li>
</ul>
</li>
</ul>
</li>
<li><p>事务的隔离级别</p>
</li>
<li><p>哪几种事务传播行为五种</p>
</li>
<li><p>Transactional(rollback=Exception.class)</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
</li>
</ul>
<h3 id="使用JPA在数据库中非持久化一个字段。"><a href="#使用JPA在数据库中非持久化一个字段。" class="headerlink" title="使用JPA在数据库中非持久化一个字段。"></a>使用JPA在数据库中非持久化一个字段。</h3><p>@Transient</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p><a href="https://blog.csdn.net/ThinkWon/article/details/104397299">面试题总结，摘自CSDN</a></p>
<h2 id="面试题总结"><a href="#面试题总结" class="headerlink" title="面试题总结"></a>面试题总结</h2><ul>
<li><p><strong>什么是SpringBoot</strong></p>
</li>
<li><p>SpringBoot的优点(Spring的缺点)</p>
<ol>
<li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li>
<li>开箱即用，远离繁琐的配置。</li>
<li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li>没有代码生成，也不需要XML配置。</li>
<li>避免大量的 Maven 导入和各种版本冲突。</li>
</ol>
</li>
<li><p><strong>核心注解是哪个，由哪几个注解组成</strong></p>
</li>
<li><p><strong>SpringBoot Starters</strong></p>
<ul>
<li>starter是什么</li>
<li>Spring-Boot-Starters-parent有什么用<ol>
<li>定义了 Java 编译版本为 1.8 。</li>
<li>使用 UTF-8 格式编码。</li>
<li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>支持哪些内嵌servlet容器：Tomcat/Jetty/undertow</strong></p>
</li>
<li><p><strong>如何实现自动装配</strong></p>
<ul>
<li>@EnableAutoConfiguration, @Configuration, @ConditionalOnClass</li>
<li>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</li>
<li>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</li>
</ul>
</li>
<li><p><strong>常用注解</strong></p>
<ul>
<li>RestController</li>
<li>GetMapping RequestParam</li>
<li>PostMapping RequestBodt</li>
<li>pathvariable，获取URL中的数据</li>
<li>Bean注解</li>
</ul>
</li>
<li><p><strong>配置文件</strong></p>
<ul>
<li><p>两种配置文件YAML properties</p>
</li>
<li><p>什么是YAML</p>
<p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>
</li>
<li><p>YAML的优势</p>
<ol>
<li>配置有序，在一些特殊的场景下，配置有序很关键</li>
<li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li>
<li>简洁</li>
</ol>
</li>
<li><p>能否使用XML配置文件</p>
<p>@ImportResource 注解可以引入一个 XML 配置。不推荐</p>
</li>
<li><p>读取配置文件的方法</p>
<ul>
<li><p>获取环境变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableApplicationContext ctx = SpringApplication.run(SpringbootPropertiesApplication.class, args);</span><br><span class="line">ctx.getEnvironment().getProperty(<span class="string">&quot;string.port&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>通过注解</p>
<p>@Value(“${string.port}”)     private int intPort;</p>
</li>
</ul>
</li>
<li><p>配置文件优先级</p>
<p><code>spring.config.location</code> &gt; <code>spring.profiles.active</code> &gt; <code>spring.config.additional-location</code> &gt; 默认的 <code>application.proerties</code>。</p>
</li>
</ul>
</li>
<li><p><strong>安全问题</strong></p>
<p> spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p>
</li>
<li><p>跨域问题</p>
<p> <a href="https://victor-huihui.gitee.io/2020/03/19/CORS%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/">跨域</a></p>
</li>
</ul>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p>使用框架开发，一定是越来越简单的。在整合Spring的时候的地狱配置让人头大，于是Boot出现了，而cloud不一样，cloud不是为了改进什么而出现的，它更多是为了适应<code>微服务</code>这一话题而提供的一整套解决方案。既然cloud是一整套的微服务解决方案，那就有必要先来聊聊微服务。</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>这词已经不新鲜了，是一种架构风格，将应用程序构建为以业务业务领域为模型的小型自治服务集合。敏捷团队可以使用可用的框架和所选的技术栈构建单独的服务组件。每个服务组件形成一个强大的微服务架构，从而提供更好的拓展性。可以单独处理每个服务组件的问题，从而对整个应用程序没有影响或者影响最小。</p>
<h3 id="微服务的特点和优点"><a href="#微服务的特点和优点" class="headerlink" title="微服务的特点和优点"></a>微服务的特点和优点</h3><ul>
<li><strong>特点</strong><ul>
<li>解耦</li>
<li>组件化</li>
<li>自治：开发人员和团队可以彼此独立工作，从而提高速度。</li>
<li>持续交付：CICD</li>
<li>敏捷</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>独立开发：微服务可以根据各自的功能轻松开发</li>
<li>独立部署</li>
<li>故障隔离：一项不起作用，系统可以继续运行</li>
<li>混合技术栈：可以使用不同的语言开发。来构建同一个应用的不同服务。</li>
</ul>
</li>
</ul>
<h2 id="cloud"><a href="#cloud" class="headerlink" title="cloud"></a>cloud</h2>]]></content>
      <categories>
        <category>复习入口</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
</search>
